From cb72a726ef856965bb6861c9ae39673ba9265807 Mon Sep 17 00:00:00 2001
From: Zhang Wei E <wei.e.zhang@intel.com>
Date: Fri, 10 May 2024 08:41:39 +0800
Subject: [PATCH 2/8] import dpdk patch into stack

Signed-off-by: Zhang Wei E <wei.e.zhang@intel.com>
---
 .gitignore                                    |    7 +
 Makefile.am                                   |   10 +
 configure.ac                                  |  144 +-
 dpdk/Makefile.am                              |   46 +
 dpdk/ec_dpdk.c                                |  473 +++++++
 dpdk/ecdev.h                                  |   61 +
 .../0001-for-ethercat-statistics.patch        |  155 +++
 examples/Makefile.am                          |    9 +-
 examples/debug/Makefile.am                    |   44 +
 examples/debug/main.c                         |   73 +
 examples/ecatdio/Makefile.am                  |   20 +-
 examples/ecatdio/main.c                       |   26 +
 examples/ecatmotor/Makefile.am                |   67 +
 examples/ecatmotor/main.c                     |  494 +++++++
 examples/ecatmotor/main.h                     |  104 ++
 examples/fly_trigger_poc/Makefile.am          |    5 +-
 examples/multi_axis/Makefile.am               |    5 +-
 examples/soe_axis/Makefile.am                 |    5 +-
 globals.h                                     |  141 ++
 include/Makefile.am                           |    6 +-
 ipc/Makefile.am                               |   53 +
 ipc/ecat_ipc.h                                |    7 +
 ipc/ipc_atomic.h                              |   90 ++
 ipc/ipc_ctrl.c                                |  878 ++++++++++++
 ipc/ipc_ctrl.h                                |   13 +
 ipc/ipc_iface.c                               |   37 +
 ipc/ipc_iface.h                               |   11 +
 ipc/ipc_shm.h                                 |   47 +
 lib/Makefile.am                               |    8 +
 lib/common.c                                  |   13 +
 lib/domain.c                                  |   20 +-
 lib/master.c                                  |  156 +++
 lib/master.h                                  |    4 +
 lib/reg_request.c                             |   23 +
 lib/sdo_request.c                             |   33 +
 lib/slave_config.c                            |  112 ++
 lib/soe_request.c                             |   30 +-
 lib/voe_handler.c                             |   38 +
 master/Makefile.am                            |  198 ++-
 master/cdev.c                                 |    2 +
 master/coe_emerg_ring.c                       |   19 +
 master/datagram.c                             |   63 +-
 master/datagram.h                             |    9 +-
 master/datagram_pair.c                        |   13 +-
 master/datagram_pair.h                        |    7 +-
 master/debug.c                                |   28 +-
 master/debug.h                                |    5 +
 master/device.c                               |  121 +-
 master/device.h                               |   52 +-
 master/domain.c                               |   51 +-
 master/domain.h                               |    7 +-
 master/ecrt_config.c                          |  383 ++++++
 master/ecrt_config.h                          |   31 +
 master/eoe_request.c                          |    5 +-
 master/eoe_request.h                          |    6 +-
 master/ethercatd.c                            |  801 +++++++++++
 master/ethernet.c                             |   34 +-
 master/ethernet.h                             |   14 +-
 master/flag.c                                 |   15 +-
 master/flag.h                                 |    5 +
 master/foe_request.c                          |   28 +-
 master/foe_request.h                          |    9 +-
 master/fsm_change.c                           |   14 +
 master/fsm_coe.c                              |  212 ++-
 master/fsm_foe.c                              |   27 +-
 master/fsm_master.c                           |   47 +-
 master/fsm_pdo.c                              |   21 +-
 master/fsm_pdo_entry.c                        |   17 +-
 master/fsm_sii.c                              |    9 +
 master/fsm_slave.c                            |    6 +
 master/fsm_slave_config.c                     |   38 +-
 master/fsm_slave_scan.c                       |   31 +-
 master/fsm_soe.c                              |   39 +-
 master/globals.h                              |   58 +-
 master/ioctl.c                                | 1178 +++++++++++++----
 master/ioctl.h                                |   35 +-
 master/list.h                                 |  210 +++
 master/mailbox.c                              |   12 +-
 master/master.c                               |  610 +++++++--
 master/master.h                               |   85 +-
 master/mm.h                                   |   72 +
 master/module.c                               |   33 +-
 master/pdo.c                                  |   44 +-
 master/pdo.h                                  |    7 +-
 master/pdo_entry.c                            |   15 +
 master/pdo_entry.h                            |    7 +-
 master/pdo_list.c                             |   29 +-
 master/pdo_list.h                             |    7 +-
 master/reg_request.c                          |   17 +-
 master/reg_request.h                          |    7 +-
 master/rt_locks.h                             |   40 +-
 master/rtdm.c                                 |    9 +-
 master/sdo.c                                  |   13 +
 master/sdo.h                                  |    6 +-
 master/sdo_entry.c                            |    9 +
 master/sdo_entry.h                            |    8 +-
 master/sdo_request.c                          |   41 +-
 master/sdo_request.h                          |   10 +-
 master/slave.c                                |   72 +-
 master/slave.h                                |   17 +-
 master/slave_config.c                         |  156 ++-
 master/slave_config.h                         |   14 +-
 master/soe_request.c                          |   43 +-
 master/soe_request.h                          |    6 +-
 master/voe_handler.c                          |   22 +
 master/voe_handler.h                          |    7 +-
 master/wq.h                                   |   68 +
 script/Makefile.am                            |    6 +-
 script/sysconfig/Makefile.am                  |    6 +
 script/sysconfig/ecrt.conf                    |   15 +
 tool/CommandMaster.cpp                        |    9 +
 tool/Makefile.am                              |    9 +
 tool/MasterDevice.cpp                         |  153 ++-
 tool/MasterDevice.h                           |    4 +
 114 files changed, 8331 insertions(+), 673 deletions(-)
 create mode 100644 dpdk/Makefile.am
 create mode 100644 dpdk/ec_dpdk.c
 create mode 100644 dpdk/ecdev.h
 create mode 100644 dpdk/patches/0001-for-ethercat-statistics.patch
 create mode 100644 examples/debug/Makefile.am
 create mode 100644 examples/debug/main.c
 create mode 100644 examples/ecatmotor/Makefile.am
 create mode 100644 examples/ecatmotor/main.c
 create mode 100644 examples/ecatmotor/main.h
 create mode 100644 ipc/Makefile.am
 create mode 100644 ipc/ecat_ipc.h
 create mode 100644 ipc/ipc_atomic.h
 create mode 100644 ipc/ipc_ctrl.c
 create mode 100644 ipc/ipc_ctrl.h
 create mode 100644 ipc/ipc_iface.c
 create mode 100644 ipc/ipc_iface.h
 create mode 100644 ipc/ipc_shm.h
 create mode 100644 master/ecrt_config.c
 create mode 100644 master/ecrt_config.h
 create mode 100644 master/ethercatd.c
 create mode 100644 master/list.h
 create mode 100644 master/mm.h
 create mode 100644 master/wq.h
 create mode 100644 script/sysconfig/ecrt.conf

diff --git a/.gitignore b/.gitignore
index 694273bd..a1ef94cc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -33,6 +33,9 @@ ethercat.spec
 examples/dc_user/ec_dc_user_example
 examples/user/ec_user_example
 examples/user/build/
+examples/ecatdio/ec_ecatdio_example
+examples/multi_axis/ec_multi_axis_example
+examples/soe_axis/ec_soe_axis_example
 lib/*.cmake
 lib/libethercat.la
 lib/libethercat.pc
@@ -46,3 +49,7 @@ tool/ethercat
 device_drivers.md
 generated_table.md
 doxygen-output/
+master/ethercatd
+master/*.la
+dpdk/*.la
+ipc/*.la
diff --git a/Makefile.am b/Makefile.am
index 650863ee..a6c3b4da 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -36,6 +36,13 @@ SUBDIRS += \
 	master
 endif
 
+if ENABLE_USERMODE
+SUBDIRS += \
+	dpdk \
+	ipc \
+	master
+endif
+
 if BUILD_TOOL
 SUBDIRS += tool
 endif
@@ -105,4 +112,7 @@ doc: device_drivers.md
 cleandoc:
 	@rm -rf doxygen-output generated_table.md device_drivers.md
 
+if ENABLE_USERMODE
+CLEANFILE = *~
+endif
 #-----------------------------------------------------------------------------
diff --git a/configure.ac b/configure.ac
index 7fc8cb4c..492e5a10 100644
--- a/configure.ac
+++ b/configure.ac
@@ -42,6 +42,7 @@ AC_PROG_SED
 PKG_PROG_PKG_CONFIG
 PKG_INSTALLDIR()
 
+#CFLAGS="${CFLAGS} -g"
 #-----------------------------------------------------------------------------
 # Global
 #-----------------------------------------------------------------------------
@@ -51,12 +52,147 @@ m4_ifdef([AM_PROG_AR], [AM_PROG_AR])
 AC_PROG_CXX
 AC_PROG_LIBTOOL
 
+#------------------------------------------------------------------------------
+# Benchmark
+#------------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to build benchmark part])
+
+AC_ARG_ENABLE([benchmark],
+    AS_HELP_STRING([--enable-benchmark],
+                   [Enable building benchmark]),
+    [
+        case "${enableval}" in
+            yes) benchmark=1
+                ;;
+            no) benchmark=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-benchmark])
+                ;;
+        esac
+    ],
+    [benchmark=0]
+)
+if test "x${benchmark}" = "x1"; then
+    AC_DEFINE([EC_BENCHMARK], [1], [benchmark support enabled])
+    AC_MSG_RESULT([yes])
+else
+    AC_MSG_RESULT([no])
+fi
+
+AM_CONDITIONAL(ENABLE_BENCHMARK, test "x${benchmark}" = "x1")
+AC_SUBST(ENABLE_BENCHMARK,[${benchmark}])
+
+
+#------------------------------------------------------------------------------
+# Userspace mode
+#------------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to build userspace mode])
+
+AC_ARG_ENABLE([usermode],
+    AS_HELP_STRING([--enable-usermode],
+                   [Enable building userspace mode]),
+    [
+        case "${enableval}" in
+            yes) usermode=1
+                ;;
+            no) usermode=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-usermode])
+                ;;
+        esac
+    ],
+    [usermode=0]
+)
+
+if test "x${usermode}" = "x1"; then
+    AC_DEFINE([EC_USERMODE], [1], [USERMODE support enabled])
+    AC_MSG_RESULT([yes])
+else
+    AC_MSG_RESULT([no])
+fi
+
+AM_CONDITIONAL(ENABLE_USERMODE, test "x${usermode}" = "x1")
+AC_SUBST(ENABLE_USERMODE,[${usermode}])
+
+if test "x$usermode" = "x1"; then
+PKG_CHECK_MODULES([DPDK], [libdpdk])
+#DPDK support
+AC_ARG_ENABLE(dpdk,
+    AS_HELP_STRING([--enable-dpdk], [Enable DPDK support [default=no]]),
+                  [enable_dpdk=$enableval],[enable_dpdk=no])
+AS_IF([test "x$enable_dpdk" = "xyes"], [
+    AC_CHECK_LIB(numa, numa_available,, [numa_found="no"])
+    if test "$numa_found" = "no"; then
+        echo
+        echo "  ERROR! libnuma not found by pkg-config, go get it"
+        echo "      from http://github.com/numactl/numactl or your distribution:"
+        echo "          Ubuntu: apt-get install libnuma-dev"
+        echo "          Fedora: dnf install numactl-devel"
+        echo "          CentOS/RHEL: yum install numactl-devel"
+        echo
+        exit 1
+    fi
+    AC_DEFINE([HAVE_DPDK],[1],(DPDK support enabled))
+    PKG_CHECK_EXISTS(libdpdk >= 19.11, , [with_pkgconfig_libdpdk=no])
+    if test "$with_pkgconfig_libdpdk" = "no"; then
+        echo
+        echo "   ERROR! libdpdk >= 19.11 not found by pkg-config, go get it"
+        echo "   from https://www.dpdk.org/ or your distribution:"
+        echo
+        echo "   Ubuntu: apt-get install dpdk-dev"
+        echo "   Fedora: dnf install dpdk-devel"
+        echo "   CentOS/RHEL: yum install dpdk-devel"
+        echo
+        exit 1
+    fi
+    CFLAGS="${CFLAGS} `pkg-config --cflags libdpdk`"
+    LIBS="${LIBS} -Wl,-fPIC,-R,`pkg-config --libs-only-L libdpdk | cut -c 3-` -lnuma `pkg-config --libs libdpdk`"
+])
+
+AC_MSG_CHECKING([whether to build ipc in userspace mode])
+
+AC_ARG_ENABLE([daemon],
+    AS_HELP_STRING([--enable-daemon],
+                   [Build master stack as daemon mode in user mode]),
+    [
+        case "${enableval}" in
+            yes) daemon=1
+                ;;
+            no) daemon=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-daemon])
+                ;;
+        esac
+    ],
+    [daemon=0]
+)
+
+if test "x${daemon}" = "x1"; then
+    AC_DEFINE([EC_ENABLE_DAEMON], [1], [Daemon mode enabled])
+    AC_MSG_RESULT([yes])
+else
+    AC_DEFINE([EC_ENABLE_DAEMON], [0], [Daemon mode disabled])
+    AC_MSG_RESULT([no])
+fi
+
+AM_CONDITIONAL(ENABLE_DAEMON, test "x${daemon}" = "x1")
+AC_SUBST(ENABLE_DAEMON,[${daemon}])
+
+else
+AM_CONDITIONAL(ENABLE_DAEMON, 0)
+AC_SUBST(ENABLE_DAEMON,[0])
+fi
+
 #-----------------------------------------------------------------------------
 # Kernel modules
 #-----------------------------------------------------------------------------
 
 AC_MSG_CHECKING([whether to build kernel modules])
 
+if test "x$usermode" = "x0"; then
+
 AC_ARG_ENABLE([kernel],
     AS_HELP_STRING([--enable-kernel],
                    [Enable building kernel modules]),
@@ -73,12 +209,14 @@ AC_ARG_ENABLE([kernel],
     [enablekernel=1]
 )
 
+else
+enablekernel=0
 if test "x$enablekernel" = "x1"; then
     AC_MSG_RESULT([yes])
 else
     AC_MSG_RESULT([no])
 fi
-
+fi
 AM_CONDITIONAL(ENABLE_KERNEL, test "x$enablekernel" = "x1")
 AC_SUBST(ENABLE_KERNEL,[$enablekernel])
 
@@ -1372,6 +1510,7 @@ AC_CONFIG_FILES([
         devices/r8169/Makefile
         devices/stmmac/Kbuild
         devices/stmmac/Makefile
+        dpdk/Makefile
         ethercat.spec
         examples/Kbuild
         examples/Makefile
@@ -1394,9 +1533,12 @@ AC_CONFIG_FILES([
         examples/fly_trigger_poc/Makefile
         examples/multi_axis/Makefile
         examples/soe_axis/Makefile
+        examples/debug/Makefile
+        examples/ecatmotor/Makefile
         include/Makefile
         lib/Makefile
         lib/libethercat.pc
+        ipc/Makefile
         master/Kbuild
         master/Makefile
         script/Makefile
diff --git a/dpdk/Makefile.am b/dpdk/Makefile.am
new file mode 100644
index 00000000..6dc0986d
--- /dev/null
+++ b/dpdk/Makefile.am
@@ -0,0 +1,46 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT master userspace library.
+#
+#  The IgH EtherCAT master userspace library is free software; you can
+#  redistribute it and/or modify it under the terms of the GNU Lesser General
+#  Public License as published by the Free Software Foundation; version 2.1 of
+#  the License.
+#
+#  The IgH EtherCAT master userspace library is distributed in the hope that
+#  it will be useful, but WITHOUT ANY WARRANTY; without even the implied
+#  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with the IgH EtherCAT master userspace library. If not, see
+#  <http://www.gnu.org/licenses/>.
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+lib_LTLIBRARIES = libecat_dpdk.la
+
+#------------------------------------------------------------------------------
+PKGCONF ?= pkg-config
+
+libecat_dpdk_la_SOURCES = \
+	ec_dpdk.c
+
+noinst_HEADERS = \
+	ecdev.h
+
+libecat_dpdk_la_CFLAGS = -fno-strict-aliasing -Wall -Og @DPDK_CFLAGS@ -DALLOW_EXPERIMENTAL_API -msse4.1
+
+libecat_dpdk_la_LDFLAGS = -no-undefined -lpthread @DPDK_LIBS@
+libecat_dpdk_la_LIBS = @DPDK_LIBS@
+
diff --git a/dpdk/ec_dpdk.c b/dpdk/ec_dpdk.c
new file mode 100644
index 00000000..65c47f5f
--- /dev/null
+++ b/dpdk/ec_dpdk.c
@@ -0,0 +1,473 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2020 Intel Corporation
+ */
+
+/*****************************************************************************/
+
+#include "../globals.h"
+#include "ecdev.h"
+#include <rte_string_fns.h>
+
+#define PFX "ec_dpdk: "
+
+#define ETH_P_ETHERCAT 0x88A4
+
+#define EC_GEN_RX_BUF_SIZE 1600
+
+#define RX_RING_SIZE 128
+#define TX_RING_SIZE 128
+#define NUM_MBUFS 8191
+#define MBUF_CACHE_SIZE 512
+#define BURST_SIZE 32
+#define BURST_SIZE_ECAT 1
+
+/*****************************************************************************/
+//#define EC_ETHERCAT_COMM_DEBUG
+static struct rte_mempool *mbuf_pool;
+/*****************************************************************************/
+
+/** \cond */
+
+/** \endcond */
+typedef struct {
+    struct dpdk_dev *dpdkdev;
+    ec_device_t *ecdev;
+    uint8_t *rx_buf;
+} ec_dpdk_device_t;
+
+int ec_dpdk_device_open(struct dpdk_dev *);
+int ec_dpdk_device_stop(struct dpdk_dev *);
+int ec_dpdk_device_start_xmit(struct dpdk_dev *, void *, unsigned len);
+void ec_dpdk_device_poll(struct dpdk_dev *);
+
+static const struct ec_dpdk_ops ec_dpdk_device_ops = {
+    .dpdk_open = ec_dpdk_device_open,
+    .dpdk_stop = ec_dpdk_device_stop,
+    .dpdk_start_xmit = ec_dpdk_device_start_xmit,
+};
+
+/*****************************************************************************/
+/*
+ * Initializes a given port using global settings and with the RX buffers
+ * coming from the mbuf_pool passed as a parameter.
+ */
+static int
+lsi_event_callback(uint16_t port_id, enum rte_eth_event_type type, void *param,
+		    void *ret_param)
+{
+    struct rte_eth_link link;
+    int ret;
+    char link_status_text[RTE_ETH_LINK_MAX_STR_LEN];
+    struct dpdk_dev *dev = param;
+    ec_dpdk_device_t *priv;
+
+    RTE_SET_USED(param);
+    RTE_SET_USED(ret_param);
+    if (!dev) {
+        return 1;
+    }
+    priv = dev->priv;
+
+#ifdef EC_ETHERCAT_COMM_DEBUG
+    printf("Event type: %s\n", type == RTE_ETH_EVENT_INTR_LSC ? "LSC interrupt" : "unknown event");
+#endif
+    ret = rte_eth_link_get_nowait(port_id, &link);
+    if (ret < 0) {
+        printf("Failed link get on port %d: %s\n",
+            port_id, rte_strerror(-ret));
+        return ret;
+    }
+    rte_eth_link_to_str(link_status_text, sizeof(link_status_text), &link);
+#ifdef EC_ETHERCAT_COMM_DEBUG
+    printf("Port %d %s\n\n", port_id, link_status_text);
+#endif
+    if (link.link_status == RTE_ETH_LINK_DOWN) {
+        ecdev_set_link(priv->ecdev, 0);
+    } else {
+        ecdev_set_link(priv->ecdev, 1);
+    }
+
+    return 0;
+}
+
+/* Main functional part of port initialization. 8< */
+static inline int
+ec_dpdk_port_init(struct dpdk_dev *dev, struct rte_mempool *mbuf_pool)
+{
+    struct rte_eth_conf port_conf;
+    const uint16_t rx_rings = 1, tx_rings = 1;
+    uint16_t nb_rxd = RX_RING_SIZE;
+    uint16_t nb_txd = TX_RING_SIZE;
+    int retval;
+    uint16_t q;
+    struct rte_eth_dev_info dev_info;
+    struct rte_eth_txconf txconf;
+
+    if (!dev || !rte_eth_dev_is_valid_port(dev->portid))
+        return -1;
+
+    memset(&port_conf, 0, sizeof(struct rte_eth_conf));
+
+    retval = rte_eth_dev_info_get(dev->portid, &dev_info);
+    if (retval != 0) {
+        printf("Error during getting device (port %u) info: %s\n",
+                dev->portid, strerror(-retval));
+        return retval;
+    }
+
+    port_conf.link_speeds = RTE_ETH_LINK_SPEED_100M;   /*Set the link speed to 100Mbps*/
+    port_conf.intr_conf.lsc = 1;
+    /* Configure the Ethernet device. */
+    retval = rte_eth_dev_configure(dev->portid, rx_rings, tx_rings, &port_conf);
+    if (retval != 0)
+        return retval;
+
+    rte_eth_dev_callback_register(dev->portid,
+        RTE_ETH_EVENT_INTR_LSC, lsi_event_callback, dev);
+    retval = rte_eth_dev_adjust_nb_rx_tx_desc(dev->portid, &nb_rxd, &nb_txd);
+    if (retval != 0)
+        return retval;
+
+    /* Allocate and set up 1 RX queue per Ethernet port. */
+    for (q = 0; q < rx_rings; q++) {
+        retval = rte_eth_rx_queue_setup(dev->portid, q, nb_rxd,
+                rte_eth_dev_socket_id(dev->portid), NULL, mbuf_pool);
+        if (retval < 0)
+            return retval;
+    }
+
+    txconf = dev_info.default_txconf;
+    txconf.offloads = port_conf.txmode.offloads;
+    /* Allocate and set up 1 TX queue per Ethernet port. */
+    for (q = 0; q < tx_rings; q++) {
+        retval = rte_eth_tx_queue_setup(dev->portid, q, nb_txd,
+                rte_eth_dev_socket_id(dev->portid), &txconf);
+        if (retval < 0)
+            return retval;
+    }
+    retval = rte_eth_dev_start(dev->portid);
+    /* >8 End of starting of ethernet port. */
+    if (retval < 0)
+        return retval;
+
+    /* Display the port MAC address. */
+    struct rte_ether_addr addr;
+    retval = rte_eth_macaddr_get(dev->portid, &addr);
+    if (retval != 0)
+        return retval;
+
+#ifdef EC_ETHERCAT_COMM_DEBUG
+    printf("Port %u MAC: %02" PRIx8 " %02" PRIx8 " %02" PRIx8
+               " %02" PRIx8 " %02" PRIx8 " %02" PRIx8 "\n",
+            dev->portid, RTE_ETHER_ADDR_BYTES(&addr));
+#endif
+
+    /* Enable RX in promiscuous mode for the Ethernet device. */
+    retval = rte_eth_promiscuous_enable(dev->portid);
+    /* End of setting RX port in promiscuous mode. */
+    if (retval != 0)
+        return retval;
+
+    return 0;
+}
+
+#ifdef EC_ETHERCAT_COMM_DEBUG
+/** Outputs frame contents for debugging purposes.
+ * If the data block is larger than 256 bytes, only the first 128
+ * and the last 128 bytes will be shown
+ */
+static void ec_dpdk_dump_data(const uint8_t *data, /**< pointer to data */
+                   size_t size /**< number of bytes to output */
+                   )
+{
+    unsigned int i;
+
+    printf("dpdk dump:\n");
+    printf(" ");
+    for (i = 0; i < size; i++) {
+        printf("%02X ", data[i]);
+
+        if ((i + 1) % 16 == 0 && i < size - 1) {
+            printf("\n");
+            printf("");
+        }
+
+        if (i + 1 == 128 && size > 256) {
+            printf("dropped %zu bytes\n", size - 128 - i);
+            i = size - 128;
+            printf("");
+        }
+    }
+    printf("\n");
+}
+#endif
+
+/** Open the device.
+ */
+int ec_dpdk_device_open(struct dpdk_dev *dev)
+{
+    int nb_ports = 1;
+    struct rte_mbuf* txbuf;
+
+    if (!dev) {
+        return 0;
+    }
+    /* Allocates mempool to hold the mbufs. 8< */
+    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", NUM_MBUFS * nb_ports,
+        MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());
+    /* >8 End of allocating mempool to hold mbuf. */
+
+    if (mbuf_pool == NULL)
+        rte_exit(EXIT_FAILURE, "Cannot create mbuf pool\n");
+
+    txbuf = rte_pktmbuf_alloc(mbuf_pool);
+    if(txbuf == NULL)
+    {
+        printf("txbuf allocate failed\n");
+        return 0;
+    }
+    dev->txbuf = (uint8_t*)txbuf;
+    int retval = ec_dpdk_port_init(dev, mbuf_pool);
+    if (retval < 0)
+        return retval;
+    /*
+     * Check that the port is on the same NUMA node as the polling thread
+
+     * for best performance.
+     */
+    if (rte_eth_dev_socket_id(dev->portid) >= 0 && \
+            rte_eth_dev_socket_id(dev->portid) != \
+                    (int)rte_socket_id())
+        printf("WARNING, port %u is on remote NUMA node to "
+                "polling thread.\n\tPerformance will "
+                "not be optimal.\n", dev->portid);
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+/** Stop the device.
+ */
+int ec_dpdk_device_stop(struct dpdk_dev *dev)
+{
+    ec_dpdk_device_t *priv;
+    int retval = 0;
+
+    if (!dev) {
+        return 1;
+    }
+    priv = dev->priv;
+    if (priv == NULL) {
+        return -1;
+    }
+    if (priv->ecdev) {
+        ecdev_close(priv->ecdev);
+        ecdev_withdraw(priv->ecdev);
+        rte_eth_dev_stop(dev->portid);
+        priv->ecdev = NULL;
+    }
+    if (dev->txbuf){
+        rte_pktmbuf_free(dev->txbuf);
+	dev->txbuf = NULL;
+    }
+    return 0;
+}
+
+/*****************************************************************************/
+
+static inline void
+copy_buf_to_pkt(void* buf, unsigned len, struct rte_mbuf *pkt, unsigned offset)
+{
+    if (!pkt || !buf) {
+        return;
+    }
+    if (offset + len <= pkt->data_len)
+    {
+        rte_memcpy(rte_pktmbuf_mtod_offset(pkt, char *, offset), buf, (size_t) len);
+        return;
+    }else
+        printf("pkg too small(%d:%d)\n", len, pkt->data_len);
+}
+
+int ec_dpdk_device_start_xmit(struct dpdk_dev *dev,
+        void *buff, unsigned len)
+{
+    uint16_t nb_tx;
+    struct rte_mbuf *tx_buff;
+    ec_dpdk_device_t *priv;
+
+    if (!dev) {
+        return 0;
+    }
+    priv = dev->priv;
+    if (!ecdev_get_link(priv->ecdev)) {
+	return 0;
+    }
+
+    if (!dev->txbuf)
+        return 0;
+    tx_buff = (struct rte_mbuf*)dev->txbuf;
+    tx_buff->data_len = len;
+    tx_buff->l2_len = sizeof(struct rte_ether_addr);
+    tx_buff->nb_segs = 1;
+    tx_buff->pkt_len = len;
+    copy_buf_to_pkt(buff, len, tx_buff, 0);
+
+    nb_tx = rte_eth_tx_burst(dev->portid, 0, &tx_buff, 1);
+#ifdef EC_BENCHMARK
+    dev->dpdk_tx_sw_end_time = tx_buff->ec_dpdk_time.tx_sw_end_time;
+#endif
+    return nb_tx==1 ? 0:1;
+}
+
+/*****************************************************************************/
+
+/** Polls the device.
+ */
+void ec_dpdk_device_poll(struct dpdk_dev *dev)
+{
+    int budget = 10; // FIXME
+    struct rte_mbuf *bufs;
+    uint16_t nb_rx = 0;
+    ec_dpdk_device_t *priv;
+
+    if (!dev)
+        return;
+    priv = dev->priv;
+
+    if (!ecdev_get_link(priv->ecdev)) {
+        return;
+    }
+    do {
+        nb_rx = rte_eth_rx_burst(dev->portid, 0, &bufs, 1);
+
+        if (nb_rx > 0) {
+#ifdef EC_BENCHMARK
+            dev->dpdk_rx_hw_end_time = bufs->ec_dpdk_time.rx_hw_end_time;
+#endif
+            priv->rx_buf = rte_pktmbuf_mtod_offset(bufs, char *, 0);
+            ecdev_receive(priv->ecdev, priv->rx_buf, bufs->data_len);
+        } else if (nb_rx < 0) {
+            printf("no recv\n");
+            break;
+        }
+        budget--;
+    } while (budget);
+}
+
+static inline int ec_dpdk_is_same_addr(unsigned char *mac, struct rte_ether_addr *addr)
+{
+    int i;
+    if ((!mac)||(!addr)) {
+        return 0;
+    }
+    for (i = 0; i < 6; i++)
+        if (addr->addr_bytes[i] != mac[i])
+            return 0;
+    return 1;
+}
+
+#define MAX_ARGS_COUNT (100)
+/*****************************************************************************/
+
+/** Module initialization.
+ *
+ * Initializes \a master_count masters.
+ * \return 0 on success, else < 0
+ */
+int ec_dpdk_bind(unsigned char *mac, char* argv)
+{
+    int ret = 0;
+    uint8_t port;
+    struct dpdk_dev *dpdkdev;
+    ec_dpdk_device_t *dev;
+    struct rte_ether_addr addr;
+
+    char *arguments = argv;
+    uint8_t argc = 0;
+    const char* dpdk_drv = "ec_dpdk";
+    char *arg[MAX_ARGS_COUNT];
+
+    arg[0] = dpdk_drv;
+    argc++;
+    if (arguments != NULL) {
+        do {
+            arg[argc] = strtok(arguments, " ");
+            if (arg[argc] == NULL) {
+                break;
+            }
+            argc++;
+            arguments = NULL;
+        } while (argc < MAX_ARGS_COUNT-1);
+    }
+
+    /* Initializion the Environment Abstraction Layer (EAL). 8< */
+    ret = rte_eal_init(argc, &arg);
+    if (ret < 0) {
+        rte_exit(EXIT_FAILURE, "Cannot init EAL: %s\n",
+                rte_strerror(rte_errno));
+    }
+    RTE_ETH_FOREACH_DEV(port) {
+        if (rte_eth_macaddr_get(port, &addr) != 0)
+        {
+            printf("Warning, port %u cannot get mac address\n", port);
+            continue;
+        }
+        if (ec_dpdk_is_same_addr(mac, &addr) == 0)
+            continue;
+        dev = malloc(sizeof(ec_dpdk_device_t));
+        if (!dev) {
+            ret = -ENOMEM;
+            return ret;
+        }
+
+        // Initial device
+        dpdkdev = malloc(sizeof(struct dpdk_dev));
+        if (!dpdkdev) {
+            free(dev);
+            ret = -ENOMEM;
+            return ret;
+        }
+        dpdkdev->portid = port;
+        dpdkdev->dpdk_ops = &ec_dpdk_device_ops;
+	memcpy(dpdkdev->mac, mac, ETH_ALEN);
+        dpdkdev->priv = dev;
+        dev->dpdkdev = dpdkdev;
+        dev->ecdev = NULL;
+        dev->ecdev = ecdev_offer(dev->dpdkdev, ec_dpdk_device_poll);
+        if (dev->ecdev) {
+            if (ecdev_open(dev->ecdev)) {
+                ecdev_withdraw(dev->ecdev);
+                dev->ecdev = NULL;
+            } else {
+                ret = 1;
+            }
+	}
+	break;
+    }
+
+    return ret;
+}
+
+/*****************************************************************************/
+
+/** Module cleanup.
+ *
+ * Clears all master instances.
+ */
+void ec_dpdk_cleanup(void)
+{
+#ifdef EC_ETHERCAT_COMM_DEBUG
+	printf("ec_dpdk_cleanup: Enter\n");
+#endif
+}
+
+/*****************************************************************************/
+
+/** \cond */
+
+
+/** \endcond */
+
+/*****************************************************************************/
diff --git a/dpdk/ecdev.h b/dpdk/ecdev.h
new file mode 100644
index 00000000..0b9e66cc
--- /dev/null
+++ b/dpdk/ecdev.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2020 Intel Corporation
+ */
+
+#ifndef __ECDEV_H__
+#define __ECDEV_H__
+
+#include <rte_eal.h>
+#include <rte_ethdev.h>
+#include <rte_cycles.h>
+#include <rte_lcore.h>
+#include <rte_mbuf.h>
+
+/*****************************************************************************/
+
+typedef struct ec_dpdk_ops {
+    int (*dpdk_open)(struct dpdk_dev *dev);
+    int (*dpdk_stop)(struct dpdk_dev *dev);
+    void* (*dpdk_start_xmit)(struct dpdk_dev *dev, void *buff, unsigned len);
+} ec_dpdk_ops_t;
+
+typedef struct dpdk_dev {
+    uint16_t portid;
+    uint8_t *mac[ETH_ALEN];
+    void *priv;
+    uint8_t *txbuf;
+    struct ec_dpdk_ops *dpdk_ops;
+#ifdef EC_BENCHMARK
+    uint64_t dpdk_tx_sw_end_time;
+    uint64_t dpdk_rx_hw_end_time;
+#endif
+} dpdk_dev_t;
+
+struct ec_device;
+typedef struct ec_device ec_device_t; /**< \see ec_device */
+
+/** Device poll function type.
+ */
+typedef void (*ec_pollfunc_t)(struct dpdk_dev *);
+
+/******************************************************************************
+ * Offering/withdrawal functions
+ *****************************************************************************/
+
+ec_device_t *ecdev_offer(struct dpdk_dev *dpdk_dev, ec_pollfunc_t poll);
+void ecdev_withdraw(ec_device_t *device);
+
+int ec_dpdk_bind(unsigned char *mac, char* argv);
+/******************************************************************************
+ * Device methods
+ *****************************************************************************/
+
+int ecdev_open(ec_device_t *device);
+void ecdev_close(ec_device_t *device);
+void ecdev_receive(ec_device_t *device, const void *data, size_t size);
+void ecdev_set_link(ec_device_t *device, uint8_t state);
+uint8_t ecdev_get_link(const ec_device_t *device);
+
+/*****************************************************************************/
+
+#endif
diff --git a/dpdk/patches/0001-for-ethercat-statistics.patch b/dpdk/patches/0001-for-ethercat-statistics.patch
new file mode 100644
index 00000000..a39c7131
--- /dev/null
+++ b/dpdk/patches/0001-for-ethercat-statistics.patch
@@ -0,0 +1,155 @@
+From 8616d39ab85fdba13aabf667483c96d8ba684ecc Mon Sep 17 00:00:00 2001
+From: nacui <nacui@intel.com>
+Date: Mon, 19 Jun 2023 15:22:56 +0800
+Subject: [PATCH] patch for tx/ra latency statistics
+
+Signed-off-by: nacui <nacui@intel.com>
+---
+ drivers/net/e1000/igb_rxtx.c | 14 ++++++++++++++
+ drivers/net/igc/igc_txrx.c   | 16 ++++++++++++++++
+ lib/mbuf/rte_mbuf_core.h     | 14 +++++++++++++-
+ 3 files changed, 43 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/e1000/igb_rxtx.c b/drivers/net/e1000/igb_rxtx.c
+index f32dee46df..96a99ab637 100644
+--- a/drivers/net/e1000/igb_rxtx.c
++++ b/drivers/net/e1000/igb_rxtx.c
+@@ -400,6 +400,7 @@ eth_igb_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts,
+ 	uint32_t new_ctx = 0;
+ 	uint32_t ctx = 0;
+ 	union igb_tx_offload tx_offload = {0};
++	struct timespec tx_sw_end_time;
+ 
+ 	txq = tx_queue;
+ 	sw_ring = txq->sw_ring;
+@@ -608,6 +609,15 @@ eth_igb_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts,
+ 	PMD_TX_LOG(DEBUG, "port_id=%u queue_id=%u tx_tail=%u nb_tx=%u",
+ 		   (unsigned) txq->port_id, (unsigned) txq->queue_id,
+ 		   (unsigned) tx_id, (unsigned) nb_tx);
++	
++	/* check if HW has sent the packet */ 
++	clock_gettime(CLOCK_MONOTONIC, &tx_sw_end_time);
++	tx_pkt->ec_dpdk_time.tx_sw_end_time = TIMESPEC2NS(tx_sw_end_time);
++	while(1) {
++		if(eth_igb_tx_descriptor_status(txq, 0) == RTE_ETH_TX_DESC_DONE)
++			break;
++	}
++	
+ 	txq->tx_tail = tx_id;
+ 
+ 	return nb_tx;
+@@ -821,6 +831,7 @@ eth_igb_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
+ 	uint16_t nb_rx;
+ 	uint16_t nb_hold;
+ 	uint64_t pkt_flags;
++	struct timespec rx_hw_end_time;
+ 
+ 	nb_rx = 0;
+ 	nb_hold = 0;
+@@ -841,6 +852,8 @@ eth_igb_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
+ 		staterr = rxdp->wb.upper.status_error;
+ 		if (! (staterr & rte_cpu_to_le_32(E1000_RXD_STAT_DD)))
+ 			break;
++		/* HW has received the packet */
++		clock_gettime(CLOCK_MONOTONIC, &rx_hw_end_time);
+ 		rxd = *rxdp;
+ 
+ 		/*
+@@ -957,6 +970,7 @@ eth_igb_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
+ 		 * Store the mbuf address into the next entry of the array
+ 		 * of returned packets.
+ 		 */
++		rxm->ec_dpdk_time.rx_hw_end_time = TIMESPEC2NS(rx_hw_end_time);
+ 		rx_pkts[nb_rx++] = rxm;
+ 	}
+ 	rxq->rx_tail = rx_id;
+diff --git a/drivers/net/igc/igc_txrx.c b/drivers/net/igc/igc_txrx.c
+index c11b6f7f25..f5a7fbe061 100644
+--- a/drivers/net/igc/igc_txrx.c
++++ b/drivers/net/igc/igc_txrx.c
+@@ -242,6 +242,9 @@ igc_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+ 	uint16_t rx_id = rxq->rx_tail;
+ 	uint16_t nb_rx = 0;
+ 	uint16_t nb_hold = 0;
++	struct timespec rx_hw_end_time;
++
++	
+ 
+ 	while (nb_rx < nb_pkts) {
+ 		volatile union igc_adv_rx_desc *rxdp;
+@@ -264,6 +267,8 @@ igc_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+ 		staterr = rte_cpu_to_le_32(rxdp->wb.upper.status_error);
+ 		if (!(staterr & IGC_RXD_STAT_DD))
+ 			break;
++        /* HW has received the packet */
++        clock_gettime(CLOCK_MONOTONIC, &rx_hw_end_time);
+ 		rxd = *rxdp;
+ 
+ 		/*
+@@ -365,6 +370,7 @@ igc_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+ 		 * Store the mbuf address into the next entry of the array
+ 		 * of returned packets.
+ 		 */
++        rxm->ec_dpdk_time.rx_hw_end_time = TIMESPEC2NS(rx_hw_end_time);
+ 		rx_pkts[nb_rx++] = rxm;
+ 	}
+ 	rxq->rx_tail = rx_id;
+@@ -1573,6 +1579,7 @@ igc_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
+ 	uint32_t new_ctx = 0;
+ 	union igc_tx_offload tx_offload = {0};
+ 	uint64_t ts;
++    struct timespec tx_sw_end_time;
+ 
+ 	tx_id = txq->tx_tail;
+ 	txe = &sw_ring[tx_id];
+@@ -1787,6 +1794,15 @@ igc_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
+ 	IGC_PCI_REG_WRITE_RELAXED(txq->tdt_reg_addr, tx_id);
+ 	PMD_TX_LOG(DEBUG, "port_id=%u queue_id=%u tx_tail=%u nb_tx=%u",
+ 		txq->port_id, txq->queue_id, tx_id, nb_tx);
++	
++	/* check if HW has sent the packet */ 
++	clock_gettime(CLOCK_MONOTONIC, &tx_sw_end_time);
++	tx_pkt->ec_dpdk_time.tx_sw_end_time = TIMESPEC2NS(tx_sw_end_time);
++	while(1) {
++		if(eth_igc_tx_descriptor_status(txq, 0) == RTE_ETH_TX_DESC_DONE)
++			break;
++	}
++	
+ 	txq->tx_tail = tx_id;
+ 
+ 	return nb_tx;
+diff --git a/lib/mbuf/rte_mbuf_core.h b/lib/mbuf/rte_mbuf_core.h
+index c692c33ec4..d081cae11e 100644
+--- a/lib/mbuf/rte_mbuf_core.h
++++ b/lib/mbuf/rte_mbuf_core.h
+@@ -459,6 +459,15 @@ enum {
+ #endif
+ };
+ 
++#define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
++
++struct ec_dpdk_time_t {
++	/** the time when a tx packet has been sent to DMA */
++	uint64_t tx_sw_end_time;
++	/** the time when a rx packet has been received in DMA */
++	uint64_t rx_hw_end_time;
++};
++
+ /**
+  * The generic rte_mbuf, containing a packet mbuf.
+  */
+@@ -664,7 +673,10 @@ struct rte_mbuf {
+ 	/** Timesync flags for use with IEEE1588. */
+ 	uint16_t timesync;
+ 
+-	uint32_t dynfield1[9]; /**< Reserved for dynamic fields. */
++	/** Timestamp for EtherCAT over DPDK */
++	struct ec_dpdk_time_t ec_dpdk_time;
++
++	uint32_t dynfield1[1]; /**< Reserved for dynamic fields. */
+ } __rte_cache_aligned;
+ 
+ /**
+-- 
+2.34.1
+
diff --git a/examples/Makefile.am b/examples/Makefile.am
index 7307c7e1..a6789c44 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -21,7 +21,7 @@
 
 include $(top_srcdir)/Makefile.kbuild
 
-SUBDIRS = multi_axis ecatdio soe_axis
+SUBDIRS = multi_axis ecatdio soe_axis ecatmotor
 
 if ENABLE_USERLIB
 SUBDIRS += \
@@ -53,6 +53,13 @@ SUBDIRS += \
 endif
 endif
 
+if ENABLE_USERMODE
+if !ENABLE_DAEMON
+SUBDIRS += \
+	debug
+endif
+endif
+
 # Here DIST_SUBDIRS needs to be explicitely defined because
 # dc_rtai, mini and rtai are never added to `SUBDIRS`
 DIST_SUBDIRS = \
diff --git a/examples/debug/Makefile.am b/examples/debug/Makefile.am
new file mode 100644
index 00000000..f43926da
--- /dev/null
+++ b/examples/debug/Makefile.am
@@ -0,0 +1,44 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_debug_example
+
+ec_debug_example_SOURCES = main.c
+
+ec_debug_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+ec_debug_example_LDFLAGS = \
+	-lrt
+ec_debug_example_LDFLAGS += \
+	-L$(top_builddir)/master/.libs -lethercatd
+
+#------------------------------------------------------------------------------
diff --git a/examples/debug/main.c b/examples/debug/main.c
new file mode 100644
index 00000000..a3758c15
--- /dev/null
+++ b/examples/debug/main.c
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include "ecrt.h"
+
+static volatile int run = 1;
+static ec_master_t *master = NULL;
+
+void signal_handler(int sig)
+{
+    run = 0;
+}
+
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0);
+    if (!master) {
+        return -1;
+    }
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    while (run) {
+        sleep(1);
+    }
+
+    ecrt_release_master(master);
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/ecatdio/Makefile.am b/examples/ecatdio/Makefile.am
index dca8720f..bce2b829 100644
--- a/examples/ecatdio/Makefile.am
+++ b/examples/ecatdio/Makefile.am
@@ -31,16 +31,18 @@ noinst_PROGRAMS = ec_ecatdio_example
 
 ec_ecatdio_example_SOURCES = main.c
 
-if ENABLE_XENOMAI
+if ENABLE_XENOMAI_V3
 ec_ecatdio_example_CFLAGS = \
 	-Wall \
 	-lm  \
 	-I$(top_srcdir)/include \
-	$(XENOMAI_POSIX_CFLAGS)
+	$(XENOMAI_POSIX_CFLAGS) \
+	-DXENOMAI_API_V3
 
 ec_ecatdio_example_LDFLAGS = \
 	-L$(top_builddir)/lib/.libs -lethercat_rtdm -lmodbus \
 	$(XENOMAI_POSIX_LDFLAGS)
+
 else
 ec_ecatdio_example_CFLAGS = \
 	-Wall \
@@ -48,7 +50,19 @@ ec_ecatdio_example_CFLAGS = \
 	-I$(top_srcdir)/include
 
 ec_ecatdio_example_LDFLAGS = \
-	-L$(top_builddir)/lib/.libs -lethercat -lrt -lpthread -lmodbus
+	-lrt -lpthread -lmodbus
+if ENABLE_USERMODE
+if ENABLE_DAEMON
+ec_ecatdio_example_LDFLAGS += \
+	-L$(top_builddir)/lib/.libs -lethercat -DEC_ENABLE_DAEMON=1
+else
+ec_ecatdio_example_LDFLAGS += \
+	-L$(top_builddir)/master/.libs -lethercatd
+endif
+else
+ec_ecatdio_example_LDFLAGS += \
+	-L$(top_builddir)/lib/.libs -lethercat -DEC_ENABLE_DAEMON=1
+endif
 endif
 
 #------------------------------------------------------------------------------
diff --git a/examples/ecatdio/main.c b/examples/ecatdio/main.c
index 0595e713..171f8150 100644
--- a/examples/ecatdio/main.c
+++ b/examples/ecatdio/main.c
@@ -270,6 +270,10 @@ static void getOptions(int argc, char **argv)
  ***************************************************************************/
 int main(int argc, char *argv[])
 {
+#if !EC_ENABLE_DAEMON
+    int ret;
+    ec_slave_info_t slave_info;
+#endif
     getOptions(argc,argv);
     data_init();
     signal(SIGTERM, signal_handler);
@@ -281,6 +285,28 @@ int main(int argc, char *argv[])
     if (!master) {
         return -1;
     }
+#if !EC_ENABLE_DAEMON
+    printf("Getting master state...\n");
+    ecrt_master_state(master, &master_state);
+    while (1){
+        ecrt_master_state(master, &master_state);
+	if ((master_state.slaves_responding == 1)&&(master_state.al_states&0x0E))
+           break;
+        sleep(0.01);
+    };
+    printf("Getting slave info...\n");
+    while(1)
+    {
+	ret = ecrt_master_get_slave(master, 0, &slave_info);
+	if (ret != 0) {
+	    printf("Error in getting slave info\n");
+	} else if ((slave_info.al_state >= EC_AL_STATE_PREOP)) {
+	    printf("slave info state=%d\n",slave_info.al_state);
+	    break;
+	}
+        sleep(0.01);
+    };
+#endif
 
     printf("Creating domain ...\n");
     domain = ecrt_master_create_domain(master);
diff --git a/examples/ecatmotor/Makefile.am b/examples/ecatmotor/Makefile.am
new file mode 100644
index 00000000..e451d963
--- /dev/null
+++ b/examples/ecatmotor/Makefile.am
@@ -0,0 +1,67 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_motor_example
+
+ec_motor_example_SOURCES = main.c
+
+if ENABLE_XENOMAI_V3
+ec_motor_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS) \
+	-DXENOMAI_API_V3
+
+ec_motor_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm \
+	$(XENOMAI_POSIX_LDFLAGS)
+else
+ec_motor_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+ec_motor_example_LDFLAGS = \
+	-lrt -lpthread
+if ENABLE_USERMODE
+if ENABLE_DAEMON
+ec_motor_example_LDFLAGS += \
+	-L$(top_builddir)/lib/.libs -lethercat -DEC_ENABLE_DAEMON=1
+else
+ec_motor_example_LDFLAGS += \
+	-L$(top_builddir)/master/.libs -lethercatd
+endif
+else
+ec_motor_example_LDFLAGS += \
+	-L$(top_builddir)/lib/.libs -lethercat -DEC_ENABLE_DAEMON=1
+endif
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/ecatmotor/main.c b/examples/ecatmotor/main.c
new file mode 100644
index 00000000..c85bfa1a
--- /dev/null
+++ b/examples/ecatmotor/main.c
@@ -0,0 +1,494 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+#include "main.h"
+#include <getopt.h>
+
+static double set_tar_vel = 1.0;
+static int master_id = 0;
+static pthread_t cyclic_thread;
+static volatile int run = 1;
+
+static int slave_id = 0;
+static int operation_mode = MODE_CSP;
+static ec_sync_info_t* servo_syncs;
+static int slave_decord_per_cycle;
+
+static ec_master_t *master = NULL;
+static ec_master_state_t master_state = {};
+static Slave_Data ec_slave0;
+
+static ec_domain_t *domain = NULL;
+static uint8_t *domain_pd = NULL;
+static ec_slave_config_t *sc;
+static ec_pdo_entry_reg_t* domain_regs;
+
+static volatile int sem_update = 0;
+int64_t latency_min_ns = 1000000, latency_sum_ns = 0, latency_max_ns = -1000000;
+int64_t exec_min_ns = 1000000, exec_sum_ns = 0, exec_max_ns = -1000000;
+int32_t dc_diff_min=0x7fffffff, dc_diff_max = 0;
+uint64_t count = 0;
+
+const static ec_pdo_entry_reg_t inov_is620n_regs[] = {
+    // Inovance IS620N CoE EtherCAT Slave ID = 0
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x6040, 0x00, &ec_slave0.ctrl_word, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x607a, 0x00, &ec_slave0.tar_pos, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x60FF, 0x00, &ec_slave0.tar_vel, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x6060, 0x00, &ec_slave0.mode_sel, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x6041, 0x00, &ec_slave0.status_word, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x6064, 0x00, &ec_slave0.act_pos, NULL},
+    {INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID, 0x606c, 0x00, &ec_slave0.act_vel, NULL},
+    {}
+};
+
+const static ec_pdo_entry_reg_t hiwin_d2_regs[] = {
+    // Hiwin D2 CoE EtherCAT Slave ID = 1
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x6040, 0x00, &ec_slave0.ctrl_word, NULL},
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x607a, 0x00, &ec_slave0.tar_pos, NULL},
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x60FF, 0x00, &ec_slave0.tar_vel, NULL},
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x6041, 0x00, &ec_slave0.status_word, NULL},
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x6064, 0x00, &ec_slave0.act_pos, NULL},
+    {HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID, 0x606c, 0x00, &ec_slave0.act_vel, NULL},
+    {}
+};
+
+static void data_init(void)
+{
+    memset(&ec_slave0,0,sizeof(Slave_Data));
+    sc = NULL;
+}
+
+static void ec_slave_config_init(ec_slave_config_t *sc)
+{
+    /* Clear RxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 0); /*clear sm pdo 0x1c12*/
+    ecrt_slave_config_sdo8(sc, 0x1600, 0, 0); /*clear sm pdo 0x1600*/
+    /* Clear TxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 0); /*clear sm pdo 0x1600*/
+    ecrt_slave_config_sdo8(sc, 0x1A00, 0, 0); /*clear sm pdo 0x1A00*/
+}
+
+void rt_check_master_state(void)
+{
+    ec_master_state_t ms;
+    ecrt_master_state(master, &ms);
+    if (ms.slaves_responding != master_state.slaves_responding)
+        printf("%u slave(s).\n", ms.slaves_responding);
+    if (ms.al_states != master_state.al_states)
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    if (ms.link_up != master_state.link_up)
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+    master_state = ms;
+}
+
+static uint16_t coe_cia402_statemachine(uint16_t status)
+{
+    if ((status&0x4F) == 0x0) {         // Not ready to Switch on
+        return 0x80;
+    } else if ((status&0x4F) == 0x40) { // Switch on Disabled
+        return 0x6;
+    } else if ((status&0x6F) == 0x21) { // Ready to Switch on
+        return 0x7;
+    } else if ((status&0x6F) == 0x23) { // Switch on
+        return 0xF;
+    } else if ((status&0x6F) == 0x27) { // Operation enabled
+        return 0x1F;
+    } else if ((status&0x6F) == 0x07) { // Quick stop active
+        return 0x0;
+    } else if ((status&0x4F) == 0x0F) { // Fault reaction active
+        return 0x80;
+    } else if ((status&0x4F) == 0x08) { // Fault
+        return 0x80;
+    }
+    return 0x80;
+}
+
+static void ec_readmotordata(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    ec_motor->statusword 	= EC_READ_U16(domain_pd + ec_slave.status_word);
+    ec_motor->actualpos  	= EC_READ_S32(domain_pd + ec_slave.act_pos);
+    ec_motor->actualvel  	= EC_READ_S32(domain_pd + ec_slave.act_vel);
+
+    ec_motor->controlword = coe_cia402_statemachine(ec_motor->statusword);
+}
+
+static void ec_writemotordata(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    if (operation_mode == MODE_CSP) {
+        EC_WRITE_S32(domain_pd+ec_slave.tar_pos, ec_motor->targetpos );
+        if (slave_id == 0) {
+            EC_WRITE_U8(domain_pd+ec_slave.mode_sel, MODE_CSP);
+        }
+    } else if (operation_mode == MODE_CSV) {
+        EC_WRITE_S32(domain_pd+ec_slave.tar_vel, ec_motor->targetvel );
+        if (slave_id == 0) {
+            EC_WRITE_U8(domain_pd+ec_slave.mode_sel, MODE_CSV);
+        }
+    }
+    EC_WRITE_U16(domain_pd+ec_slave.ctrl_word, ec_motor->controlword );
+    ec_motor->prevel = ec_motor->actualvel;
+    ec_motor->prevpos = ec_motor->actualpos;
+}
+
+void *my_thread(void *arg)
+{
+    struct timespec next_period, dc_period, exec_start, exec_end;
+    unsigned int cycle_counter = 0;
+    Ctl_Data ec_motor0;
+    static bool init_pos_flag = 0;
+    int32_t dc_diff = 0;
+    int64_t latency_ns = 0, exec_ns = 0;
+
+    struct sched_param param = {.sched_priority = 99};
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+    clock_gettime(CLOCK_MONOTONIC, &next_period);
+    memset(&ec_motor0,0,sizeof(Ctl_Data));
+
+    while (run) {
+        next_period.tv_nsec += CYCLE_US * 1000;
+        while (next_period.tv_nsec >= NSEC_PER_SEC) {
+            next_period.tv_nsec -= NSEC_PER_SEC;
+            next_period.tv_sec++;
+        }
+        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_period, NULL);
+        cycle_counter++;
+        count++;
+        clock_gettime(CLOCK_MONOTONIC, &dc_period);
+        latency_ns = DIFF_NS(next_period, dc_period);
+        if (latency_ns > latency_max_ns)
+            latency_max_ns = latency_ns;
+        if (latency_ns < latency_min_ns)
+            latency_min_ns = latency_ns;
+        latency_sum_ns += latency_ns;
+
+        if ((cycle_counter%CYCLE_COUNTER_PERSEC)==0) {
+            sem_update = 1;
+        }
+        clock_gettime(CLOCK_MONOTONIC, &exec_start);
+        ecrt_master_receive(master);
+        ecrt_domain_process(domain);
+        if (cycle_counter > 60000)
+            dc_diff = ecrt_master_sync_monitor_process(master);
+        else
+            dc_diff = 0;
+        if (dc_diff == 0xffffffff)
+            dc_diff = 0;
+        if (!(cycle_counter % CYCLE_COUNTER_PERSEC)) {
+            rt_check_master_state();
+        }
+        ec_readmotordata(&ec_motor0,ec_slave0);
+
+        switch(ec_motor0.controlword)
+        {
+            case 0x1F:
+                if (operation_mode == MODE_CSP) {
+                    if(!init_pos_flag){
+                        init_pos_flag = 1;
+                        ec_motor0.targetpos = ec_motor0.actualpos;
+                    }else
+                        ec_motor0.targetpos = ec_motor0.targetpos + set_tar_vel* slave_decord_per_cycle/CYCLE_COUNTER_PERSEC;
+                } else if (operation_mode == MODE_CSV) {
+                    ec_motor0.targetvel = set_tar_vel * slave_decord_per_cycle;
+                }
+                ec_writemotordata(&ec_motor0,ec_slave0);
+                if(dc_diff > dc_diff_max) {
+                    dc_diff_max = dc_diff;
+                }
+                if(dc_diff < dc_diff_min) {
+                    dc_diff_min = dc_diff;
+                }
+                break;
+            case 0x06:
+            case 0x07:
+            case 0x0F:
+            case 0x80:
+                EC_WRITE_U16(domain_pd+ec_slave0.ctrl_word, ec_motor0.controlword );
+                break;
+        }
+
+        clock_gettime(CLOCK_MONOTONIC, &dc_period);
+        ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+        ecrt_master_sync_reference_clock(master);
+        ecrt_master_sync_slave_clocks(master);
+        ecrt_master_sync_monitor_queue(master);
+        ecrt_domain_queue(domain);
+        ecrt_master_send(master);
+        clock_gettime(CLOCK_MONOTONIC, &exec_end);
+        exec_ns = TIMESPEC2NS(exec_end) - TIMESPEC2NS(exec_start);
+        if (exec_ns > exec_max_ns)
+            exec_max_ns = exec_ns;
+        if (exec_ns < exec_min_ns)
+            exec_min_ns = exec_ns;
+        exec_sum_ns += exec_ns;
+    }
+    return NULL;
+}
+
+void signal_handler(int sig)
+{
+    run = 0;
+}
+
+static int get_slaveid(char* slave) {
+    int id = 0;
+    if ((!strcmp(slave, "is620n"))||(!strcmp(slave, "IS620N"))) {
+        id = 0;
+    } else if ((!strcmp(slave, "d2"))||(!strcmp(slave, "D2"))) {
+        id = 1;
+    }
+    return id;
+}
+
+static uint8_t get_operationmode(char* mode) {
+    if ((!strcmp(mode, "CSP"))||(!strcmp(mode, "csp"))) {
+        return MODE_CSP;
+    } else if ((!strcmp(mode, "CSV"))||(!strcmp(mode, "csv"))) {
+        return MODE_CSV;
+    }
+    return MODE_CSP; //DEFAULT
+}
+
+static void getOptions(int argc, char **argv)
+{
+    int index;
+    static struct option longOptions[] = {
+        //name		has_arg				flag	val
+        {"slave",required_argument,	NULL,	's'},
+        {"velocity",required_argument,	NULL,	'v'},
+        {"master",required_argument,	NULL,	'm'},
+	{"mode", required_argument, NULL, 'o'},
+        {"help",	no_argument,		NULL,	'h'},
+        {}
+    };
+    do{
+	index = getopt_long(argc, argv, "s:v:m:o:h", longOptions, NULL);
+	switch(index){
+        case 'v':
+            set_tar_vel = atof(optarg);
+            if(set_tar_vel > 50.0)
+                set_tar_vel = 50.0;
+            printf("velocity : %f circle per second \n",set_tar_vel);
+            break;
+        case 'h':
+            printf("Global options:\n");
+            printf("  --slave -s  Set target slave model/s). default: inovnace \n");
+            printf("  --velocity -v  Set target velocity(circle/s). Max:10.0 \n");
+            printf("  --master -m  Set master id. default is %d \n", master_id);
+            printf("  --mode -o  Set slave operation mode. default is CSP \n");
+            printf("  --help     -h  Show this help.\n");
+            printf("default  velocity:1.0 circle/second\n");
+            exit(0);
+            break;
+        case 'm':
+            master_id = atoi(optarg);
+            if (master_id > 1)
+                master_id = 0;
+            break;
+	case 'o':
+            operation_mode = get_operationmode(optarg);
+            break;
+        case 's':
+            slave_id = get_slaveid(optarg);
+            break;
+        default:
+            break;
+        }
+    }
+    while(index != -1);
+}
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+    struct timespec dc_period;
+    int ret;
+
+#if !EC_ENABLE_DAEMON
+    ec_slave_info_t slave_info;
+#endif
+    getOptions(argc,argv);
+    data_init();
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+
+    master = ecrt_request_master(master_id);
+    if (!master) {
+        return -1;
+    }
+#if !EC_ENABLE_DAEMON
+    printf("Getting master state...\n");
+    ecrt_master_state(master, &master_state);
+    while (1){
+        ecrt_master_state(master, &master_state);
+	if ((master_state.slaves_responding == 1)&&(master_state.al_states&0x0E))
+           break;
+        sleep(0.01);
+    };
+    printf("Getting slave info...\n");
+    while(1)
+    {
+	ret = ecrt_master_get_slave(master, 0, &slave_info);
+	if (ret != 0) {
+	    printf("Error in getting slave info\n");
+	} else if ((slave_info.al_state >= EC_AL_STATE_PREOP)) {
+	    printf("slave info state=%d\n",slave_info.al_state);
+	    break;
+	}
+        sleep(0.01);
+    };
+#endif
+    printf("Creating domain ...\n");
+    domain = ecrt_master_create_domain(master);
+    if (!domain){
+	return -1;
+    }
+
+    switch(slave_id) {
+        case 0:
+            sc = ecrt_master_slave_config(master, INOV_IS620N_SLAVE00_POS, INOV_IS620N_SLAVE00_ID);
+            servo_syncs = inov_is620n_syncs;
+            slave_decord_per_cycle = (1 << INOV_IS620N_DECODER_BITS);
+            domain_regs = inov_is620n_regs;
+            break;
+        case 1:
+            sc = ecrt_master_slave_config(master, HIWIN_D2_SLAVE00_POS, HIWIN_D2_SLAVE00_ID);
+            servo_syncs = hiwin_d2_syncs;
+            slave_decord_per_cycle = (1 << HIWIN_D2_DECODER_BITS);
+	    domain_regs = hiwin_d2_regs;
+            break;
+    }
+    if (!sc) {
+        printf("Slave sc is NULL \n");
+        return -1;
+    }
+
+    printf("Creating slave configurations...\n");
+    //ec_slave_config_init(sc);
+
+    if (ecrt_slave_config_pdos(sc, EC_END, servo_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  1 \n");
+        return -1;
+    }
+
+    ecrt_master_set_send_interval(master, CYCLE_US);
+
+    if (ecrt_domain_reg_pdo_entry_list(domain, domain_regs)) {
+        fprintf(stderr, "PDO entry registration failed!\n");
+        return -1;
+    }
+
+    if (slave_id == 1) {
+        ecrt_slave_config_sdo32(sc, 0x6081, 0x00, 0x6AAAA);  /* profile vel */
+        ecrt_slave_config_sdo32(sc, 0x6083, 0x00, 0x42AAAA); /* profile acc */
+        ecrt_slave_config_sdo32(sc, 0x6084, 0x00, 0x42AAAA); /* profile dcc */
+    }
+
+    ecrt_slave_config_sdo8(sc, 0x6060, 0x00, operation_mode);
+
+    /*Configuring DC signal*/
+    ecrt_slave_config_dc(sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+
+    /* Set the initial master time and select a slave to use as the DC
+     * reference clock, otherwise pass NULL to auto select the first capable
+     * slave. Note: This can be used whether the master or the ref slave will
+     * be used as the systems master DC clock
+    */
+    clock_gettime(CLOCK_MONOTONIC, &dc_period);
+
+    /* Attention: The initial application time is also used for phase
+     * calcuation for the SYNC0/1 interrupts. Please be sure to call it at
+     * the correct phase to the realtime cycle
+    */
+    ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+
+    ret = ecrt_master_select_reference_clock(master, sc);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to select reference clock: %s\n",strerror(-ret));
+        return ret;
+    }
+
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    if (!(domain_pd = ecrt_domain_data(domain))) {
+        fprintf(stderr, "Failed to get domain data pointer.\n");
+        return -1;
+    }
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t thattr;
+    pthread_attr_init(&thattr);
+    pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+
+    if (pthread_create(&cyclic_thread, &thattr, &my_thread, NULL)) {
+        fprintf(stderr, "pthread_create cyclic task failed\n");
+        return 1;
+    }
+
+    while (run) {
+        if (sem_update&&count) {
+            printf("latency(us):  %10.3f ... %10.3f ... %10.3f\n", (float)latency_min_ns/1000, (float)latency_sum_ns/count/1000, (float)latency_max_ns/1000);
+            printf("DCM(ns)    :  %10d ... %10d\n", dc_diff_min, dc_diff_max);
+            printf("exec(us)   :  %10.3f ... %10.3f ... %10.3f\n", (float)exec_min_ns/1000, (float)exec_sum_ns/count/1000, (float)exec_max_ns/1000);
+            sem_update = 0;
+        }
+    }
+    pthread_join(cyclic_thread, NULL);
+
+    ecrt_slave_config_sdo16(sc, 0x6040, 0x00, 0x100);
+    ecrt_release_master(master);
+
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/ecatmotor/main.h b/examples/ecatmotor/main.h
new file mode 100644
index 00000000..c095fac9
--- /dev/null
+++ b/examples/ecatmotor/main.h
@@ -0,0 +1,104 @@
+#ifndef __ETHERCAT_MOTOR_MAIN_H__
+#define __ETHERCAT_MOTOR_MAIN_H__
+
+#include <stdio.h>
+#include "ecrt.h"
+
+#define CYCLE_US    			1000
+#define PERIOD_NS   			(CYCLE_US*1000)
+#define NSEC_PER_SEC    		(1000000000L)
+#define TIMESPEC2NS(T)  		((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DIFF_NS(A,B)    		(((B).tv_sec - (A).tv_sec)*NSEC_PER_SEC + ((B).tv_nsec)-(A).tv_nsec)
+#define CYCLE_COUNTER_PERSEC            (NSEC_PER_SEC/PERIOD_NS)
+
+enum{
+	MODE_PP     = 1,
+	MODE_PV     = 3,
+	MODE_PT     = 4,
+	MODE_NULL   = 5,
+	MODE_HM     = 6,
+	MODE_IP     = 7,
+	MODE_CSP    = 8,
+	MODE_CSV    = 9,
+	MODE_CST    = 10
+};
+
+typedef struct{
+    ec_slave_config_t *sc;
+    unsigned int status_word;
+    unsigned int ctrl_word;
+    unsigned int tar_pos;
+    unsigned int act_pos;
+    unsigned int tar_vel;
+    unsigned int act_vel;
+    unsigned char mode_sel;
+}Slave_Data;
+
+typedef struct{
+    unsigned short statusword;
+    unsigned short controlword;
+    unsigned long prevpos;
+    unsigned long actualpos;
+    unsigned long targetpos;
+    int prevel;
+    int actualvel;
+    int targetvel;
+}Ctl_Data;
+
+/* Inovance IS620N CoE EtherCAT Servo*/
+#define INOV_IS620N_SLAVE00_POS  			0, 0
+#define INOV_IS620N_SLAVE00_ID   			0x00100000, 0x000c0108
+#define INOV_IS620N_DECODER_BITS                           23
+ec_pdo_entry_info_t inov_is620n_pdo_entries[] = {
+  {0x6040, 0x00, 16},
+  {0x6060, 0x00, 8},
+  {0x607A, 0x00, 32},
+  {0x60FF, 0x00, 32},
+  {0x6041, 0x00, 16},
+  {0x6061, 0x00, 8},
+  {0x6064, 0x00, 32},
+  {0x606C, 0x00, 32},
+  {0x60F4, 0x00, 32},
+};
+
+ec_pdo_info_t inov_is620n_pdos[] = {
+   {0x1600, 4, inov_is620n_pdo_entries + 0},
+   {0x1a00, 5, inov_is620n_pdo_entries + 4},
+};
+
+ec_sync_info_t inov_is620n_syncs[] = {
+   {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+   {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+   {2, EC_DIR_OUTPUT, 1, inov_is620n_pdos + 0, EC_WD_ENABLE},
+   {3, EC_DIR_INPUT, 1, inov_is620n_pdos + 1, EC_WD_DISABLE},
+   {0xff}
+};
+
+/* Hiwin D2 CoE EtherCAT Servo*/
+#define HIWIN_D2_SLAVE00_POS  			        0, 0
+#define HIWIN_D2_SLAVE00_ID   			        0x0000aaaa, 0x00000003
+#define HIWIN_D2_DECODER_BITS                           17
+ec_pdo_entry_info_t hiwin_d2_pdo_entries[] = {
+	{0x6040, 0x00, 16},
+	{0x607A, 0x00, 32},
+	{0x60FF, 0x00, 32},
+	{0x6041, 0x00, 16},
+	{0x6064, 0x00, 32},
+	{0x606C, 0x00, 32},
+};
+
+ec_pdo_info_t hiwin_d2_pdos[] = {
+   {0x1600, 3, hiwin_d2_pdo_entries + 0},
+   {0x1a00, 3, hiwin_d2_pdo_entries + 3},
+};
+
+ec_sync_info_t hiwin_d2_syncs[] = {
+   {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+   {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+   {2, EC_DIR_OUTPUT, 1, hiwin_d2_pdos + 0, EC_WD_DISABLE},
+   {3, EC_DIR_INPUT, 1, hiwin_d2_pdos + 1, EC_WD_DISABLE},
+   {0xff}
+};
+
+#endif
+
diff --git a/examples/fly_trigger_poc/Makefile.am b/examples/fly_trigger_poc/Makefile.am
index 8854ab38..5e73507a 100644
--- a/examples/fly_trigger_poc/Makefile.am
+++ b/examples/fly_trigger_poc/Makefile.am
@@ -31,12 +31,13 @@ noinst_PROGRAMS = fly_trigger_poc
 
 fly_trigger_poc_SOURCES = main.c
 
-if ENABLE_XENOMAI
+if ENABLE_XENOMAI_V3
 fly_trigger_poc_CFLAGS = \
 	-Wall \
 	-lm  \
 	-I$(top_srcdir)/include \
-	$(XENOMAI_POSIX_CFLAGS)
+	$(XENOMAI_POSIX_CFLAGS) \
+	-DXENOMAI_API_V3
 
 fly_trigger_poc_LDFLAGS = \
 	-L$(top_builddir)/lib/.libs -lethercat_rtdm \
diff --git a/examples/multi_axis/Makefile.am b/examples/multi_axis/Makefile.am
index ac82f85c..4eac77b6 100644
--- a/examples/multi_axis/Makefile.am
+++ b/examples/multi_axis/Makefile.am
@@ -31,12 +31,13 @@ noinst_PROGRAMS = ec_multi_axis_example
 
 ec_multi_axis_example_SOURCES = main.c circle.c modbus_server/modbus_server.c
 
-if ENABLE_XENOMAI
+if ENABLE_XENOMAI_V3
 ec_multi_axis_example_CFLAGS = \
 	-Wall \
 	-lm  \
 	-I$(top_srcdir)/include \
-	$(XENOMAI_POSIX_CFLAGS)
+	$(XENOMAI_POSIX_CFLAGS) \
+	-DXENOMAI_API_V3
 
 ec_multi_axis_example_LDFLAGS = \
 	-L$(top_builddir)/lib/.libs -lethercat_rtdm -lmodbus \
diff --git a/examples/soe_axis/Makefile.am b/examples/soe_axis/Makefile.am
index 1d3e0aa2..c82de58a 100644
--- a/examples/soe_axis/Makefile.am
+++ b/examples/soe_axis/Makefile.am
@@ -31,12 +31,13 @@ noinst_PROGRAMS = ec_soe_axis_example
 
 ec_soe_axis_example_SOURCES = soe-axis.c
 
-if ENABLE_XENOMAI
+if ENABLE_XENOMAI_V3
 ec_soe_axis_example_CFLAGS = \
 	-Wall \
 	-lm  \
 	-I$(top_srcdir)/include \
-	$(XENOMAI_POSIX_CFLAGS)
+	$(XENOMAI_POSIX_CFLAGS) \
+	-DXENOMAI_API_V3
 
 ec_soe_axis_example_LDFLAGS = \
 	-L$(top_builddir)/lib/.libs -lethercat_rtdm \
diff --git a/globals.h b/globals.h
index d2a470e9..e77ca444 100644
--- a/globals.h
+++ b/globals.h
@@ -29,6 +29,15 @@
 #define __EC_GLOBALS_H__
 
 #include "config.h"
+#ifdef EC_USERMODE
+#include <stdbool.h>
+
+#ifdef EC_BENCHMARK
+#define NUM_TX_LATENCY 3
+#define NUM_RX_LATENCY 2
+#define NUM_STATISTIC 3
+#endif
+#endif
 
 /******************************************************************************
  *  Overall macros
@@ -51,5 +60,137 @@
 #define EC_MASTER_VERSION VERSION " " EC_STR(REV)
 
 /*****************************************************************************/
+#ifdef EC_USERMODE
+#include <stdint.h>
+#ifndef u8
+typedef uint8_t u8;
+#endif
+#ifndef u16
+typedef uint16_t u16;
+#endif
+#ifndef u32
+typedef uint32_t u32;
+#endif
+#ifndef u64
+typedef uint64_t u64;
+#endif
+#ifndef s8
+typedef int8_t s8;
+#endif
+#ifndef s16
+typedef int16_t s16;
+#endif
+#ifndef s32
+typedef int32_t s32;
+#endif
+#ifndef s64
+typedef int64_t s64;
+#endif
+#ifndef cycles_t
+typedef unsigned int cycles_t;
+#endif
+
+#define time_after(a, b) \
+	((long)((b) - (a)) < 0 )
 
+#ifndef ETH_ALEN
+#define ETH_ALEN 6
+#endif
+
+#define MAX_ERRNO 4095
+#define IS_ERR_VALUE(x) ((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)
+static inline void * ERR_PTR(long error)
+{
+	return (void *) error;
+}
+
+static inline bool IS_ERR(const void *ptr)
+{
+	return IS_ERR_VALUE((unsigned long)ptr);
+}
+
+static inline long PTR_ERR(const void *ptr)
+{
+	return (long) ptr;
+}
+
+#include <sys/time.h>
+#include <time.h>
+#define NSEC_PER_SEC (1000000000L)
+#define DIFF_NS(A, B) (((B).tv_sec - (A).tv_sec) * NSEC_PER_SEC + \
+        (B).tv_nsec - (A).tv_nsec)
+#define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+static inline uint64_t get_jiffies(void)
+{
+    struct timespec now;
+    clock_gettime(CLOCK_MONOTONIC, &now);
+    return (TIMESPEC2NS(now));
+}
+
+static inline int ec_nanosleep(uint64_t ns)
+{
+    struct timespec ts;
+    ts.tv_sec = ns/NSEC_PER_SEC;
+    ts.tv_nsec = (ns % NSEC_PER_SEC);
+    return nanosleep(&ts, NULL);
+}
+
+#ifndef EPROTONOSUPPORT
+#define EPROTONOSUPPORT 43
+#endif
+
+#ifndef EIO
+#define EIO 5
+#endif
+
+#ifndef EOVERFLOW
+#define EOVERFLOW 112
+#endif
+
+#ifndef EPROTO
+#define EPROTO 85
+#endif
+
+#ifndef EINVAL
+#define EINVAL 22
+#endif
+
+#ifndef EINTR
+#define EINTR 4
+#endif
+
+#ifndef ENXIO
+#define ENXIO 6
+#endif
+
+#ifndef EAGAIN
+#define EAGAIN 11
+#endif
+
+#ifndef ENOMEM
+#define ENOMEM 12
+#endif
+
+#ifndef EEXIST
+#define EEXIST 17
+#endif
+
+#ifndef ENODEV
+#define ENODEV 19
+#endif
+
+#ifndef EFAULT
+#define EFAULT 14
+#endif
+
+#ifndef EBUSY
+#define EBUSY 16
+#endif
+
+#ifdef EC_USERMODE
+#define min(x,y) (x < y ? x : y)
+#define max(x,y) (x > y ? x : y)
+#endif
+
+#endif
 #endif
diff --git a/include/Makefile.am b/include/Makefile.am
index 3ae0eeff..49fb3faf 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -20,7 +20,11 @@
 #-----------------------------------------------------------------------------
 
 include_HEADERS = \
-	ecrt.h \
+	ecrt.h
+
+if !ENABLE_USERMODE
+include_HEADERS += \
 	ectty.h
+endif
 
 #-----------------------------------------------------------------------------
diff --git a/ipc/Makefile.am b/ipc/Makefile.am
new file mode 100644
index 00000000..5d33311f
--- /dev/null
+++ b/ipc/Makefile.am
@@ -0,0 +1,53 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT master userspace library.
+#
+#  The IgH EtherCAT master userspace library is free software; you can
+#  redistribute it and/or modify it under the terms of the GNU Lesser General
+#  Public License as published by the Free Software Foundation; version 2.1 of
+#  the License.
+#
+#  The IgH EtherCAT master userspace library is distributed in the hope that
+#  it will be useful, but WITHOUT ANY WARRANTY; without even the implied
+#  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with the IgH EtherCAT master userspace library. If not, see
+#  <http://www.gnu.org/licenses/>.
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_LTLIBRARIES = libecat_ipc.la
+
+#------------------------------------------------------------------------------
+
+libecat_ipc_la_SOURCES = \
+	ipc_iface.c \
+	ipc_ctrl.c
+
+noinst_HEADERS = \
+	ecat_ipc.h \
+	ipc_atomic.h \
+	ipc_shm.h \
+	ipc_ctrl.h \
+	ipc_iface.h
+
+libecat_ipc_la_AMFLAGS = -I m4
+
+libecat_ipc_la_CFLAGS = -fno-strict-aliasing -Wall
+if ENABLE_DAEMON
+libecat_ipc_la_CFLAGS += -DEC_ENABLE_DAEMON
+endif
+
+CLEANFILE = *~
diff --git a/ipc/ecat_ipc.h b/ipc/ecat_ipc.h
new file mode 100644
index 00000000..c190eef3
--- /dev/null
+++ b/ipc/ecat_ipc.h
@@ -0,0 +1,7 @@
+#ifndef __ECAT_IPC_H_DEF__
+#define __ECAT_IPC_H_DEF__
+
+#include "ipc_shm.h"
+#include "ipc_atomic.h"
+
+#endif
diff --git a/ipc/ipc_atomic.h b/ipc/ipc_atomic.h
new file mode 100644
index 00000000..1748789d
--- /dev/null
+++ b/ipc/ipc_atomic.h
@@ -0,0 +1,90 @@
+#ifndef __IPC_ATOMIC_H_DEF__
+#define __IPC_ATOMIC_H_DEF__
+
+#include <stdatomic.h>
+#include <time.h>
+#include <sys/time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#define IPC_ATOMIC_SERVER_FLAG       'S'
+#define IPC_ATOMIC_CLIENT_FLAG       'C'
+#define IPC_ATOMIC_TIMEOUT_FLAG      'E'
+#define IPC_ATOMIC_EXIT_FLAG         'X'
+#define ATOMIC_WAIT_USLEEP           10000 // 10ms
+static void ipc_timer_expired(union sigval timer_data) {
+    atomic_char *guard = timer_data.sival_ptr;
+    atomic_store(guard, IPC_ATOMIC_TIMEOUT_FLAG);
+}
+
+static inline int ipc_timer_start(atomic_char* guard, unsigned long ms) {
+    timer_t timerId = 0;
+    int res;
+    struct sigevent sev = {0};
+    struct itimerspec its;
+
+    its.it_value.tv_sec = ms/1000;
+    its.it_value.tv_nsec = (ms%1000)*1000000L;
+    its.it_interval.tv_sec = ms/1000;
+    its.it_interval.tv_nsec = (ms%1000)*1000000L;
+
+    sev.sigev_notify = SIGEV_THREAD;
+    sev.sigev_notify_function = &ipc_timer_expired;
+    sev.sigev_value.sival_ptr = guard;
+
+    res = timer_create(CLOCK_REALTIME, &sev, &timerId);
+    if (res != 0) {
+        fprintf(stderr, "Error to create timer: %s\n", strerror(errno));
+	exit(-1);
+    }
+
+    res = timer_settime(timerId, 0, &its, NULL);
+    if (res != 0) {
+        fprintf(stderr, "Error to set timer: %s\n", strerror(errno));
+	exit(-1);
+    }
+    return 0;
+}
+
+static inline atomic_char* ipc_atomic_create(char* p, char flag) {
+    atomic_char* guard = (atomic_char*)p;
+    if (flag == IPC_ATOMIC_SERVER_FLAG)
+        atomic_init(guard, flag);
+    return guard;
+}
+
+static inline int ipc_atomic_wait(atomic_char* guard, char flag) {
+    char ret;
+
+    while(1) {
+        ret = atomic_load(guard);
+	if (ret == flag)
+            return ret;
+	else if (ret == IPC_ATOMIC_EXIT_FLAG)
+            return ret;
+#ifndef EC_ENABLE_DAEMON
+        usleep(ATOMIC_WAIT_USLEEP);
+#endif
+    }
+}
+
+static inline int ipc_atomic_wait_timeout(atomic_char* guard, char flag, unsigned long timeout) {
+    char ret;
+    ipc_timer_start(guard, timeout);
+    do {
+        ret = atomic_load(guard);
+	if (ret == IPC_ATOMIC_TIMEOUT_FLAG)
+            return 1;
+    } while(ret != flag);
+    return 0;
+}
+
+
+static inline void ipc_atomic_notify(atomic_char* guard, char flag) {
+    atomic_store(guard, flag);
+}
+#endif
diff --git a/ipc/ipc_ctrl.c b/ipc/ipc_ctrl.c
new file mode 100644
index 00000000..7dc102c0
--- /dev/null
+++ b/ipc/ipc_ctrl.c
@@ -0,0 +1,878 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include "globals.h"
+#include "ecat_ipc.h"
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <stdarg.h>
+#include "../master/ioctl.h"
+
+static long ec_msg_payload_prepare(unsigned int cmd, void *dest, void *src)
+{
+    long size = 0;
+    switch (cmd) {
+        case EC_IOCTL_MODULE:
+            size = sizeof(ec_ioctl_module_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_MASTER:
+            size = sizeof(ec_ioctl_master_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE:
+            size = sizeof(ec_ioctl_slave_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC:
+            size = sizeof(ec_ioctl_slave_sync_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC_PDO:
+            size = sizeof(ec_ioctl_slave_sync_pdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC_PDO_ENTRY:
+            size = sizeof(ec_ioctl_slave_sync_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN:
+            size = sizeof(ec_ioctl_domain_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN_FMMU:
+            size = sizeof(ec_ioctl_domain_fmmu_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN_DATA:
+            {
+                ec_ioctl_domain_data_t *data;
+                size = sizeof(ec_ioctl_domain_data_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_domain_data_t*)src;
+                memcpy(dest+size, data->target, data->data_size);
+                size +=data->data_size;
+            }
+            break;
+        case EC_IOCTL_MASTER_DEBUG:
+            size = sizeof(unsigned long);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_MASTER_RESCAN:
+        case EC_IOCTL_REQUEST:
+        case EC_IOCTL_CREATE_DOMAIN:
+        case EC_IOCTL_DEACTIVATE:
+        case EC_IOCTL_SEND:
+        case EC_IOCTL_RECEIVE:
+        case EC_IOCTL_SYNC_REF:
+        case EC_IOCTL_SYNC_SLAVES:
+        case EC_IOCTL_SYNC_MON_QUEUE:
+        case EC_IOCTL_RESET:
+        case EC_IOCTL_DOMAIN_SIZE:
+        case EC_IOCTL_DOMAIN_OFFSET:
+        case EC_IOCTL_DOMAIN_PROCESS:
+        case EC_IOCTL_DOMAIN_QUEUE:
+            size = 0;
+            break;
+        case EC_IOCTL_SLAVE_STATE:
+            size = sizeof(ec_ioctl_slave_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO:
+            size = sizeof(ec_ioctl_slave_sdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO_ENTRY:
+            size = sizeof(ec_ioctl_slave_sdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO_UPLOAD:
+            {
+                ec_ioctl_slave_sdo_upload_t *data;
+                size = sizeof(ec_ioctl_slave_sdo_upload_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_sdo_upload_t*)src;
+                memcpy(dest+size, data->target, data->target_size);
+                size += data->target_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SDO_DOWNLOAD:
+            {
+                ec_ioctl_slave_sdo_download_t *data;
+                size = sizeof(ec_ioctl_slave_sdo_download_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_sdo_download_t*)src;
+                memcpy(dest+size, data->data, data->data_size);
+                size += data->data_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SII_READ:
+        case EC_IOCTL_SLAVE_SII_WRITE:
+            {
+                ec_ioctl_slave_sii_t *data;
+                size = sizeof(ec_ioctl_slave_sii_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_sii_t*)src;
+                memcpy(dest+size, data->words, data->nwords);
+                size += data->nwords;
+            }
+            break;
+        case EC_IOCTL_SLAVE_REG_READ:
+        case EC_IOCTL_SLAVE_REG_WRITE:
+            {
+                ec_ioctl_slave_reg_t *data;
+                size = sizeof(ec_ioctl_slave_reg_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_reg_t*)src;
+                memcpy(dest+size, data->data, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_FOE_READ:
+        case EC_IOCTL_SLAVE_FOE_WRITE:
+            {
+                ec_ioctl_slave_foe_t *data;
+                size = sizeof(ec_ioctl_slave_foe_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_foe_t*)src;
+                memcpy(dest+size, data->buffer, data->buffer_size);
+                size += data->buffer_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SOE_READ:
+            {
+                ec_ioctl_slave_soe_read_t *data;
+                size = sizeof(ec_ioctl_slave_soe_read_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_soe_read_t*)src;
+                memcpy(dest+size, data->data, data->mem_size);
+                size += data->mem_size;
+            }
+            break;
+#ifdef EC_EOE
+        case EC_IOCTL_SLAVE_EOE_IP_PARAM:
+            size = sizeof(ec_ioctl_slave_eoe_ip_t);
+            memcpy(dest, src, size);
+            break;
+#endif
+        case EC_IOCTL_SLAVE_SOE_WRITE:
+            {
+                ec_ioctl_slave_soe_write_t *data;
+                size = sizeof(ec_ioctl_slave_soe_write_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_slave_soe_write_t*)src;
+                memcpy(dest+size, data->data, data->data_size);
+                size += data->data_size;
+            }
+            break;
+        case EC_IOCTL_CONFIG:
+        case EC_IOCTL_CREATE_SLAVE_CONFIG:
+        case EC_IOCTL_SC_SYNC:
+        case EC_IOCTL_SC_WATCHDOG:
+        case EC_IOCTL_SC_DC:
+            size = sizeof(ec_ioctl_config_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_PDO:
+        case EC_IOCTL_SC_ADD_PDO:
+        case EC_IOCTL_SC_CLEAR_PDOS:
+        case EC_IOCTL_SC_CLEAR_ENTRIES:
+            size = sizeof(ec_ioctl_config_pdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_PDO_ENTRY:
+            size = sizeof(ec_ioctl_config_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_SDO:
+            size = sizeof(ec_ioctl_config_sdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_IDN:
+            size = sizeof(ec_ioctl_config_idn_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_FLAG:
+            size = sizeof(ec_ioctl_config_flag_t);
+            memcpy(dest, src, size);
+            break;
+#ifdef EC_EOE
+        case EC_IOCTL_EOE_HANDLER:
+            size = sizeof(ec_ioctl_eoe_handler_t);
+            memcpy(dest, src, size);
+            break;
+#endif
+        case EC_IOCTL_SELECT_REF_CLOCK:
+        case EC_IOCTL_REF_CLOCK_TIME:
+        case EC_IOCTL_SYNC_MON_PROCESS:
+            size = sizeof(uint32_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_ACTIVATE:
+            {
+                ec_ioctl_master_activate_t *data;
+                size = sizeof(ec_ioctl_master_activate_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_master_activate_t *)src;
+                if (data->process_data) {
+                    memcpy(dest+size, data->process_data, data->process_data_size);
+                    size += data->process_data_size;
+                }
+            }
+            break;
+        case EC_IOCTL_MASTER_STATE:
+            size = sizeof(ec_master_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_MASTER_LINK_STATE:
+            size = sizeof(ec_master_link_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_APP_TIME:
+        case EC_IOCTL_SYNC_REF_TO:
+            size = sizeof(uint64_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_ADD_ENTRY:
+        case EC_IOCTL_SC_REG_PDO_ENTRY:
+            size = sizeof(ec_ioctl_add_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_REG_PDO_POS:
+            size = sizeof(ec_ioctl_reg_pdo_pos_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_SDO:
+	    {
+                ec_ioctl_sc_sdo_t *data;
+                size = sizeof(ec_ioctl_sc_sdo_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sc_sdo_t *)src;
+                memcpy(dest+size, data->data, data->size);
+                size += data->size;
+	    }
+            break;
+        case EC_IOCTL_SC_EMERG_SIZE:
+        case EC_IOCTL_SC_EMERG_POP:
+        case EC_IOCTL_SC_EMERG_CLEAR:
+        case EC_IOCTL_SC_EMERG_OVERRUNS:
+            {
+                ec_ioctl_sc_emerg_t *data;
+                size = sizeof(ec_ioctl_sc_emerg_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sc_emerg_t *)src;
+                memcpy(dest+size, data->target, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_SDO_REQUEST:
+        case EC_IOCTL_SDO_REQUEST_INDEX:
+        case EC_IOCTL_SDO_REQUEST_TIMEOUT:
+        case EC_IOCTL_SDO_REQUEST_STATE:
+        case EC_IOCTL_SDO_REQUEST_READ:
+        case EC_IOCTL_SDO_REQUEST_WRITE:
+        case EC_IOCTL_SDO_REQUEST_DATA:
+            {
+                ec_ioctl_sdo_request_t* data;
+                size = sizeof(ec_ioctl_sdo_request_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sdo_request_t *)src;
+                memcpy(dest+size, data->data, data->size);
+                size += data->size;
+            }
+            break;
+	case EC_IOCTL_SC_SOE_REQUEST:
+	case EC_IOCTL_SOE_REQUEST_IDN:
+	case EC_IOCTL_SOE_REQUEST_TIMEOUT:
+	case EC_IOCTL_SOE_REQUEST_STATE:
+	case EC_IOCTL_SOE_REQUEST_READ:
+	case EC_IOCTL_SOE_REQUEST_WRITE:
+	case EC_IOCTL_SOE_REQUEST_DATA:
+	    {
+	        ec_ioctl_soe_request_t* data;
+		size = sizeof(ec_ioctl_soe_request_t);
+		memcpy(dest, src, size);
+		data = (ec_ioctl_soe_request_t *)src;
+		memcpy(dest+size, data->data, data->size);
+		size += data->size;
+	    }
+	    break;
+        case EC_IOCTL_SC_VOE:
+        case EC_IOCTL_VOE_SEND_HEADER:
+        case EC_IOCTL_VOE_REC_HEADER:
+        case EC_IOCTL_VOE_READ:
+        case EC_IOCTL_VOE_READ_NOSYNC:
+        case EC_IOCTL_VOE_WRITE:
+        case EC_IOCTL_VOE_EXEC:
+        case EC_IOCTL_VOE_DATA:
+            {
+                ec_ioctl_voe_t *data;
+                size = sizeof(ec_ioctl_voe_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_voe_t *)src;
+                memcpy(dest+size, data->vendor_id, sizeof(uint32_t));
+                size += sizeof(uint32_t);
+                memcpy(dest+size, data->vendor_type, sizeof(uint16_t));
+                size += sizeof(uint16_t);
+                memcpy(dest+size, data->data, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_STATE:
+            {
+                ec_ioctl_sc_state_t *data;
+                size = sizeof(ec_ioctl_sc_state_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sc_state_t *)src;
+                memcpy(dest+size, data->state, sizeof(ec_slave_config_state_t));
+                size += sizeof(ec_slave_config_state_t);
+            }
+            break;
+        case EC_IOCTL_SC_IDN:
+            {
+                ec_ioctl_sc_idn_t *data;
+                size = sizeof(ec_ioctl_sc_idn_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sc_idn_t *)src;
+                memcpy(dest+size, data->data, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_FLAG:
+            {
+                ec_ioctl_sc_flag_t *data;
+                size = sizeof(ec_ioctl_sc_flag_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_sc_flag_t *)src;
+                memcpy(dest+size, data->key, data->key_size);
+                size += data->key_size;
+            }
+            break;
+        case EC_IOCTL_DOMAIN_STATE:
+            {
+                ec_ioctl_domain_state_t *data;
+                size = sizeof(ec_ioctl_domain_state_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_domain_state_t *)src;
+                memcpy(dest+size, data->state, sizeof(ec_domain_state_t));
+                size += sizeof(ec_slave_config_state_t);
+            }
+            break;
+        case EC_IOCTL_SC_REG_REQUEST:
+        case EC_IOCTL_REG_REQUEST_DATA:
+        case EC_IOCTL_REG_REQUEST_STATE:
+        case EC_IOCTL_REG_REQUEST_WRITE:
+        case EC_IOCTL_REG_REQUEST_READ:
+            {
+                ec_ioctl_reg_request_t *data;
+                size = sizeof(ec_ioctl_reg_request_t);
+                memcpy(dest, src, size);
+                data = (ec_ioctl_reg_request_t *)src;
+                memcpy(dest+size, data->data, data->transfer_size);
+                size += data->transfer_size;
+            }
+            break;
+        case EC_IOCTL_SET_SEND_INTERVAL:
+            size = sizeof(size_t);
+            memcpy(dest, src, size);
+            break;
+        default:
+            size = 0;
+            break;
+    }
+    return size;
+}
+
+static long ec_msg_payload_process(unsigned int cmd, void *src, void *dest)
+{
+    long size = 0;
+    switch (cmd) {
+        case EC_IOCTL_MODULE:
+            size = sizeof(ec_ioctl_module_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_MASTER:
+            size = sizeof(ec_ioctl_master_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE:
+            size = sizeof(ec_ioctl_slave_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC:
+            size = sizeof(ec_ioctl_slave_sync_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC_PDO:
+            size = sizeof(ec_ioctl_slave_sync_pdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SYNC_PDO_ENTRY:
+            size = sizeof(ec_ioctl_slave_sync_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN:
+            size = sizeof(ec_ioctl_domain_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN_FMMU:
+            size = sizeof(ec_ioctl_domain_fmmu_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_DOMAIN_DATA:
+            {
+                ec_ioctl_domain_data_t *data;
+                uint8_t* target;
+                data = (ec_ioctl_domain_data_t*)dest;
+                target =  data->target;
+                size = sizeof(ec_ioctl_domain_data_t);
+                memcpy(dest, src, size);
+                data->target = target;
+                data = (ec_ioctl_domain_data_t*)src;
+                memcpy(target, src+size, data->data_size);
+                size += data->data_size;
+            }
+            break;
+        case EC_IOCTL_MASTER_DEBUG:
+            size = sizeof(unsigned long);
+            break;
+        case EC_IOCTL_SLAVE_STATE:
+            size = sizeof(ec_ioctl_slave_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO:
+            size = sizeof(ec_ioctl_slave_sdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO_ENTRY:
+            size = sizeof(ec_ioctl_slave_sdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SLAVE_SDO_UPLOAD:
+            {
+                ec_ioctl_slave_sdo_upload_t *data;
+                uint8_t* target;
+                data = (ec_ioctl_slave_sdo_upload_t*)dest;
+                target = data->target;
+                size = sizeof(ec_ioctl_slave_sdo_upload_t);
+                memcpy(dest, src, size);
+                data->target = target;
+                data = (ec_ioctl_slave_sdo_upload_t*)src;
+                memcpy(target, src+size, data->target_size);
+                size += data->target_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SDO_DOWNLOAD:
+            {
+                ec_ioctl_slave_sdo_download_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_slave_sdo_download_t*)dest;
+                size = sizeof(ec_ioctl_slave_sdo_download_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_slave_sdo_download_t*)src;
+                memcpy(backup, src+size, data->data_size);
+                size += data->data_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SII_READ:
+        case EC_IOCTL_SLAVE_SII_WRITE:
+            {
+                ec_ioctl_slave_sii_t *data;
+                uint16_t* words;
+                data = (ec_ioctl_slave_sii_t*)dest;
+                size = sizeof(ec_ioctl_slave_sii_t);
+                words = data->words;
+                memcpy(dest, src, size);
+                data->words = words;
+                data = (ec_ioctl_slave_sii_t*)src;
+                memcpy(words, src+size, data->nwords);
+                size += data->nwords;
+            }
+            break;
+        case EC_IOCTL_SLAVE_REG_READ:
+        case EC_IOCTL_SLAVE_REG_WRITE:
+            {
+                ec_ioctl_slave_reg_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_slave_reg_t*)dest;
+                size = sizeof(ec_ioctl_slave_reg_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_slave_reg_t*)src;
+                memcpy(backup, src+size, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_FOE_READ:
+        case EC_IOCTL_SLAVE_FOE_WRITE:
+            {
+                ec_ioctl_slave_foe_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_slave_foe_t*)dest;
+                size = sizeof(ec_ioctl_slave_foe_t);
+                backup = data->buffer;
+                memcpy(dest, src, size);
+                data->buffer = backup;
+                data = (ec_ioctl_slave_foe_t*)src;
+                memcpy(backup, src+size, data->buffer_size);
+                size += data->buffer_size;
+            }
+            break;
+        case EC_IOCTL_SLAVE_SOE_READ:
+            {
+                ec_ioctl_slave_soe_read_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_slave_soe_read_t*)dest;
+                size = sizeof(ec_ioctl_slave_soe_read_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_slave_soe_read_t*)src;
+                memcpy(backup, src+size, data->mem_size);
+                size += data->mem_size;
+            }
+            break;
+#ifdef EC_EOE
+        case EC_IOCTL_SLAVE_EOE_IP_PARAM:
+            size = sizeof(ec_ioctl_slave_eoe_ip_t);
+            memcpy(dest, src, size);
+            break;
+#endif
+        case EC_IOCTL_SLAVE_SOE_WRITE:
+            {
+                ec_ioctl_slave_soe_write_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_slave_soe_write_t*)dest;
+                size = sizeof(ec_ioctl_slave_soe_write_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_slave_soe_write_t*)src;
+                memcpy(backup, src+size, data->data_size);
+                size += data->data_size;
+            }
+            break;
+        case EC_IOCTL_CONFIG:
+        case EC_IOCTL_CREATE_SLAVE_CONFIG:
+        case EC_IOCTL_SC_SYNC:
+        case EC_IOCTL_SC_WATCHDOG:
+        case EC_IOCTL_SC_DC:
+            size = sizeof(ec_ioctl_config_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_PDO:
+        case EC_IOCTL_SC_ADD_PDO:
+        case EC_IOCTL_SC_CLEAR_PDOS:
+        case EC_IOCTL_SC_CLEAR_ENTRIES:
+            size = sizeof(ec_ioctl_config_pdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_PDO_ENTRY:
+            size = sizeof(ec_ioctl_config_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_SDO:
+            size = sizeof(ec_ioctl_config_sdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_IDN:
+            size = sizeof(ec_ioctl_config_idn_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_CONFIG_FLAG:
+            size = sizeof(ec_ioctl_config_flag_t);
+            memcpy(dest, src, size);
+            break;
+#ifdef EC_EOE
+        case EC_IOCTL_EOE_HANDLER:
+            size = sizeof(ec_ioctl_eoe_handler_t);
+            memcpy(dest, src, size);
+            break;
+#endif
+        case EC_IOCTL_MASTER_RESCAN:
+        case EC_IOCTL_REQUEST:
+        case EC_IOCTL_CREATE_DOMAIN:
+        case EC_IOCTL_DEACTIVATE:
+        case EC_IOCTL_SEND:
+        case EC_IOCTL_RECEIVE:
+        case EC_IOCTL_SYNC_REF:
+        case EC_IOCTL_SYNC_SLAVES:
+        case EC_IOCTL_SYNC_MON_QUEUE:
+        case EC_IOCTL_RESET:
+        case EC_IOCTL_DOMAIN_SIZE:
+        case EC_IOCTL_DOMAIN_OFFSET:
+        case EC_IOCTL_DOMAIN_PROCESS:
+        case EC_IOCTL_DOMAIN_QUEUE:
+            size = 0;
+            break;
+        case EC_IOCTL_SELECT_REF_CLOCK:
+        case EC_IOCTL_REF_CLOCK_TIME:
+        case EC_IOCTL_SYNC_MON_PROCESS:
+            size = sizeof(uint32_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_ACTIVATE:
+            {
+                ec_ioctl_master_activate_t *data;
+                void *backup;
+                size = sizeof(ec_ioctl_master_activate_t);
+                data = (ec_ioctl_master_activate_t *)dest;
+                backup = data->process_data;
+                memcpy(dest, src, size);
+                data->process_data = backup;
+                data = (ec_ioctl_master_activate_t *)src;
+                if (data->process_data) {
+                    memcpy(backup, src+size, data->process_data_size);
+                    size += data->process_data_size;
+                }
+            }
+            break;
+        case EC_IOCTL_MASTER_STATE:
+            size = sizeof(ec_master_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_MASTER_LINK_STATE:
+            size = sizeof(ec_master_link_state_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_APP_TIME:
+        case EC_IOCTL_SYNC_REF_TO:
+            size = sizeof(uint64_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_ADD_ENTRY:
+        case EC_IOCTL_SC_REG_PDO_ENTRY:
+            size = sizeof(ec_ioctl_add_pdo_entry_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_REG_PDO_POS:
+            size = sizeof(ec_ioctl_reg_pdo_pos_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_SDO:
+	    {
+                ec_ioctl_sc_sdo_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_sc_sdo_t *)dest;
+                size = sizeof(ec_ioctl_sc_sdo_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_sc_sdo_t *)src;
+                memcpy(backup, src+size, data->size);
+                size += data->size;
+	    }
+            size = sizeof(ec_ioctl_sc_sdo_t);
+            memcpy(dest, src, size);
+            break;
+        case EC_IOCTL_SC_EMERG_SIZE:
+        case EC_IOCTL_SC_EMERG_POP:
+        case EC_IOCTL_SC_EMERG_CLEAR:
+        case EC_IOCTL_SC_EMERG_OVERRUNS:
+            {
+                ec_ioctl_sc_emerg_t *data;
+                uint8_t* target;
+                data = (ec_ioctl_sc_emerg_t *)dest;
+                size = sizeof(ec_ioctl_sc_emerg_t);
+                target = data->target;
+                memcpy(dest, src, size);
+                data->target = target;
+                data = (ec_ioctl_sc_emerg_t *)src;
+                memcpy(target, src+size, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_SDO_REQUEST:
+        case EC_IOCTL_SDO_REQUEST_INDEX:
+        case EC_IOCTL_SDO_REQUEST_TIMEOUT:
+        case EC_IOCTL_SDO_REQUEST_STATE:
+        case EC_IOCTL_SDO_REQUEST_READ:
+        case EC_IOCTL_SDO_REQUEST_WRITE:
+        case EC_IOCTL_SDO_REQUEST_DATA:
+            {
+                ec_ioctl_sdo_request_t* data;
+                uint8_t* backup;
+                data = (ec_ioctl_sdo_request_t *)dest;
+                size = sizeof(ec_ioctl_sdo_request_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_sdo_request_t *)src;
+                memcpy(backup, src+size, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_VOE:
+        case EC_IOCTL_VOE_SEND_HEADER:
+        case EC_IOCTL_VOE_REC_HEADER:
+        case EC_IOCTL_VOE_READ:
+        case EC_IOCTL_VOE_READ_NOSYNC:
+        case EC_IOCTL_VOE_WRITE:
+        case EC_IOCTL_VOE_EXEC:
+        case EC_IOCTL_VOE_DATA:
+            {
+                ec_ioctl_voe_t *data;
+                uint32_t* vendor_id;
+                uint16_t* vendor_type;
+                uint8_t* backup;
+                data = (ec_ioctl_voe_t *)dest;
+                size = sizeof(ec_ioctl_voe_t);
+                vendor_id = data->vendor_id;
+                vendor_type = data->vendor_type;
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->vendor_id = vendor_id;
+                data->vendor_type = vendor_type;
+                data->data = backup;
+                data = (ec_ioctl_voe_t *)src;
+                memcpy(vendor_id, src+size, sizeof(uint32_t));
+                size += sizeof(uint32_t);
+                memcpy(vendor_type, src+size, sizeof(uint16_t));
+                size += sizeof(uint16_t);
+                memcpy(backup, src+size, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_STATE:
+            {
+                ec_ioctl_sc_state_t *data;
+                ec_slave_config_state_t* state;
+                data = (ec_ioctl_sc_state_t *)dest;
+                size = sizeof(ec_ioctl_sc_state_t);
+                state = data->state;
+                memcpy(dest, src, size);
+                data->state = state;
+                data = (ec_ioctl_sc_state_t *)src;
+                memcpy((uint8_t*)state, src+size, sizeof(ec_slave_config_state_t));
+                size += sizeof(ec_slave_config_state_t);
+            }
+            break;
+        case EC_IOCTL_SC_IDN:
+            {
+                ec_ioctl_sc_idn_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_sc_idn_t *)dest;
+                size = sizeof(ec_ioctl_sc_idn_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_sc_idn_t *)src;
+                memcpy(backup, src+size, data->size);
+                size += data->size;
+            }
+            break;
+        case EC_IOCTL_SC_FLAG:
+            {
+                ec_ioctl_sc_flag_t *data;
+                uint8_t* key;
+                data = (ec_ioctl_sc_flag_t *)dest;
+                size = sizeof(ec_ioctl_sc_flag_t);
+                key = data->key;
+                memcpy(dest, src, size);
+                data->key = key;
+                data = (ec_ioctl_sc_flag_t *)src;
+                memcpy(key, src+size, data->key_size);
+                size += data->key_size;
+            }
+            break;
+        case EC_IOCTL_DOMAIN_STATE:
+            {
+                ec_ioctl_domain_state_t *data;
+                ec_domain_state_t* state;
+                data = (ec_ioctl_domain_state_t *)dest;
+                size = sizeof(ec_ioctl_domain_state_t);
+                state = data->state;
+                memcpy(dest, src, size);
+                data->state = state;
+                data = (ec_ioctl_domain_state_t *)src;
+                memcpy((uint8_t*)state, src+size, sizeof(ec_domain_state_t));
+                size += sizeof(ec_slave_config_state_t);
+            }
+            break;
+        case EC_IOCTL_SC_REG_REQUEST:
+        case EC_IOCTL_REG_REQUEST_DATA:
+        case EC_IOCTL_REG_REQUEST_STATE:
+        case EC_IOCTL_REG_REQUEST_WRITE:
+        case EC_IOCTL_REG_REQUEST_READ:
+            {
+                ec_ioctl_reg_request_t *data;
+                uint8_t* backup;
+                data = (ec_ioctl_reg_request_t *)dest;
+                size = sizeof(ec_ioctl_reg_request_t);
+                backup = data->data;
+                memcpy(dest, src, size);
+                data->data = backup;
+                data = (ec_ioctl_reg_request_t *)src;
+                memcpy(backup, src+size, data->transfer_size);
+                size += data->transfer_size;
+            }
+            break;
+        case EC_IOCTL_SET_SEND_INTERVAL:
+            size = sizeof(size_t);
+            break;
+        default:
+            size = 0;
+            break;
+    }
+    return size;
+}
+
+#define IPC_MESSAGE_TIMEOUT     2000
+
+int ipc_ctrl_ioctl(char* p, unsigned int cmd, ...) {
+    char* new = p+1;
+    size_t size;
+    int dir;
+    int *ret;
+
+    va_list ap;
+    void* data;
+    atomic_char* guard = ipc_atomic_create(p, IPC_ATOMIC_CLIENT_FLAG);
+    va_start(ap, cmd);
+    ret = (int*)new;
+    new += sizeof(int);
+    *(unsigned int*)new = cmd;
+    new += sizeof(unsigned int);
+    data = va_arg(ap, void*);
+    size = ec_msg_payload_prepare(cmd, new, data);
+    va_end(ap);
+
+    ipc_atomic_notify(guard, IPC_ATOMIC_CLIENT_FLAG);
+    ipc_atomic_wait(guard, IPC_ATOMIC_SERVER_FLAG);
+    //if (ipc_atomic_wait_timeout(guard, IPC_ATOMIC_SERVER_FLAG, IPC_MESSAGE_TIMEOUT) == -1)
+    //    return -1;
+    ec_msg_payload_process(cmd, new, data);
+    return (*ret);
+}
+
+
+void ipc_ctrl_atomic_exit(char* p) {
+    atomic_char* guard = ipc_atomic_create(p, IPC_ATOMIC_EXIT_FLAG);
+    ipc_atomic_notify(guard, IPC_ATOMIC_EXIT_FLAG);
+}
+
+static unsigned char ipc_ctrl_get_clientid(char* p)
+{
+    return 0;
+}
+
+void ipc_ctrl_init(char** p) {
+    ipc_shm_generate(ECAT_IPC_SHM_NAME, ECAT_IPC_DEFAULT_SHM_SIZE, p);
+    return 0;
+}
+
+void ipc_ctrl_mmap(char** p, size_t size) {
+    ipc_shm_generate(ECAT_IPC_MMAP_SHM_NAME, size, p);
+}
+
+void ipc_ctrl_unmap(char* p) {
+    ipc_shm_release(p);
+}
+
+void ipc_ctrl_release(char* p ) {
+    ipc_shm_release(p);
+}
diff --git a/ipc/ipc_ctrl.h b/ipc/ipc_ctrl.h
new file mode 100644
index 00000000..5f686e46
--- /dev/null
+++ b/ipc/ipc_ctrl.h
@@ -0,0 +1,13 @@
+#ifndef __IPC_CTRL_H_DEF__
+#define __IPC_CTRL_H_DEF__
+
+#ifdef __cplusplus
+extern "C" {
+#include "../master/ioctl.h"
+int ipc_ctrl_ioctl(char*, unsigned int, ...);
+void ipc_ctrl_init(char**);
+void ipc_ctrl_mmap(char**, size_t);
+void ipc_ctrl_release(char*);
+}
+#endif
+#endif
diff --git a/ipc/ipc_iface.c b/ipc/ipc_iface.c
new file mode 100644
index 00000000..f58b4aaf
--- /dev/null
+++ b/ipc/ipc_iface.c
@@ -0,0 +1,37 @@
+#include <stdio.h>
+#include <unistd.h>
+#include "ecat_ipc.h"
+#include "ipc_iface.h"
+
+void ipc_iface_atomic_notify(char* p) {
+    ipc_atomic_notify((atomic_char*)p, IPC_ATOMIC_SERVER_FLAG);
+}
+
+int ipc_iface_atomic_wait(char* p) {
+    char flag = ipc_atomic_wait((atomic_char*)p, IPC_ATOMIC_CLIENT_FLAG);
+    if (flag != IPC_ATOMIC_CLIENT_FLAG)
+        return -1;
+    return 0;
+}
+
+char* ipc_iface_atomic_create(char* p) {
+    return (char*)ipc_atomic_create(p, IPC_ATOMIC_SERVER_FLAG);
+}
+
+int ipc_iface_init(char **p) {
+    int id = ipc_shm_generate(ECAT_IPC_SHM_NAME, ECAT_IPC_DEFAULT_SHM_SIZE, p);
+
+    return id;
+}
+
+void ipc_iface_mmap(char **p, size_t size) {
+    ipc_shm_generate(ECAT_IPC_MMAP_SHM_NAME, size, p);
+}
+
+void ipc_iface_unmap(char * p) {
+    ipc_shm_release(p);
+}
+
+void ipc_iface_release(int id, char* p ) {
+    ipc_shm_cleanall(id, p);
+}
diff --git a/ipc/ipc_iface.h b/ipc/ipc_iface.h
new file mode 100644
index 00000000..68e76b97
--- /dev/null
+++ b/ipc/ipc_iface.h
@@ -0,0 +1,11 @@
+#ifndef __IPC_IFACE_H_DEF__
+#define __IPC_IFACE_H_DEF__
+
+void ipc_iface_atomic_notify(char*);
+int ipc_iface_atomic_wait(char*);
+char* ipc_iface_atomic_create(char*);
+int ipc_iface_init(char **);
+void ipc_iface_mmap(char **, size_t);
+void ipc_iface_release(int, char *);
+
+#endif
diff --git a/ipc/ipc_shm.h b/ipc/ipc_shm.h
new file mode 100644
index 00000000..84b7135d
--- /dev/null
+++ b/ipc/ipc_shm.h
@@ -0,0 +1,47 @@
+#ifndef __IPC_SHM_H_DEF__
+#define __IPC_SHM_H_DEF__
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/shm.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+#define ECAT_IPC_DEFAULT_PROJ_ID            'E'
+#define ECAT_IPC_DEFAULT_SHM_SIZE           512
+
+#define ECAT_IPC_SHM_NAME                "ecat"
+#define ECAT_IPC_MMAP_SHM_NAME           "ecatmmap"
+static inline void ipc_shm_release(char* p) {
+    shmdt(p);
+}
+
+static inline void ipc_shm_cleanall(int id, char* p)
+{
+    shmdt(p);
+    shm_unlink(p);
+}
+
+static inline int ipc_shm_generate(char* name, size_t size, void** p) {
+    int fd;
+
+    fd = shm_open(name, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+    if (fd == -1) {
+        perror("shm_open error!");
+	exit(-1);
+    }
+
+    if (ftruncate(fd, size+1) == -1) {
+        perror("Failed to truncate share memory!");
+	exit(-1);
+    }
+
+    *p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (*p == MAP_FAILED) {
+        perror("mmap error!");
+	exit(-1);
+    }
+    return fd;
+}
+#endif
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 644d4ea8..7e6d3180 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -52,6 +52,13 @@ libethercat_la_CFLAGS = \
 	-Dethercat_EXPORTS \
 	-fvisibility=hidden
 
+if ENABLE_USERMODE
+libethercat_la_CFLAGS += -lrt -DEC_USERMODE
+
+libethercat_la_CFLAGS += -L$(top_builddir)/ipc
+libethercat_la_LIBADD = \
+	$(top_builddir)/ipc/libecat_ipc.la
+endif
 #
 # http://www.gnu.org/software/libtool/manual/html_node/ ...
 # Updating-version-info.html
@@ -79,6 +86,7 @@ libethercat_la_LDFLAGS = -version-info 3:0:2 \
 
 libethercat_la_DEPENDENCIES = libethercat.map
 
+pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libethercat.pc
 
 cmakedir = $(libdir)/cmake/ethercat
diff --git a/lib/common.c b/lib/common.c
index 4dbdee72..75ad919a 100644
--- a/lib/common.c
+++ b/lib/common.c
@@ -30,6 +30,9 @@
 #include <unistd.h>
 #include <sys/socket.h>
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
 #include "ioctl.h"
 #include "master.h"
 
@@ -78,6 +81,9 @@ ec_master_t *ecrt_open_master(unsigned int master_index)
     master->first_domain = NULL;
     master->first_config = NULL;
 
+#ifdef EC_USERMODE
+    ipc_ctrl_init(&master->ipcs);
+#else
     snprintf(path, MAX_PATH_LEN - 1,
 #if defined(USE_RTDM)
             "EtherCAT%u",
@@ -93,13 +99,20 @@ ec_master_t *ecrt_open_master(unsigned int master_index)
 #else
     master->fd = open(path, O_RDWR);
 #endif
+#endif
+#ifndef EC_USERMODE
     if (EC_IOCTL_IS_ERROR(master->fd)) {
         fprintf(stderr, "Failed to open %s: %s\n", path,
                 strerror(EC_IOCTL_ERRNO(master->fd)));
         goto out_clear;
     }
+#endif
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_MODULE, &module_data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_MODULE, &module_data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get module information from %s: %s\n",
                 path, strerror(EC_IOCTL_ERRNO(ret)));
diff --git a/lib/domain.c b/lib/domain.c
index 7382a24b..2fc99df0 100644
--- a/lib/domain.c
+++ b/lib/domain.c
@@ -31,6 +31,9 @@
 #include <string.h>
 #include <errno.h> /* ENOENT */
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
 #include "ioctl.h"
 #include "domain.h"
 #include "master.h"
@@ -72,7 +75,11 @@ size_t ecrt_domain_size(const ec_domain_t *domain)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(domain->master->ipcs, EC_IOCTL_DOMAIN_SIZE, &domain->index);
+#else
     ret = ioctl(domain->master->fd, EC_IOCTL_DOMAIN_SIZE, domain->index);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get domain size: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -93,8 +100,11 @@ uint8_t *ecrt_domain_data(const ec_domain_t *domain)
 int ecrt_domain_process(ec_domain_t *domain)
 {
     int ret;
-
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(domain->master->ipcs, EC_IOCTL_DOMAIN_PROCESS, &domain->index);
+#else
     ret = ioctl(domain->master->fd, EC_IOCTL_DOMAIN_PROCESS, domain->index);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -107,7 +117,11 @@ int ecrt_domain_queue(ec_domain_t *domain)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(domain->master->ipcs, EC_IOCTL_DOMAIN_QUEUE, &domain->index);
+#else
     ret = ioctl(domain->master->fd, EC_IOCTL_DOMAIN_QUEUE, domain->index);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -124,7 +138,11 @@ int ecrt_domain_state(const ec_domain_t *domain, ec_domain_state_t *state)
     data.domain_index = domain->index;
     data.state = state;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(domain->master->ipcs, EC_IOCTL_DOMAIN_STATE, &data);
+#else
     ret = ioctl(domain->master->fd, EC_IOCTL_DOMAIN_STATE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
diff --git a/lib/master.c b/lib/master.c
index 2a9018e5..774de8de 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -27,6 +27,10 @@
 #include <string.h>
 #include <sys/mman.h>
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
+
 #include "ioctl.h"
 #include "master.h"
 #include "domain.h"
@@ -43,7 +47,11 @@ void ec_master_add_slave_config(ec_master_t *, ec_slave_config_t *);
 
 int ecrt_master_reserve(ec_master_t *master)
 {
+#ifdef EC_USERMODE
+    int ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_REQUEST, NULL);
+#else
     int ret = ioctl(master->fd, EC_IOCTL_REQUEST, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to reserve master: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -59,6 +67,15 @@ void ec_master_clear_config(ec_master_t *master)
     ec_domain_t *d, *next_d;
     ec_slave_config_t *c, *next_c;
 
+    if (master->process_data)  {
+#ifdef EC_USERMODE
+        ipc_ctrl_unmap(master->process_data);
+#else
+        munmap(master->process_data, master->process_data_size);
+#endif
+        master->process_data = NULL;
+    }
+
     d = master->first_domain;
     while (d) {
         next_d = d->next;
@@ -78,7 +95,11 @@ void ec_master_clear_config(ec_master_t *master)
     master->first_config = NULL;
 
     if (master->process_data)  {
+#ifdef EC_USERMODE
+        ipc_ctrl_unmap(master->process_data);
+#else
         munmap(master->process_data, master->process_data_size);
+#endif
         master->process_data = NULL;
         master->process_data_size = 0;
     }
@@ -90,6 +111,13 @@ void ec_master_clear(ec_master_t *master)
 {
     ec_master_clear_config(master);
 
+#ifdef EC_USERMODE
+    ecrt_master_deactivate(master);
+    if (master->ipcs != NULL) {
+        ipc_ctrl_release(master->ipcs);
+        master->ipcs = NULL;	
+    }
+#else
     if (master->fd != -1) {
 #if USE_RTDM
         rt_dev_close(master->fd);
@@ -98,6 +126,7 @@ void ec_master_clear(ec_master_t *master)
 #endif
         master->fd = -1;
     }
+#endif
 }
 
 /****************************************************************************/
@@ -128,7 +157,11 @@ ec_domain_t *ecrt_master_create_domain(ec_master_t *master)
         return 0;
     }
 
+#ifdef EC_USERMODE
+    index = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_CREATE_DOMAIN, NULL);
+#else
     index = ioctl(master->fd, EC_IOCTL_CREATE_DOMAIN, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(index)) {
         fprintf(stderr, "Failed to create domain: %s\n",
                 strerror(EC_IOCTL_ERRNO(index)));
@@ -182,7 +215,11 @@ ec_slave_config_t *ecrt_master_slave_config(ec_master_t *master,
     data.vendor_id = vendor_id;
     data.product_code = product_code;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_CREATE_SLAVE_CONFIG, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_CREATE_SLAVE_CONFIG, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to create slave config: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -219,7 +256,11 @@ int ecrt_master_select_reference_clock(ec_master_t *master,
         config_index = 0xFFFFFFFF;
     }
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SELECT_REF_CLOCK, &config_index);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SELECT_REF_CLOCK, config_index);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to select reference clock: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -236,7 +277,11 @@ int ecrt_master(ec_master_t *master, ec_master_info_t *master_info)
     ec_ioctl_master_t data;
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_MASTER, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_MASTER, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get master info: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -258,7 +303,11 @@ int ecrt_master_scan_progress(ec_master_t *master,
     ec_ioctl_master_t data;
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_MASTER, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_MASTER, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get master info: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -280,7 +329,11 @@ int ecrt_master_get_slave(ec_master_t *master, uint16_t slave_position,
 
     data.position = slave_position;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get slave info: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -330,7 +383,11 @@ int ecrt_master_get_sync_manager(ec_master_t *master, uint16_t slave_position,
     data.slave_position = slave_position;
     data.sync_index = sync_index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SYNC, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SYNC, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get sync manager information: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -364,7 +421,11 @@ int ecrt_master_get_pdo(ec_master_t *master, uint16_t slave_position,
     data.sync_index = sync_index;
     data.pdo_pos = pos;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SYNC_PDO, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SYNC_PDO, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get pdo information: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -396,7 +457,11 @@ int ecrt_master_get_pdo_entry(ec_master_t *master, uint16_t slave_position,
     data.pdo_pos = pdo_pos;
     data.entry_pos = entry_pos;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SYNC_PDO_ENTRY, &data);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SYNC_PDO_ENTRY, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get pdo entry information: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -426,7 +491,11 @@ int ecrt_master_sdo_download(ec_master_t *master,
     download.data_size = data_size;
     download.data = (uint8_t *) data; // will only be read in ioctl()
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SDO_DOWNLOAD, &download);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SDO_DOWNLOAD, &download);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) == EIO && abort_code) {
             *abort_code = download.abort_code;
@@ -455,7 +524,11 @@ int ecrt_master_sdo_download_complete(ec_master_t *master,
     download.data_size = data_size;
     download.data = (uint8_t *) data; // will only be read in ioctl()
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SDO_DOWNLOAD, &download);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SDO_DOWNLOAD, &download);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) == EIO && abort_code) {
             *abort_code = download.abort_code;
@@ -483,7 +556,11 @@ int ecrt_master_sdo_upload(ec_master_t *master, uint16_t slave_position,
     upload.target_size = target_size;
     upload.target = target;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SDO_UPLOAD, &upload);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SDO_UPLOAD, &upload);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) == EIO && abort_code) {
             *abort_code = upload.abort_code;
@@ -512,7 +589,11 @@ int ecrt_master_write_idn(ec_master_t *master, uint16_t slave_position,
     io.data_size = data_size;
     io.data = (uint8_t *) data; // will only be read in ioctl()
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SOE_WRITE, &io);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SOE_WRITE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) == EIO && error_code) {
             *error_code = io.error_code;
@@ -540,7 +621,11 @@ int ecrt_master_read_idn(ec_master_t *master, uint16_t slave_position,
     io.mem_size = target_size;
     io.data = target;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SLAVE_SOE_READ, &io);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SLAVE_SOE_READ, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) == EIO && error_code) {
             *error_code = io.error_code;
@@ -561,7 +646,12 @@ int ecrt_master_activate(ec_master_t *master)
     ec_ioctl_master_activate_t io;
     int ret;
 
+#ifdef EC_USERMODE
+    memset(&io, 0x00, sizeof(ec_ioctl_master_activate_t));
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_ACTIVATE, &io);
+#else
     ret = ioctl(master->fd, EC_IOCTL_ACTIVATE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to activate master: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -571,6 +661,9 @@ int ecrt_master_activate(ec_master_t *master)
     master->process_data_size = io.process_data_size;
 
     if (master->process_data_size) {
+#ifdef EC_USERMODE
+	ipc_ctrl_mmap(&master->process_data, master->process_data_size);
+#else
 #ifdef USE_RTDM
         /* memory-mapping was already done in kernel. The user-space addess is
          * provided in the ioctl data.
@@ -586,6 +679,7 @@ int ecrt_master_activate(ec_master_t *master)
             master->process_data_size = 0;
             return -errno;
         }
+#endif
 #endif
 
         // Access the mapped region to cause the initial page fault
@@ -595,8 +689,13 @@ int ecrt_master_activate(ec_master_t *master)
     // pick up process data pointers for all created domains
     ec_domain_t *domain = master->first_domain;
     while (domain) {
+#ifdef EC_USERMODE
+	int offset = ipc_ctrl_ioctl(&master->ipcs, EC_IOCTL_DOMAIN_OFFSET,
+                domain->index);
+#else
         int offset = ioctl(domain->master->fd, EC_IOCTL_DOMAIN_OFFSET,
                 domain->index);
+#endif
         if (EC_IOCTL_IS_ERROR(offset)) {
             fprintf(stderr, "Failed to get domain offset: %s\n",
                     strerror(EC_IOCTL_ERRNO(offset)));
@@ -616,7 +715,11 @@ int ecrt_master_deactivate(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_DEACTIVATE, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_DEACTIVATE, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -632,7 +735,11 @@ int ecrt_master_set_send_interval(ec_master_t *master,
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SET_SEND_INTERVAL, &send_interval_us);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SET_SEND_INTERVAL, &send_interval_us);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -646,7 +753,11 @@ int ecrt_master_send(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SEND, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SEND, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -659,7 +770,11 @@ int ecrt_master_receive(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_RECEIVE, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_RECEIVE, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -672,7 +787,11 @@ int ecrt_master_state(const ec_master_t *master, ec_master_state_t *state)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_MASTER_STATE, state);
+#else
     ret = ioctl(master->fd, EC_IOCTL_MASTER_STATE, state);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -690,7 +809,11 @@ int ecrt_master_link_state(const ec_master_t *master, unsigned int dev_idx,
     io.dev_idx = dev_idx;
     io.state = state;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_MASTER_LINK_STATE, &io);
+#else
     ret = ioctl(master->fd, EC_IOCTL_MASTER_LINK_STATE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get link state: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -709,7 +832,11 @@ int ecrt_master_application_time(ec_master_t *master, uint64_t app_time)
 
     time = app_time;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_APP_TIME, &time);
+#else
     ret = ioctl(master->fd, EC_IOCTL_APP_TIME, &time);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -722,7 +849,11 @@ int ecrt_master_sync_reference_clock(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SYNC_REF, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SYNC_REF, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -739,7 +870,11 @@ int ecrt_master_sync_reference_clock_to(ec_master_t *master,
 
     time = sync_time;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SYNC_REF_TO, &time);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SYNC_REF_TO, &time);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -752,7 +887,12 @@ int ecrt_master_sync_slave_clocks(ec_master_t *master)
 {
     int ret;
 
+
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SYNC_SLAVES, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SYNC_SLAVES, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -766,7 +906,11 @@ int ecrt_master_reference_clock_time(const ec_master_t *master,
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_REF_CLOCK_TIME, time);
+#else
     ret = ioctl(master->fd, EC_IOCTL_REF_CLOCK_TIME, time);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get reference clock time: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -782,7 +926,11 @@ int ecrt_master_sync_monitor_queue(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SYNC_MON_QUEUE, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SYNC_MON_QUEUE, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -796,7 +944,11 @@ uint32_t ecrt_master_sync_monitor_process(const ec_master_t *master)
     uint32_t time_diff;
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_SYNC_MON_PROCESS, &time_diff);
+#else
     ret = ioctl(master->fd, EC_IOCTL_SYNC_MON_PROCESS, &time_diff);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         time_diff = 0xffffffff;
         fprintf(stderr, "Failed to process sync monitor datagram: %s\n",
@@ -812,7 +964,11 @@ int ecrt_master_reset(ec_master_t *master)
 {
     int ret;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(master->ipcs, EC_IOCTL_RESET, NULL);
+#else
     ret = ioctl(master->fd, EC_IOCTL_RESET, NULL);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
diff --git a/lib/master.h b/lib/master.h
index fdcc13c0..c2dcfd33 100644
--- a/lib/master.h
+++ b/lib/master.h
@@ -25,7 +25,11 @@
 /****************************************************************************/
 
 struct ec_master {
+#ifdef EC_USERMODE
+    char* ipcs;
+#else
     int fd;
+#endif
     uint8_t *process_data;
     size_t process_data_size;
 
diff --git a/lib/reg_request.c b/lib/reg_request.c
index f52afd15..316ffc18 100644
--- a/lib/reg_request.c
+++ b/lib/reg_request.c
@@ -29,6 +29,9 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
 #include "ioctl.h"
 #include "reg_request.h"
 #include "slave_config.h"
@@ -60,10 +63,15 @@ ec_request_state_t ecrt_reg_request_state(const ec_reg_request_t *reg)
     ec_ioctl_reg_request_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_reg_request_t));
     io.config_index = reg->config->index;
     io.request_index = reg->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(reg->config->master->ipcs, EC_IOCTL_REG_REQUEST_STATE, &io);
+#else
     ret = ioctl(reg->config->master->fd, EC_IOCTL_REG_REQUEST_STATE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get register request state: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -75,8 +83,13 @@ ec_request_state_t ecrt_reg_request_state(const ec_reg_request_t *reg)
         io.data = reg->data;
         io.mem_size = reg->mem_size;
 
+#ifdef EC_USERMODE
+        ret = ipc_ctrl_ioctl(reg->config->master->ipcs,
+                EC_IOCTL_REG_REQUEST_DATA, &io);
+#else
         ret = ioctl(reg->config->master->fd,
                 EC_IOCTL_REG_REQUEST_DATA, &io);
+#endif
         if (EC_IOCTL_IS_ERROR(ret)) {
             fprintf(stderr, "Failed to get register data: %s\n",
                     strerror(EC_IOCTL_ERRNO(ret)));
@@ -95,13 +108,18 @@ int ecrt_reg_request_write(ec_reg_request_t *reg, uint16_t address,
     ec_ioctl_reg_request_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_reg_request_t));
     io.config_index = reg->config->index;
     io.request_index = reg->index;
     io.data = reg->data;
     io.address = address;
     io.transfer_size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(reg->config->master->ipcs, EC_IOCTL_REG_REQUEST_WRITE, &io);
+#else
     ret = ioctl(reg->config->master->fd, EC_IOCTL_REG_REQUEST_WRITE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -116,12 +134,17 @@ int ecrt_reg_request_read(ec_reg_request_t *reg, uint16_t address,
     ec_ioctl_reg_request_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_reg_request_t));
     io.config_index = reg->config->index;
     io.request_index = reg->index;
     io.address = address;
     io.transfer_size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(reg->config->master->ipcs, EC_IOCTL_REG_REQUEST_READ, &io);
+#else
     ret = ioctl(reg->config->master->fd, EC_IOCTL_REG_REQUEST_READ, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
diff --git a/lib/sdo_request.c b/lib/sdo_request.c
index 509a349c..d89eab23 100644
--- a/lib/sdo_request.c
+++ b/lib/sdo_request.c
@@ -29,6 +29,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
+
 #include "ioctl.h"
 #include "sdo_request.h"
 #include "slave_config.h"
@@ -54,12 +58,17 @@ int ecrt_sdo_request_index(ec_sdo_request_t *req, uint16_t index,
     ec_ioctl_sdo_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sdo_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
     data.sdo_index = index;
     data.sdo_subindex = subindex;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SDO_REQUEST_INDEX, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SDO_REQUEST_INDEX, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -73,11 +82,16 @@ int ecrt_sdo_request_timeout(ec_sdo_request_t *req, uint32_t timeout)
     ec_ioctl_sdo_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sdo_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
     data.timeout = timeout;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SDO_REQUEST_TIMEOUT, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SDO_REQUEST_TIMEOUT, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -105,10 +119,15 @@ ec_request_state_t ecrt_sdo_request_state(ec_sdo_request_t *req)
     ec_ioctl_sdo_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sdo_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SDO_REQUEST_STATE, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SDO_REQUEST_STATE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get SDO request state: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -124,8 +143,13 @@ ec_request_state_t ecrt_sdo_request_state(ec_sdo_request_t *req)
 
         data.data = req->data;
 
+#ifdef EC_USERMODE
+        ret = ipc_ctrl_ioctl(req->config->master->ipcs,
+                EC_IOCTL_SDO_REQUEST_DATA, &data);
+#else
         ret = ioctl(req->config->master->fd,
                 EC_IOCTL_SDO_REQUEST_DATA, &data);
+#endif
         if (EC_IOCTL_IS_ERROR(ret)) {
             fprintf(stderr, "Failed to get SDO data: %s\n",
                     strerror(EC_IOCTL_ERRNO(ret)));
@@ -144,10 +168,15 @@ int ecrt_sdo_request_read(ec_sdo_request_t *req)
     ec_ioctl_sdo_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sdo_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SDO_REQUEST_READ, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SDO_REQUEST_READ, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -166,7 +195,11 @@ int ecrt_sdo_request_write(ec_sdo_request_t *req)
     data.data = req->data;
     data.size = req->data_size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SDO_REQUEST_WRITE, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SDO_REQUEST_WRITE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
diff --git a/lib/slave_config.c b/lib/slave_config.c
index 7bef3a99..e293c47e 100644
--- a/lib/slave_config.c
+++ b/lib/slave_config.c
@@ -25,6 +25,10 @@
 #include <string.h>
 #include <errno.h> /* ENOENT */
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
+
 #include "ioctl.h"
 #include "slave_config.h"
 #include "domain.h"
@@ -104,7 +108,11 @@ int ecrt_slave_config_sync_manager(ec_slave_config_t *sc, uint8_t sync_index,
     data.syncs[sync_index].watchdog_mode = watchdog_mode;
     data.syncs[sync_index].config_this = 1;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_SYNC, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_SYNC, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to config sync manager: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -127,7 +135,11 @@ int ecrt_slave_config_watchdog(ec_slave_config_t *sc,
     data.watchdog_divider = divider;
     data.watchdog_intervals = intervals;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_WATCHDOG, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_WATCHDOG, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to config watchdog: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -144,11 +156,16 @@ int ecrt_slave_config_pdo_assign_add(ec_slave_config_t *sc,
     ec_ioctl_config_pdo_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_config_pdo_t));
     data.config_index = sc->index;
     data.sync_index = sync_index;
     data.index = pdo_index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_ADD_PDO, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_ADD_PDO, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to add PDO: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -166,10 +183,15 @@ int ecrt_slave_config_pdo_assign_clear(ec_slave_config_t *sc,
     ec_ioctl_config_pdo_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_config_pdo_t));
     data.config_index = sc->index;
     data.sync_index = sync_index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_CLEAR_PDOS, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_CLEAR_PDOS, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to clear PDOs: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -187,13 +209,18 @@ int ecrt_slave_config_pdo_mapping_add(ec_slave_config_t *sc,
     ec_ioctl_add_pdo_entry_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_add_pdo_entry_t));
     data.config_index = sc->index;
     data.pdo_index = pdo_index;
     data.entry_index = entry_index;
     data.entry_subindex = entry_subindex;
     data.entry_bit_length = entry_bit_length;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_ADD_ENTRY, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_ADD_ENTRY, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to add PDO entry: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -211,10 +238,15 @@ int ecrt_slave_config_pdo_mapping_clear(ec_slave_config_t *sc,
     ec_ioctl_config_pdo_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_config_pdo_t));
     data.config_index = sc->index;
     data.index = pdo_index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_CLEAR_ENTRIES, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_CLEAR_ENTRIES, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to clear PDO entries: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -300,12 +332,17 @@ int ecrt_slave_config_reg_pdo_entry(
     ec_ioctl_reg_pdo_entry_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_reg_pdo_entry_t));
     data.config_index = sc->index;
     data.entry_index = index;
     data.entry_subindex = subindex;
     data.domain_index = domain->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_REG_PDO_ENTRY, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_REG_PDO_ENTRY, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to register PDO entry: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -340,13 +377,18 @@ int ecrt_slave_config_reg_pdo_entry_pos(
     ec_ioctl_reg_pdo_pos_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_reg_pdo_pos_t));
     io.config_index = sc->index;
     io.sync_index = sync_index;
     io.pdo_pos = pdo_pos;
     io.entry_pos = entry_pos;
     io.domain_index = domain->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_REG_PDO_POS, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_REG_PDO_POS, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to register PDO entry: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -376,6 +418,7 @@ int ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate,
     ec_ioctl_config_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_config_t));
     data.config_index = sc->index;
     data.dc_assign_activate = assign_activate;
     data.dc_sync[0].cycle_time = sync0_cycle_time;
@@ -383,7 +426,11 @@ int ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate,
     data.dc_sync[1].cycle_time = sync1_cycle_time;
     data.dc_sync[1].shift_time = sync1_shift_time;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_DC, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_DC, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -398,6 +445,7 @@ int ecrt_slave_config_sdo(ec_slave_config_t *sc, uint16_t index,
     ec_ioctl_sc_sdo_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sc_sdo_t));
     data.config_index = sc->index;
     data.index = index;
     data.subindex = subindex;
@@ -405,7 +453,11 @@ int ecrt_slave_config_sdo(ec_slave_config_t *sc, uint16_t index,
     data.size = size;
     data.complete_access = 0;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_SDO, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_SDO, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to configure SDO: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -423,6 +475,7 @@ int ecrt_slave_config_complete_sdo(ec_slave_config_t *sc, uint16_t index,
     ec_ioctl_sc_sdo_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sc_sdo_t));
     data.config_index = sc->index;
     data.index = index;
     data.subindex = 0;
@@ -430,7 +483,11 @@ int ecrt_slave_config_complete_sdo(ec_slave_config_t *sc, uint16_t index,
     data.size = size;
     data.complete_access = 1;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_SDO, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_SDO, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to configure SDO: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -480,10 +537,15 @@ int ecrt_slave_config_emerg_size(ec_slave_config_t *sc, size_t elements)
     ec_ioctl_sc_emerg_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_emerg_t));
     io.config_index = sc->index;
     io.size = elements;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_EMERG_SIZE, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_EMERG_SIZE, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to set emergency ring size: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -500,10 +562,15 @@ int ecrt_slave_config_emerg_pop(ec_slave_config_t *sc, uint8_t *target)
     ec_ioctl_sc_emerg_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_emerg_t));
     io.config_index = sc->index;
     io.target = target;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_EMERG_POP, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_EMERG_POP, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         if (EC_IOCTL_ERRNO(ret) != ENOENT) {
             fprintf(stderr, "Failed to get emergency message: %s\n",
@@ -522,9 +589,14 @@ int ecrt_slave_config_emerg_clear(ec_slave_config_t *sc)
     ec_ioctl_sc_emerg_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_emerg_t));
     io.config_index = sc->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_EMERG_CLEAR, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_EMERG_CLEAR, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to clear emergency ring: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -541,9 +613,14 @@ int ecrt_slave_config_emerg_overruns(const ec_slave_config_t *sc)
     ec_ioctl_sc_emerg_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_emerg_t));
     io.config_index = sc->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_EMERG_OVERRUNS, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_EMERG_OVERRUNS, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get emergency overruns: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -596,12 +673,17 @@ ec_sdo_request_t *ecrt_slave_config_create_sdo_request(ec_slave_config_t *sc,
         req->data = NULL;
     }
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sdo_request_t));
     data.config_index = sc->index;
     data.sdo_index = index;
     data.sdo_subindex = subindex;
     data.size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_SDO_REQUEST, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_SDO_REQUEST, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to create SDO request: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -666,12 +748,17 @@ ec_soe_request_t *ecrt_slave_config_create_soe_request(ec_slave_config_t *sc,
         req->data = NULL;
     }
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = sc->index;
     data.drive_no = drive_no;
     data.idn = idn;
     data.size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_SOE_REQUEST, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_SOE_REQUEST, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to create SoE request: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -736,10 +823,15 @@ ec_reg_request_t *ecrt_slave_config_create_reg_request(ec_slave_config_t *sc,
         reg->data = NULL;
     }
 
+    memset(&io, 0x00, sizeof(ec_ioctl_reg_request_t));
     io.config_index = sc->index;
     io.mem_size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_REG_REQUEST, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_REG_REQUEST, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to create register request: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -801,10 +893,15 @@ ec_voe_handler_t *ecrt_slave_config_create_voe_handler(ec_slave_config_t *sc,
         voe->data = NULL;
     }
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = sc->index;
     data.size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_VOE, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_VOE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to create VoE handler: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -832,10 +929,15 @@ int ecrt_slave_config_state(const ec_slave_config_t *sc,
     ec_ioctl_sc_state_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_sc_state_t));
     data.config_index = sc->index;
     data.state = state;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_STATE, &data);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_STATE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -850,6 +952,7 @@ int ecrt_slave_config_idn(ec_slave_config_t *sc, uint8_t drive_no,
     ec_ioctl_sc_idn_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_idn_t));
     io.config_index = sc->index;
     io.drive_no = drive_no;
     io.idn = idn;
@@ -857,7 +960,11 @@ int ecrt_slave_config_idn(ec_slave_config_t *sc, uint8_t drive_no,
     io.data = data;
     io.size = size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_IDN, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_IDN, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to configure IDN: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -875,6 +982,7 @@ int ecrt_slave_config_flag(ec_slave_config_t *sc, const char *key,
     ec_ioctl_sc_flag_t io;
     int ret;
 
+    memset(&io, 0x00, sizeof(ec_ioctl_sc_flag_t));
     io.config_index = sc->index;
     io.key_size = strlen(key);
     if (io.key_size <= 0) {
@@ -891,7 +999,11 @@ int ecrt_slave_config_flag(ec_slave_config_t *sc, const char *key,
     strcpy(io.key, key); // no strncpy, buffer is alloc'ed with strlen
     io.value = value;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(sc->master->ipcs, EC_IOCTL_SC_FLAG, &io);
+#else
     ret = ioctl(sc->master->fd, EC_IOCTL_SC_FLAG, &io);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to configure feature flag: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
diff --git a/lib/soe_request.c b/lib/soe_request.c
index 822e3c1e..28cd00ab 100644
--- a/lib/soe_request.c
+++ b/lib/soe_request.c
@@ -54,12 +54,17 @@ int ecrt_soe_request_idn(ec_soe_request_t *req, uint8_t drive_no,
     ec_ioctl_soe_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
     data.drive_no = drive_no;
     data.idn = idn;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_IDN, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SOE_REQUEST_IDN, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -73,11 +78,16 @@ int ecrt_soe_request_timeout(ec_soe_request_t *req, uint32_t timeout)
     ec_ioctl_soe_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
     data.timeout = timeout;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_TIMEOUT, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SOE_REQUEST_TIMEOUT, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -105,10 +115,15 @@ ec_request_state_t ecrt_soe_request_state(ec_soe_request_t *req)
     ec_ioctl_soe_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_STATE, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SOE_REQUEST_STATE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to get SoE request state: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -123,9 +138,12 @@ ec_request_state_t ecrt_soe_request_state(ec_soe_request_t *req)
         }
 
         data.data = req->data;
-
+#ifdef EC_USERMODE
+        ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_DATA, &data);
+#else
         ret = ioctl(req->config->master->fd,
                 EC_IOCTL_SOE_REQUEST_DATA, &data);
+#endif
         if (EC_IOCTL_IS_ERROR(ret)) {
             fprintf(stderr, "Failed to get SoE data: %s\n",
                     strerror(EC_IOCTL_ERRNO(ret)));
@@ -144,10 +162,15 @@ int ecrt_soe_request_read(ec_soe_request_t *req)
     ec_ioctl_soe_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_READ, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SOE_REQUEST_READ, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -161,12 +184,17 @@ int ecrt_soe_request_write(ec_soe_request_t *req)
     ec_ioctl_soe_request_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_soe_request_t));
     data.config_index = req->config->index;
     data.request_index = req->index;
     data.data = req->data;
     data.size = req->data_size;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(req->config->master->ipcs, EC_IOCTL_SOE_REQUEST_WRITE, &data);
+#else
     ret = ioctl(req->config->master->fd, EC_IOCTL_SOE_REQUEST_WRITE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
diff --git a/lib/voe_handler.c b/lib/voe_handler.c
index bc17c370..247cdeaa 100644
--- a/lib/voe_handler.c
+++ b/lib/voe_handler.c
@@ -29,6 +29,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
+
 #include "ioctl.h"
 #include "voe_handler.h"
 #include "slave_config.h"
@@ -52,12 +56,17 @@ int ecrt_voe_handler_send_header(ec_voe_handler_t *voe, uint32_t vendor_id,
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
     data.vendor_id = &vendor_id;
     data.vendor_type = &vendor_type;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_SEND_HEADER, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_SEND_HEADER, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -72,12 +81,17 @@ int ecrt_voe_handler_received_header(const ec_voe_handler_t *voe,
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
     data.vendor_id = vendor_id;
     data.vendor_type = vendor_type;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_REC_HEADER, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_REC_HEADER, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -105,10 +119,15 @@ int ecrt_voe_handler_read(ec_voe_handler_t *voe)
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_READ, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_READ, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -122,10 +141,15 @@ int ecrt_voe_handler_read_nosync(ec_voe_handler_t *voe)
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_READ_NOSYNC, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_READ_NOSYNC, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -139,12 +163,17 @@ int ecrt_voe_handler_write(ec_voe_handler_t *voe, size_t size)
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
     data.size = size;
     data.data = voe->data;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_WRITE, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_WRITE, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         return -EC_IOCTL_ERRNO(ret);
     }
@@ -158,10 +187,15 @@ ec_request_state_t ecrt_voe_handler_execute(ec_voe_handler_t *voe)
     ec_ioctl_voe_t data;
     int ret;
 
+    memset(&data, 0x00, sizeof(ec_ioctl_voe_t));
     data.config_index = voe->config->index;
     data.voe_index = voe->index;
 
+#ifdef EC_USERMODE
+    ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_EXEC, &data);
+#else
     ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_EXEC, &data);
+#endif
     if (EC_IOCTL_IS_ERROR(ret)) {
         fprintf(stderr, "Failed to execute VoE handler: %s\n",
                 strerror(EC_IOCTL_ERRNO(ret)));
@@ -177,7 +211,11 @@ ec_request_state_t ecrt_voe_handler_execute(ec_voe_handler_t *voe)
 
         data.data = voe->data;
 
+#ifdef EC_USERMODE
+        ret = ipc_ctrl_ioctl(voe->config->master->ipcs, EC_IOCTL_VOE_DATA, &data);
+#else
         ret = ioctl(voe->config->master->fd, EC_IOCTL_VOE_DATA, &data);
+#endif
         if (EC_IOCTL_IS_ERROR(ret)) {
             fprintf(stderr, "Failed to get VoE data: %s\n",
                     strerror(EC_IOCTL_ERRNO(ret)));
diff --git a/master/Makefile.am b/master/Makefile.am
index 1a0ef30a..09f08dcf 100644
--- a/master/Makefile.am
+++ b/master/Makefile.am
@@ -18,59 +18,163 @@
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 #-----------------------------------------------------------------------------
-
+if ENABLE_USERMODE
+if ENABLE_DAEMON
+bin_PROGRAMS = ethercatd
+else
+lib_LTLIBRARIES = libethercatd.la
+endif
+else
 include $(top_srcdir)/Makefile.kbuild
+endif
 
-# using HEADERS to enable tags target
-noinst_HEADERS = \
-	cdev.c cdev.h \
-	coe_emerg_ring.c coe_emerg_ring.h \
-	datagram.c datagram.h \
-	datagram_pair.c datagram_pair.h \
-	debug.c debug.h \
-	device.c device.h \
-	domain.c domain.h \
+ethercat_SOURCES = \
+	coe_emerg_ring.c \
+	datagram.c \
+	datagram_pair.c \
+	debug.c \
+	device.c \
+	domain.c \
 	doxygen.c \
-	eoe_request.c eoe_request.h \
-	ethernet.c ethernet.h \
-	flag.c flag.h \
-	fmmu_config.c fmmu_config.h \
+	flag.c \
+	fmmu_config.c \
+	foe_request.c \
+	fsm_change.c \
+	fsm_coe.c \
+	fsm_foe.c \
+	fsm_master.c \
+	fsm_pdo.c \
+	fsm_pdo_entry.c \
+	fsm_sii.c \
+	fsm_slave.c \
+	fsm_slave_config.c \
+	fsm_slave_scan.c \
+	fsm_soe.c \
+	ioctl.c \
+	mailbox.c \
+	master.c \
+	pdo.c \
+	pdo_entry.c \
+	pdo_list.c \
+	reg_request.c \
+	sdo.c \
+	sdo_entry.c \
+	sdo_request.c \
+	slave.c \
+	slave_config.c \
+	soe_errors.c \
+	soe_request.c \
+	sync.c \
+	sync_config.c \
+	voe_handler.c
+
+if ENABLE_EOE
+ethercat_SOURCES += \
+	eoe_request.c \
+	ethernet.c \
+	fsm_eoe.c
+endif
+
+if ENABLE_USERMODE
+ethercat_SOURCES += \
+	ethercatd.c \
+	ecrt_config.c
+noinst_HEADERS = \
+	ecrt_config.h \
+	mm.h
+else
+noinst_HEADERS = $(ethercat_SOURCES)
+noinst_HEADERS += \
+	module.c \
+	rtdm-ioctl.c \
+	cdev.c
+endif
+
+# using HEADERS to enable tags target
+noinst_HEADERS += \
+	coe_emerg_ring.h \
+	datagram.h \
+	datagram_pair.h \
+	debug.h \
+	device.h \
+	domain.h \
+	flag.h \
+	fmmu_config.h \
 	foe.h \
-	foe_request.c foe_request.h \
-	fsm_change.c fsm_change.h \
-	fsm_coe.c fsm_coe.h \
-	fsm_eoe.c fsm_eoe.h \
-	fsm_foe.c fsm_foe.h \
-	fsm_master.c fsm_master.h \
-	fsm_pdo.c fsm_pdo.h \
-	fsm_pdo_entry.c fsm_pdo_entry.h \
-	fsm_sii.c fsm_sii.h \
-	fsm_slave.c fsm_slave.h \
-	fsm_slave_config.c fsm_slave_config.h \
-	fsm_slave_scan.c fsm_slave_scan.h \
-	fsm_soe.c fsm_soe.h \
+	foe_request.h \
+	fsm_change.h \
+	fsm_coe.h \
+	fsm_foe.h \
+	fsm_master.h \
+	fsm_pdo.h \
+	fsm_pdo_entry.h \
+	fsm_sii.h \
+	fsm_slave.h \
+	fsm_slave_config.h \
+	fsm_slave_scan.h \
+	fsm_soe.h \
 	globals.h \
-	ioctl.c ioctl.h \
-	mailbox.c mailbox.h \
-	master.c master.h \
+	ioctl.h \
+	mailbox.h \
+	master.h \
+	pdo.h \
+	pdo_entry.h \
+	pdo_list.h \
+	rt_locks.h \
+	reg_request.h \
+	rtdm.h \
+	rtdm_details.h \
+	sdo.h \
+	sdo_entry.h \
+	sdo_request.h \
+	slave.h \
+	slave_config.h \
+	soe_request.h \
+	sync.h \
+	sync_config.h \
+	voe_handler.h
+
+if ENABLE_EOE
+noinst_HEADERS += \
+	eoe_request.h \
+	ethernet.h \
+	fsm_eoe.h
+endif
+if !ENABLE_USERMODE
+noinst_HEADERS += \
+	cdev.h \
 	module.c \
-	pdo.c pdo.h \
-	pdo_entry.c pdo_entry.h \
-	pdo_list.c pdo_list.h \
-	reg_request.c reg_request.h \
 	rtdm-ioctl.c \
-	rtdm.c rtdm.h \
-	rtdm_details.h \
-	rtdm_xenomai_v3.c \
-	sdo.c sdo.h \
-	sdo_entry.c sdo_entry.h \
-	sdo_request.c sdo_request.h \
-	slave.c slave.h \
-	slave_config.c slave_config.h \
-	soe_errors.c \
-	soe_request.c soe_request.h \
-	sync.c sync.h \
-	sync_config.c sync_config.h \
-	voe_handler.c voe_handler.h
+	rtdm.c \
+	rtdm_xenomai_v3.c
+endif
+
+
+if ENABLE_USERMODE
+#-----------------------------------------------------------------------------
+REV = `if test -s $(top_srcdir)/revision; then \
+		cat $(top_srcdir)/revision; \
+	else \
+		git -C $(top_srcdir) describe 2>/dev/null || echo "unknown"; \
+	fi`
+
+ethercatd_SOURCES = $(ethercat_SOURCES)
+ethercatd_CXXFLAGS = \
+	-I$(top_srcdir)/master \
+	-lpthread -lrt -L$(top_builddir)/dpdk \
+	-Wall -DREV=$(REV) \
+	-fno-strict-aliasing
+
+ethercatd_LDADD = \
+	$(top_builddir)/ipc/libecat_ipc.la
 
+ethercatd_CFLAGS = $(ethercatd_CXXFLAGS)
+if !ENABLE_DAEMON
+libethercatd_la_SOURCES = $(ethercatd_SOURCES)
+libethercatd_la_CFLAGS = $(ethercatd_CFLAGS) -I$(top_srcdir)/include
+libethercatd_la_LIBADD = $(ethercatd_LDADD) -lecat_dpdk
+libethercatd_la_LDFLAGS = -version-info 2:0:1
+endif
+CLEANFILE = *~
+endif
 #-----------------------------------------------------------------------------
diff --git a/master/cdev.c b/master/cdev.c
index eb95bfe9..99921247 100644
--- a/master/cdev.c
+++ b/master/cdev.c
@@ -26,9 +26,11 @@
 
 /****************************************************************************/
 
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
+#endif
 
 #include "cdev.h"
 #include "master.h"
diff --git a/master/coe_emerg_ring.c b/master/coe_emerg_ring.c
index b0026c3b..02cf642a 100644
--- a/master/coe_emerg_ring.c
+++ b/master/coe_emerg_ring.c
@@ -26,8 +26,15 @@
  */
 
 /****************************************************************************/
+#include "globals.h"
 
+#ifdef EC_USERMODE
+#include <stdio.h>
+#include <string.h>
+#include "mm.h"
+#else
 #include <linux/slab.h>
+#endif
 
 #include "coe_emerg_ring.h"
 
@@ -57,7 +64,11 @@ void ec_coe_emerg_ring_clear(
         )
 {
     if (ring->msgs) {
+#ifdef EC_USERMODE
+        free(ring->msgs);
+#else
         kfree(ring->msgs);
+#endif
     }
 }
 
@@ -81,7 +92,11 @@ int ec_coe_emerg_ring_size(
     ring->read_index = ring->write_index = 0;
 
     if (ring->msgs) {
+#ifdef EC_USERMODE
+        free(ring->msgs);
+#else
         kfree(ring->msgs);
+#endif
     }
     ring->msgs = NULL;
 
@@ -89,7 +104,11 @@ int ec_coe_emerg_ring_size(
         return 0;
     }
 
+#ifdef EC_USERMODE
+    ring->msgs = malloc(sizeof(ec_coe_emerg_msg_t) * (size + 1));
+#else
     ring->msgs = kmalloc(sizeof(ec_coe_emerg_msg_t) * (size + 1), GFP_KERNEL);
+#endif
     if (!ring->msgs) {
         return -ENOMEM;
     }
diff --git a/master/datagram.c b/master/datagram.c
index c0f3360a..a76bb49e 100644
--- a/master/datagram.c
+++ b/master/datagram.c
@@ -26,7 +26,16 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include <stdio.h>
+#include "mm.h"
+#include "list.h"
+#include "string.h"
+#else
 #include <linux/slab.h>
+#endif
 
 #include "datagram.h"
 #include "master.h"
@@ -34,7 +43,7 @@
 /****************************************************************************/
 
 /** \cond */
-
+#ifndef EC_USERMODE
 #define EC_FUNC_HEADER \
     ret = ec_datagram_prealloc(datagram, data_size); \
     if (unlikely(ret)) \
@@ -42,6 +51,15 @@
     datagram->index = 0; \
     datagram->working_counter = 0; \
     datagram->state = EC_DATAGRAM_INIT;
+#else
+#define EC_FUNC_HEADER \
+    ret = ec_datagram_prealloc(datagram, data_size); \
+    if (ret) \
+        return ret; \
+    datagram->index = 0; \
+    datagram->working_counter = 0; \
+    datagram->state = EC_DATAGRAM_INIT;
+#endif
 
 #define EC_FUNC_FOOTER \
     datagram->data_size = data_size; \
@@ -112,7 +130,11 @@ void ec_datagram_clear(ec_datagram_t *datagram /**< EtherCAT datagram. */)
     ec_datagram_unqueue(datagram);
 
     if (datagram->data_origin == EC_ORIG_INTERNAL && datagram->data) {
+#ifdef EC_USERMODE
+        free(datagram->data);
+#else
         kfree(datagram->data);
+#endif
         datagram->data = NULL;
     }
 }
@@ -149,12 +171,20 @@ int ec_datagram_prealloc(
         return 0;
 
     if (datagram->data) {
+#ifdef EC_USERMODE
+        free(datagram->data);
+#else
         kfree(datagram->data);
+#endif
         datagram->data = NULL;
         datagram->mem_size = 0;
     }
 
+#ifdef EC_USERMODE
+    if (!(datagram->data = malloc(size))) {
+#else
     if (!(datagram->data = kmalloc(size, GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate %zu bytes of datagram memory!\n", size);
         return -ENOMEM;
     }
@@ -558,31 +588,31 @@ void ec_datagram_print_state(
         const ec_datagram_t *datagram /**< EtherCAT datagram */
         )
 {
-    printk(KERN_CONT "Datagram ");
+    ec_print(EC_CONT "Datagram ");
     switch (datagram->state) {
         case EC_DATAGRAM_INIT:
-            printk(KERN_CONT "initialized");
+            ec_print(EC_CONT "initialized");
             break;
         case EC_DATAGRAM_QUEUED:
-            printk(KERN_CONT "queued");
+            ec_print(EC_CONT "queued");
             break;
         case EC_DATAGRAM_SENT:
-            printk(KERN_CONT "sent");
+            ec_print(EC_CONT "sent");
             break;
         case EC_DATAGRAM_RECEIVED:
-            printk(KERN_CONT "received");
+            ec_print(EC_CONT "received");
             break;
         case EC_DATAGRAM_TIMED_OUT:
-            printk(KERN_CONT "timed out");
+            ec_print(EC_CONT "timed out");
             break;
         case EC_DATAGRAM_ERROR:
-            printk(KERN_CONT "error");
+            ec_print(EC_CONT "error");
             break;
         default:
-            printk(KERN_CONT "???");
+            ec_print(EC_CONT "???");
     }
 
-    printk(KERN_CONT ".\n");
+    ec_print(EC_CONT ".\n");
 }
 
 /****************************************************************************/
@@ -596,15 +626,15 @@ void ec_datagram_print_wc_error(
         )
 {
     if (datagram->working_counter == 0) {
-        printk(KERN_CONT "No response.");
+        ec_print(EC_CONT "No response.");
     }
     else if (datagram->working_counter > 1) {
-        printk(KERN_CONT "%u slaves responded!", datagram->working_counter);
+        ec_print(EC_CONT "%u slaves responded!", datagram->working_counter);
     }
     else {
-        printk(KERN_CONT "Success.");
+        ec_print(EC_CONT "Success.");
     }
-    printk(KERN_CONT "\n");
+    ec_print(EC_CONT "\n");
 }
 
 /****************************************************************************/
@@ -615,7 +645,12 @@ void ec_datagram_output_stats(
         ec_datagram_t *datagram
         )
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    if (jiffies - datagram->stats_output_jiffies > NSEC_PER_SEC) {
+#else
     if (jiffies - datagram->stats_output_jiffies > HZ) {
+#endif
         datagram->stats_output_jiffies = jiffies;
 
         if (unlikely(datagram->skip_count)) {
diff --git a/master/datagram.h b/master/datagram.h
index 13184928..a2921578 100644
--- a/master/datagram.h
+++ b/master/datagram.h
@@ -29,11 +29,16 @@
 #ifndef __EC_DATAGRAM_H__
 #define __EC_DATAGRAM_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#include <time.h>
+#else
 #include <linux/list.h>
 #include <linux/time.h>
 #include <linux/timex.h>
-
-#include "globals.h"
+#endif
 
 /****************************************************************************/
 
diff --git a/master/datagram_pair.c b/master/datagram_pair.c
index 3e3d2838..8e7f8cf2 100644
--- a/master/datagram_pair.c
+++ b/master/datagram_pair.c
@@ -26,11 +26,12 @@
 
 /****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "master.h"
 #include "datagram_pair.h"
 
+#ifndef EC_USERMODE
+#include <linux/slab.h>
+#endif
 /****************************************************************************/
 
 /** Datagram pair constructor.
@@ -73,7 +74,11 @@ int ec_datagram_pair_init(
     }
 
 #if EC_MAX_NUM_DEVICES > 1
+#ifdef EC_USERMODE
+    if (!(pair->send_buffer = malloc(data_size))) {
+#else
     if (!(pair->send_buffer = kmalloc(data_size, GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(domain->master,
                 "Failed to allocate domain send buffer!\n");
         ret = -ENOMEM;
@@ -154,7 +159,11 @@ void ec_datagram_pair_clear(
 
 #if EC_MAX_NUM_DEVICES > 1
     if (pair->send_buffer) {
+#ifdef EC_USERMODE
+        free(pair->send_buffer);
+#else
         kfree(pair->send_buffer);
+#endif
     }
 #endif
 }
diff --git a/master/datagram_pair.h b/master/datagram_pair.h
index 0294a216..f8fc8d1d 100644
--- a/master/datagram_pair.h
+++ b/master/datagram_pair.h
@@ -29,9 +29,14 @@
 #ifndef __EC_DATAGRAM_PAIR_H__
 #define __EC_DATAGRAM_PAIR_H__
 
+#include "globals.h"
+
+#ifndef EC_USERMODE
 #include <linux/list.h>
+#else
+#include "list.h"
+#endif
 
-#include "globals.h"
 #include "datagram.h"
 
 /****************************************************************************/
diff --git a/master/debug.c b/master/debug.c
index 268a6bb7..19ad34b4 100644
--- a/master/debug.c
+++ b/master/debug.c
@@ -26,16 +26,20 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifndef EC_USERMODE
 #include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#endif
 
-#include "globals.h"
 #include "master.h"
 #include "debug.h"
 
 /****************************************************************************/
 
+#ifndef EC_USERMODE
 // net_device functions
 int ec_dbgdev_open(struct net_device *);
 int ec_dbgdev_stop(struct net_device *);
@@ -51,7 +55,7 @@ static const struct net_device_ops ec_dbg_netdev_ops =
     .ndo_start_xmit = ec_dbgdev_tx,
     .ndo_get_stats = ec_dbgdev_stats,
 };
-
+#endif
 /****************************************************************************/
 
 /** Debug interface constructor.
@@ -67,6 +71,7 @@ int ec_debug_init(
         const char *name /**< Interface name. */
         )
 {
+#ifndef EC_USERMODE
     dbg->device = device;
     dbg->registered = 0;
     dbg->opened = 0;
@@ -90,7 +95,7 @@ int ec_debug_init(
 
     // initialize private data
     *((ec_debug_t **) netdev_priv(dbg->dev)) = dbg;
-
+#endif
     return 0;
 }
 
@@ -104,10 +109,13 @@ void ec_debug_clear(
         ec_debug_t *dbg /**< debug object */
         )
 {
+#ifndef EC_USERMODE
     ec_debug_unregister(dbg);
     free_netdev(dbg->dev);
+#endif
 }
 
+#ifndef EC_USERMODE
 /****************************************************************************/
 
 /** Register debug interface.
@@ -136,7 +144,7 @@ void ec_debug_register(
         dbg->registered = 1;
     }
 }
-
+#endif
 /****************************************************************************/
 
 /** Unregister debug interface.
@@ -145,11 +153,13 @@ void ec_debug_unregister(
         ec_debug_t *dbg /**< debug object */
         )
 {
+#ifndef EC_USERMODE
     if (dbg->registered) {
         dbg->opened = 0;
         dbg->registered = 0;
         unregister_netdev(dbg->dev);
     }
+#endif
 }
 
 /****************************************************************************/
@@ -162,6 +172,7 @@ void ec_debug_send(
         size_t size /**< size of the frame data */
         )
 {
+#ifndef EC_USERMODE
     struct sk_buff *skb;
 
     if (!dbg->opened)
@@ -185,6 +196,7 @@ void ec_debug_send(
     skb->protocol = eth_type_trans(skb, dbg->dev);
     skb->ip_summed = CHECKSUM_UNNECESSARY;
     netif_rx(skb);
+#endif
 }
 
 /*****************************************************************************
@@ -195,6 +207,7 @@ void ec_debug_send(
  *
  * \return Always zero (success).
  */
+#ifndef EC_USERMODE
 int ec_dbgdev_open(
         struct net_device *dev /**< debug net_device */
         )
@@ -205,6 +218,7 @@ int ec_dbgdev_open(
             dev->name);
     return 0;
 }
+#endif
 
 /****************************************************************************/
 
@@ -212,6 +226,7 @@ int ec_dbgdev_open(
  *
  * \return Always zero (success).
  */
+#ifndef EC_USERMODE
 int ec_dbgdev_stop(
         struct net_device *dev /**< debug net_device */
         )
@@ -222,6 +237,7 @@ int ec_dbgdev_stop(
             dev->name);
     return 0;
 }
+#endif
 
 /****************************************************************************/
 
@@ -229,6 +245,7 @@ int ec_dbgdev_stop(
  *
  * \return Always zero (success).
  */
+#ifndef EC_USERMODE
 int ec_dbgdev_tx(
         struct sk_buff *skb, /**< transmit socket buffer */
         struct net_device *dev /**< EoE net_device */
@@ -240,6 +257,7 @@ int ec_dbgdev_tx(
     dbg->stats.tx_dropped++;
     return 0;
 }
+#endif
 
 /****************************************************************************/
 
@@ -247,6 +265,7 @@ int ec_dbgdev_tx(
  *
  * \return Statistics.
  */
+#ifndef EC_USERMODE
 struct net_device_stats *ec_dbgdev_stats(
         struct net_device *dev /**< debug net_device */
         )
@@ -254,5 +273,6 @@ struct net_device_stats *ec_dbgdev_stats(
     ec_debug_t *dbg = *((ec_debug_t **) netdev_priv(dev));
     return &dbg->stats;
 }
+#endif
 
 /****************************************************************************/
diff --git a/master/debug.h b/master/debug.h
index 5d435d4c..8a7b571d 100644
--- a/master/debug.h
+++ b/master/debug.h
@@ -31,6 +31,7 @@
 
 #include "../devices/ecdev.h"
 
+
 /****************************************************************************/
 
 /** Debugging network interface.
@@ -38,8 +39,10 @@
 typedef struct
 {
     ec_device_t *device; /**< Parent device. */
+#ifndef EC_USERMODE
     struct net_device *dev; /**< net_device for virtual ethernet device */
     struct net_device_stats stats; /**< device statistics */
+#endif
     uint8_t registered; /**< net_device is opened */
     uint8_t opened; /**< net_device is opened */
 }
@@ -49,7 +52,9 @@ ec_debug_t;
 
 int ec_debug_init(ec_debug_t *, ec_device_t *, const char *);
 void ec_debug_clear(ec_debug_t *);
+#ifndef EC_USERMODE
 void ec_debug_register(ec_debug_t *, const struct net_device *);
+#endif
 void ec_debug_unregister(ec_debug_t *);
 void ec_debug_send(ec_debug_t *, const uint8_t *, size_t);
 
diff --git a/master/device.c b/master/device.c
index 598d163a..731bc670 100644
--- a/master/device.c
+++ b/master/device.c
@@ -26,10 +26,17 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "mm.h"
+#include <string.h>
+#else
 #include <linux/module.h>
 #include <linux/skbuff.h>
 #include <linux/if_ether.h>
 #include <linux/netdevice.h>
+#endif
 
 #include "device.h"
 #include "master.h"
@@ -73,7 +80,9 @@ int ec_device_init(
     device->master = master;
     device->dev = NULL;
     device->poll = NULL;
+#ifndef EC_USERMODE
     device->module = NULL;
+#endif
     device->open = 0;
     device->link_state = 0;
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
@@ -124,15 +133,24 @@ int ec_device_init(
 #endif
 
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
+#ifdef EC_USERMODE
+        if (!(device->tx_skb[i] = ec_malloc(ETH_FRAME_LEN + EXTRA_HEADROOM, 0))) {
+#else
         if (!(device->tx_skb[i] = dev_alloc_skb(ETH_FRAME_LEN + EXTRA_HEADROOM))) {
+#endif
             EC_MASTER_ERR(master, "Error allocating device socket buffer!\n");
             ret = -ENOMEM;
             goto out_tx_ring;
         }
 
         // add Ethernet-II-header
+#ifdef EC_USERMODE
+        ec_reserve(device->tx_skb[i], ETH_HLEN + EXTRA_HEADROOM);
+        eth = (struct ethhdr *) ec_skb_push(device->tx_skb[i], ETH_HLEN);
+#else
         skb_reserve(device->tx_skb[i], ETH_HLEN + EXTRA_HEADROOM);
         eth = (struct ethhdr *) skb_push(device->tx_skb[i], ETH_HLEN);
+#endif
         eth->h_proto = htons(0x88A4);
         memset(eth->h_dest, 0xFF, ETH_ALEN);
     }
@@ -142,7 +160,11 @@ int ec_device_init(
 out_tx_ring:
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
         if (device->tx_skb[i]) {
+#ifdef EC_USERMODE
+            ec_free(device->tx_skb[i]);
+#else
             dev_kfree_skb(device->tx_skb[i]);
+#endif
         }
     }
 #ifdef EC_DEBUG_IF
@@ -152,6 +174,12 @@ out_return:
     return ret;
 }
 
+#ifdef EC_USERMODE
+void ec_device_bind(ec_master_t *master, char* argv){
+    ec_dpdk_bind((unsigned char*)master->macs[EC_DEVICE_MAIN], argv);
+}
+#endif
+
 /****************************************************************************/
 
 /** Destructor.
@@ -166,7 +194,11 @@ void ec_device_clear(
         ec_device_close(device);
     }
     for (i = 0; i < EC_TX_RING_SIZE; i++)
+#ifdef EC_USERMODE
+        ec_free(device->tx_skb[i]);
+#else
         dev_kfree_skb(device->tx_skb[i]);
+#endif
 #ifdef EC_DEBUG_IF
     ec_debug_clear(&device->dbg);
 #endif
@@ -178,24 +210,41 @@ void ec_device_clear(
  */
 void ec_device_attach(
         ec_device_t *device, /**< EtherCAT device */
+#ifndef EC_USERMODE
         struct net_device *net_dev, /**< net_device structure */
-        ec_pollfunc_t poll, /**< pointer to device's poll function */
-        struct module *module /**< the device's module */
+#else
+        struct dpdk_dev *dpdk_dev, /**< dpdk_device structure */
+#endif
+        ec_pollfunc_t poll /**< pointer to device's poll function */
+#ifndef EC_USERMODE
+        , struct module *module /**< the device's module */
+#endif
         )
 {
     unsigned int i;
     struct ethhdr *eth;
 
+#ifndef EC_USERMODE
     ec_device_detach(device); // resets fields
-
     device->dev = net_dev;
+#else
+    device->dev = dpdk_dev;
+#endif
     device->poll = poll;
+#ifndef EC_USERMODE
     device->module = module;
+#endif
 
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
+#ifdef EC_USERMODE
+	struct sk_buff *p = (struct sk_buff *)device->tx_skb[i];
+        eth = (struct ethhdr *) (p->data);
+        memcpy(eth->h_source, dpdk_dev->mac, ETH_ALEN);
+#else
         device->tx_skb[i]->dev = net_dev;
         eth = (struct ethhdr *) (device->tx_skb[i]->data);
         memcpy(eth->h_source, net_dev->dev_addr, ETH_ALEN);
+#endif
     }
 
 #ifdef EC_DEBUG_IF
@@ -219,14 +268,20 @@ void ec_device_detach(
 
     device->dev = NULL;
     device->poll = NULL;
+#ifndef EC_USERMODE
     device->module = NULL;
+#endif
     device->open = 0;
     device->link_state = 0; // down
 
     ec_device_clear_stats(device);
 
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
+#ifdef EC_USERMODE
+        device->tx_skb[i] = NULL;
+#else
         device->tx_skb[i]->dev = NULL;
+#endif
     }
 }
 
@@ -256,7 +311,11 @@ int ec_device_open(
 
     ec_device_clear_stats(device);
 
+#ifndef EC_USERMODE
     ret = device->dev->netdev_ops->ndo_open(device->dev);
+#else
+    ret = device->dev->dpdk_ops->dpdk_open(device->dev);
+#endif
     if (!ret)
         device->open = 1;
 
@@ -285,7 +344,13 @@ int ec_device_close(
         return 0;
     }
 
+#ifndef EC_USERMODE
     ret = device->dev->netdev_ops->ndo_stop(device->dev);
+#else
+    if ((device->dev->dpdk_ops)&&(device->dev->dpdk_ops->dpdk_stop)) {
+        ret = device->dev->dpdk_ops->dpdk_stop(device->dev);
+    }
+#endif
     if (!ret)
         device->open = 0;
 
@@ -302,12 +367,20 @@ uint8_t *ec_device_tx_data(
         ec_device_t *device /**< EtherCAT device */
         )
 {
+#ifdef EC_USERMODE
+    struct sk_buff *skb;
+#endif
     /* cycle through socket buffers, because otherwise there is a race
      * condition, if multiple frames are sent and the DMA is not scheduled in
      * between. */
     device->tx_ring_index++;
     device->tx_ring_index %= EC_TX_RING_SIZE;
+#ifdef EC_USERMODE
+    skb = (struct sk_buff*)device->tx_skb[device->tx_ring_index];
+    return skb->data + ETH_HLEN;
+#else
     return device->tx_skb[device->tx_ring_index]->data + ETH_HLEN;
+#endif
 }
 
 /****************************************************************************/
@@ -326,15 +399,22 @@ void ec_device_send(
 
     // set the right length for the data
     skb->len = ETH_HLEN + size;
-
     if (unlikely(device->master->debug_level > 1)) {
         EC_MASTER_DBG(device->master, 2, "Sending frame:\n");
+#ifndef EC_USERMODE
         ec_print_data(skb->data, ETH_HLEN + size);
+#else
+        ec_print_data(skb->data, skb->len);
+#endif
     }
 
     // start sending
+#ifdef EC_USERMODE
+    if (device->dev->dpdk_ops->dpdk_start_xmit(device->dev, skb->data, skb->len) == 0)
+#else
     if (device->dev->netdev_ops->ndo_start_xmit(skb, device->dev) ==
             NETDEV_TX_OK)
+#endif
     {
         device->tx_count++;
         device->master->device_stats.tx_count++;
@@ -379,6 +459,21 @@ void ec_device_clear_stats(
         device->tx_byte_rates[i] = 0;
         device->rx_byte_rates[i] = 0;
     }
+
+#ifdef EC_BENCHMARK
+    for (i = 0; i < NUM_TX_LATENCY; i++) {
+        device->tx_latency[i][0] = 0xffffffff;
+        device->tx_latency[i][1] = 0;
+        device->tx_latency[i][2] = 0;
+    }
+    for (i = 0; i < NUM_RX_LATENCY; i++) {
+        device->rx_latency[i][0] = 0xffffffff;
+        device->rx_latency[i][1] = 0;
+        device->rx_latency[i][2] = 0;
+    }
+    device->tx_cnt = 0;
+    device->rx_cnt = 0;
+#endif
 }
 
 /****************************************************************************/
@@ -467,7 +562,11 @@ void ec_device_poll(
 #ifdef EC_HAVE_CYCLES
     device->cycles_poll = get_cycles();
 #endif
+#ifdef EC_USERMODE
+    device->jiffies_poll = get_jiffies();
+#else
     device->jiffies_poll = jiffies;
+#endif
 #ifdef EC_DEBUG_RING
     do_gettimeofday(&device->timeval_poll);
 #endif
@@ -530,7 +629,9 @@ void ecdev_withdraw(ec_device_t *device /**< EtherCAT device */)
     ec_master_t *master = device->master;
     char dev_str[20], mac_str[20];
 
+#ifndef EC_USERMODE
     ec_mac_print(device->dev->dev_addr, mac_str);
+#endif
 
     if (device == &master->devices[EC_DEVICE_MAIN]) {
         sprintf(dev_str, "main");
@@ -544,9 +645,9 @@ void ecdev_withdraw(ec_device_t *device /**< EtherCAT device */)
 
     EC_MASTER_INFO(master, "Releasing %s device %s.\n", dev_str, mac_str);
 
-    down(&master->device_sem);
+    ec_lock_down(&master->device_sem);
     ec_device_detach(device);
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 }
 
 /****************************************************************************/
@@ -602,9 +703,11 @@ void ecdev_close(ec_device_t *device /**< EtherCAT device */)
         ec_master_leave_idle_phase(master);
     }
 
+#ifndef EC_USERMODE
     if (ec_device_close(device)) {
         EC_MASTER_WARN(master, "Failed to close device!\n");
     }
+#endif
 }
 
 /****************************************************************************/
@@ -674,9 +777,11 @@ void ecdev_set_link(
 
     if (likely(state != device->link_state)) {
         device->link_state = state;
+#ifndef EC_USERMODE
         EC_MASTER_INFO(device->master,
                 "Link state of %s changed to %s.\n",
                 device->dev->name, (state ? "UP" : "DOWN"));
+#endif
     }
 }
 
@@ -703,14 +808,14 @@ uint8_t ecdev_get_link(
 /****************************************************************************/
 
 /** \cond */
-
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecdev_withdraw);
 EXPORT_SYMBOL(ecdev_open);
 EXPORT_SYMBOL(ecdev_close);
 EXPORT_SYMBOL(ecdev_receive);
 EXPORT_SYMBOL(ecdev_get_link);
 EXPORT_SYMBOL(ecdev_set_link);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/device.h b/master/device.h
index 77430931..99f8dea1 100644
--- a/master/device.h
+++ b/master/device.h
@@ -29,10 +29,14 @@
 #ifndef __EC_DEVICE_H__
 #define __EC_DEVICE_H__
 
-#include <linux/interrupt.h>
+#include "globals.h"
 
+#ifndef EC_USERMODE
+#include <linux/interrupt.h>
 #include "../devices/ecdev.h"
-#include "globals.h"
+#else
+#include "../dpdk/ecdev.h"
+#endif
 
 /**
  * Size of the transmit ring.
@@ -73,12 +77,22 @@ typedef struct {
 struct ec_device
 {
     ec_master_t *master; /**< EtherCAT master */
+#ifndef EC_USERMODE
     struct net_device *dev; /**< pointer to the assigned net_device */
+#else
+    struct dpdk_dev *dev; /**< pointer to the assigned dpdk_device */
+#endif
     ec_pollfunc_t poll; /**< pointer to the device's poll function */
+#ifndef EC_USERMODE
     struct module *module; /**< pointer to the device's owning module */
+#endif
     uint8_t open; /**< true, if the net_device has been opened */
     uint8_t link_state; /**< device link state */
+#ifdef EC_USERMODE
+    char *tx_skb[EC_TX_RING_SIZE]; /**< transmit skb ring */
+#else
     struct sk_buff *tx_skb[EC_TX_RING_SIZE]; /**< transmit skb ring */
+#endif
     unsigned int tx_ring_index; /**< last ring entry used to transmit */
 #ifdef EC_HAVE_CYCLES
     cycles_t cycles_poll; /**< cycles of last poll */
@@ -110,6 +124,22 @@ struct ec_device
                                         different statistics cycle periods. */
     s32 rx_byte_rates[EC_RATE_COUNT]; /**< Receive rates in byte/s for
                                         different statistics cycle periods. */
+#ifdef EC_BENCHMARK
+/*
+  NUM_TX_LATENCY 0: tx total latency
+  NUM_TX_LATENCY 1: tx sw latency
+  NUM_TX_LATENCY 2: tx hw latency
+  NUM_RX_LATENCY 0: rx sw latency
+  NUM_STATISTIC 0: min
+  NUM_STATISTIC 1: max
+  NUM_STATISTIC 2: avg
+*/
+
+    u64 tx_latency[NUM_TX_LATENCY][NUM_STATISTIC]; /**< min/max/avg latency of tx total/sw/hw */
+    u64 rx_latency[NUM_RX_LATENCY][NUM_STATISTIC]; /**< min/max/avg latency of rx sw */
+    u64 tx_cnt;
+    u64 rx_cnt;
+#endif
 
 #ifdef EC_DEBUG_IF
     ec_debug_t dbg; /**< debug device */
@@ -126,8 +156,22 @@ struct ec_device
 int ec_device_init(ec_device_t *, ec_master_t *);
 void ec_device_clear(ec_device_t *);
 
-void ec_device_attach(ec_device_t *, struct net_device *, ec_pollfunc_t,
-        struct module *);
+#ifdef EC_USERMODE
+void ec_device_bind(ec_master_t *, char*);
+#endif
+void ec_device_attach(
+		ec_device_t *, 
+#ifndef EC_USERMODE
+		struct net_device *, 
+#else
+		struct dpdk_dev *,
+#endif
+		ec_pollfunc_t
+#ifndef EC_USERMODE
+		,struct module *
+#endif
+		);
+
 void ec_device_detach(ec_device_t *);
 
 int ec_device_open(ec_device_t *);
diff --git a/master/domain.c b/master/domain.c
index d74fd715..854651dd 100644
--- a/master/domain.c
+++ b/master/domain.c
@@ -25,10 +25,14 @@
 */
 
 /****************************************************************************/
+#include "globals.h"
 
+#ifdef EC_USERMODE
+#include "mm.h"
+#else
 #include <linux/module.h>
+#endif
 
-#include "globals.h"
 #include "master.h"
 #include "slave_config.h"
 
@@ -92,7 +96,11 @@ void ec_domain_clear(ec_domain_t *domain /**< EtherCAT domain */)
     list_for_each_entry_safe(datagram_pair, next_pair,
             &domain->datagram_pairs, list) {
         ec_datagram_pair_clear(datagram_pair);
+#ifdef EC_USERMODE
+        free(datagram_pair);
+#else
         kfree(datagram_pair);
+#endif
     }
 
     ec_domain_clear_data(domain);
@@ -107,7 +115,11 @@ void ec_domain_clear_data(
         )
 {
     if (domain->data_origin == EC_ORIG_INTERNAL && domain->data) {
+#ifdef EC_USERMODE
+        free(domain->data);
+#else
         kfree(domain->data);
+#endif
     }
 
     domain->data = NULL;
@@ -154,7 +166,11 @@ int ec_domain_add_datagram_pair(
     ec_datagram_pair_t *datagram_pair;
     int ret;
 
+#ifdef EC_USERMODE
+    if (!(datagram_pair = malloc(sizeof(ec_datagram_pair_t)))) {
+#else
     if (!(datagram_pair = kmalloc(sizeof(ec_datagram_pair_t), GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(domain->master,
                 "Failed to allocate domain datagram pair!\n");
         return -ENOMEM;
@@ -163,7 +179,11 @@ int ec_domain_add_datagram_pair(
     ret = ec_datagram_pair_init(datagram_pair, domain, logical_offset, data,
             data_size, used);
     if (ret) {
+#ifdef EC_USERMODE
+        free(datagram_pair);
+#else
         kfree(datagram_pair);
+#endif
         return ret;
     }
 
@@ -240,7 +260,11 @@ int ec_domain_finish(
 
     if (domain->data_size && domain->data_origin == EC_ORIG_INTERNAL) {
         if (!(domain->data =
+#ifdef EC_USERMODE
+                    (uint8_t *) malloc(domain->data_size))) {
+#else
                     (uint8_t *) kmalloc(domain->data_size, GFP_KERNEL))) {
+#endif
             EC_MASTER_ERR(domain->master, "Failed to allocate %zu bytes"
                     " internal memory for domain %u!\n",
                     domain->data_size, domain->index);
@@ -435,14 +459,14 @@ void ecrt_domain_external_memory(ec_domain_t *domain, uint8_t *mem)
     EC_MASTER_DBG(domain->master, 1, "ecrt_domain_external_memory("
             "domain = 0x%p, mem = 0x%p)\n", domain, mem);
 
-    down(&domain->master->master_sem);
+    ec_lock_down(&domain->master->master_sem);
 
     ec_domain_clear_data(domain);
 
     domain->data = mem;
     domain->data_origin = EC_ORIG_EXTERNAL;
 
-    up(&domain->master->master_sem);
+    ec_lock_up(&domain->master->master_sem);
 }
 
 /****************************************************************************/
@@ -607,9 +631,15 @@ int ecrt_domain_process(ec_domain_t *domain)
     if (wc_change) {
         domain->working_counter_changes++;
     }
-
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     if (domain->working_counter_changes &&
+#ifdef EC_USERMODE
+        jiffies - domain->notify_jiffies > NSEC_PER_SEC) {
+#else
         jiffies - domain->notify_jiffies > HZ) {
+#endif
         domain->notify_jiffies = jiffies;
         if (domain->working_counter_changes == 1) {
             EC_MASTER_INFO(domain->master, "Domain %u: Working counter"
@@ -623,19 +653,19 @@ int ecrt_domain_process(ec_domain_t *domain)
         }
 #if EC_MAX_NUM_DEVICES > 1
         if (ec_master_num_devices(domain->master) > 1) {
-            printk(KERN_CONT " (");
+            ec_print(EC_CONT " (");
             for (dev_idx = EC_DEVICE_MAIN;
                     dev_idx < ec_master_num_devices(domain->master);
                     dev_idx++) {
-                printk(KERN_CONT "%u", domain->working_counter[dev_idx]);
+                ec_print(EC_CONT "%u", domain->working_counter[dev_idx]);
                 if (dev_idx + 1 < ec_master_num_devices(domain->master)) {
-                    printk(KERN_CONT "+");
+                    ec_print(EC_CONT "+");
                 }
             }
-            printk(KERN_CONT ")");
+            ec_print(EC_CONT ")");
         }
 #endif
-        printk(KERN_CONT ".\n");
+        ec_print(EC_CONT ".\n");
 
         domain->working_counter_changes = 0;
     }
@@ -706,6 +736,7 @@ int ecrt_domain_state(const ec_domain_t *domain, ec_domain_state_t *state)
 
 /** \cond */
 
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_domain_reg_pdo_entry_list);
 EXPORT_SYMBOL(ecrt_domain_size);
 EXPORT_SYMBOL(ecrt_domain_external_memory);
@@ -713,7 +744,7 @@ EXPORT_SYMBOL(ecrt_domain_data);
 EXPORT_SYMBOL(ecrt_domain_process);
 EXPORT_SYMBOL(ecrt_domain_queue);
 EXPORT_SYMBOL(ecrt_domain_state);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/domain.h b/master/domain.h
index 5408628b..6c190c5f 100644
--- a/master/domain.h
+++ b/master/domain.h
@@ -29,9 +29,12 @@
 #ifndef __EC_DOMAIN_H__
 #define __EC_DOMAIN_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 #include "datagram.h"
 #include "master.h"
 #include "fmmu_config.h"
diff --git a/master/ecrt_config.c b/master/ecrt_config.c
new file mode 100644
index 00000000..73e04793
--- /dev/null
+++ b/master/ecrt_config.c
@@ -0,0 +1,383 @@
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "ecrt_config.h"
+
+#define ECRT_DEFAULT_CONFIG "/etc/sysconfig/ecrt.conf"
+
+static ecrt_config_t * ecrt_config_initial_alloc()
+{
+    ecrt_config_t *config = NULL;
+
+    config = malloc(sizeof(ecrt_config_t));
+    if (config == NULL)
+        return NULL;
+
+    memset (config, 0, sizeof(ecrt_config_t));
+    INIT_LIST_HEAD(&config->list);
+
+    return config;
+}
+
+static ecrt_node_t * ecrt_config_node_initial()
+{
+    ecrt_node_t *node = NULL;
+
+    node = malloc(sizeof(ecrt_node_t));
+    if (node == NULL)
+        return NULL;
+    memset (node, 0, sizeof(ecrt_node_t));
+
+    /* Initial struct */
+    INIT_LIST_HEAD(&node->list);
+    node->master_id = ECRT_INVALID_MASTER_ID;
+    memset (node->master_mac, 0xFF, ETH_ALEN);
+    node->drv_argv = NULL;
+    node->debug_level = 0;
+
+    return node;
+}
+
+static int newline_terminated(const char *buff, size_t bufflen)
+{
+    size_t len;
+
+    if ((buff == NULL) || (bufflen <= 0))
+        return -1;
+    len = strlen(buff);
+    if (len == 0)
+        return 0;
+    if (len == bufflen - 1 && buff[bufflen - 1] != '\r' && buff[len - 1] != '\n' )
+        return 0;
+    return -1;
+}
+
+static void skip_line_end(FILE *stream)
+{
+    char buff[100];
+
+    if (stream == NULL)
+        return;
+    while (fgets(buff, sizeof(buff), stream)) {
+        buff[sizeof(buff) - 1] = '\0';
+        if (newline_terminated(buff, sizeof(buff)))
+            return;
+    }
+}
+
+char* ecrt_config_read_line(char *s, int size, FILE *stream, int *line, char **pos)
+{
+    char *pos_, *end_, *start_;
+
+    if ((s == NULL) || (size <= 0) || (stream == NULL) || (line == NULL))
+        return NULL;
+
+    while (fgets(s, size, stream)) {
+        if (size == 0) {
+	    printf("size=0\n");
+	    break;
+	}
+        (*line)++;
+	s[size - 1] = '\0';
+	if (!newline_terminated(s, size)) {
+            skip_line_end(stream);
+	}
+	pos_ = s;
+
+	/* Skip white space from the beginning of line. */
+        while (*pos_ == ' ' || *pos_ == '\t' || *pos_ == '\r')
+            pos_++;
+        /* Skip comment lines and empty lines */
+        if (*pos_ == '#' || *pos_ == '\n' || *pos_ == '\0')
+            continue;
+
+        /* Remove # comments unless they are within a double quoted string. */
+        start_ = strchr(pos_, '"');
+        if (start_)
+            start_ = strrchr(start_ + 1, '"');
+        if (!start_)
+            start_ = pos_;
+        end_ = strchr(start_, '#');
+        if (end_)
+            *end_-- = '\0';
+        else
+            end_ = pos_ + strlen(pos_) - 1;
+
+	/* Remove trailing white space. */
+        while (end_ > pos_ &&
+               (*end_ == '\n' || *end_ == ' ' || *end_ == '\t' ||
+               *end_ == '\r'))
+               *end_-- = '\0';
+        if (*pos_ == '\0')
+            continue;
+        if (pos)
+            *pos = pos_;
+        return *pos;
+    }
+
+    if (pos)
+        *pos = NULL;
+    return NULL;
+}
+
+static int ecrt_config_parse_int(const char *value)
+{
+    int val;
+    char *end;
+
+    if (value == NULL)
+        return -1;
+
+    val = strtol(value, &end, 0);
+    if (*end) {
+        return -1;
+    }
+    return val;
+}
+
+static char* dup_binstr(const void *src, size_t len)
+{
+    char *res;
+
+    if ((src == NULL) || (len <= 0))
+        return NULL;
+    res = malloc(len + 1);
+    if (res == NULL)
+        return NULL;
+    memcpy(res, src, len);
+    res[len] = '\0';
+
+    return res;
+}
+
+static char* ecrt_config_parse_str(const char *value, size_t *len)
+{
+    if (value == NULL)
+        return NULL;
+
+    if (*value == '"') {
+        const char *pos;
+	char *str = NULL;
+	value++;
+	pos = strrchr(value, '"');
+	if (pos == NULL || pos[1] != '\0')
+            return NULL;
+	if (len) {
+	    *len = pos - value;
+	    str = dup_binstr(value, *len);
+	}
+	if (str == NULL)
+            return NULL;
+	return str;
+    }
+
+    return NULL;
+}
+
+static int ecrt_config_validate_node(ecrt_node_t *node, int line)
+{
+    int errors = 0;
+
+    if (node == NULL)
+        return 1;
+    /* Valid master id valid */
+    if (node->master_id == ECRT_INVALID_MASTER_ID)
+        errors++;
+    /* Valid MAC address valid*/
+    if (node->master_mac[0]&0x02) {
+        errors++;
+    } else if (node->master_mac[0] == 0 && 
+               node->master_mac[1] == 0 &&
+               node->master_mac[2] == 0 &&
+               node->master_mac[3] == 0 &&
+               node->master_mac[4] == 0 &&
+               node->master_mac[5] == 0 ) {
+	errors++;
+    } else if (node->master_mac[0] == 0xFF && 
+               node->master_mac[1] == 0xFF &&
+               node->master_mac[2] == 0xFF &&
+               node->master_mac[3] == 0xFF &&
+               node->master_mac[4] == 0xFF &&
+               node->master_mac[5] == 0xFF ) {
+	errors++;
+    }
+    return errors;
+}
+
+static int ecrt_mac_parse(char *mac, char *src, int allow_empty)
+{
+    unsigned int i, value;
+    const char *orig = src;
+    char *rem;
+
+    if ((mac == NULL) || (src == NULL))
+        return -EINVAL;
+
+    if (!strlen(src)) {
+        if (allow_empty){
+            return 0;
+        } else {
+            EC_ERR("MAC address may not be empty.\n");
+            return -EINVAL;
+        }
+    }
+
+    for (i = 0; i < ETH_ALEN; i++) {
+        value = strtoul(src, &rem, 16);
+        if (rem != src + 2
+                || value > 0xFF
+                || (i < ETH_ALEN - 1 && *rem != ':')) {
+            EC_ERR("Invalid MAC address \"%s\".\n", orig);
+            return -EINVAL;
+        }
+        mac[i] = value;
+        if (i < ETH_ALEN - 1) {
+            src = rem + 1; // skip colon
+        }
+    }
+
+    return 0;
+}
+
+static void ecrt_config_free_node(ecrt_node_t *node)
+{
+    if (node) {
+        free(node);
+    }
+}
+
+static ecrt_node_t * ecrt_config_read_node(FILE *filenode, int *line, ecrt_node_t * node)
+{
+   char buff[512], *pos, *pos2;
+   int errors = 0;
+   int end = 0;
+   int len = 0;
+
+   if ((filenode == NULL) || (line == NULL) || (node == NULL))
+       return NULL;
+   while (ecrt_config_read_line(buff, sizeof(buff), filenode, line, &pos)) {
+       if (strcmp(pos, "}") == 0) {
+           end = 1;
+           break;
+       }
+
+       pos2 = strchr(pos, '=');
+       if (pos2 == NULL) {
+           errors++;
+	   continue;
+       }
+
+       *pos2++ = '\0';
+       if (*pos2 == '"') {
+           if (strchr(pos2 + 1, '"') == NULL) {
+	       errors++;
+	       continue;
+	   }
+       }
+
+       if (strcmp(pos, "master_id") == 0) {
+           node->master_id = ecrt_config_parse_int(pos2);
+       } else if (strcmp(pos, "master_mac") == 0) {
+           char* mac = ecrt_config_parse_str(pos2, &len);
+	   ecrt_mac_parse(node->master_mac, mac, 0);
+       } else if (strcmp(pos, "debug_level") == 0) {
+           node->debug_level = ecrt_config_parse_int(pos2);
+       } else if (strcmp(pos, "drv_argv") == 0) {
+           node->drv_argv = ecrt_config_parse_str(pos2, &len);
+       }
+   }
+
+   if (!end) {
+       errors++;
+   }
+
+   errors += ecrt_config_validate_node(node, *line);
+   if (errors) {
+       ecrt_config_free_node(node);
+       node = NULL;
+   }
+   return node;
+}
+
+static ecrt_config_t * ecrt_config_read(const char *name)
+{
+    FILE *filenode;
+    char buff[512], *pos;
+    int line = 0;
+
+    ecrt_config_t *config;
+    ecrt_node_t *node;
+
+    if (name == NULL)
+        return NULL;
+    config = ecrt_config_initial_alloc();
+    if (config == NULL)
+        return NULL;
+    
+    filenode = fopen(name, "r");
+    if (filenode == NULL) {
+        printf("Failed to open config file '%s' error:%s \n", name, strerror(errno));
+	free(config);
+	return NULL;
+    }
+
+    while (ecrt_config_read_line(buff, sizeof(buff), filenode, &line, &pos)) {
+        if (strcmp(pos, "ethercat={") == 0) {
+            ecrt_node_t *node1;
+            node = ecrt_config_node_initial();
+            node1 = ecrt_config_read_node(filenode, &line, node);
+            if (node1) {
+                list_add_tail(&node->list, &config->list);
+            }
+        }
+    }
+    fclose(filenode);
+
+    return config;
+}
+
+ecrt_node_t * ecrt_config_get_node_by_id(ec_master_t *master, int id)
+{
+    ecrt_node_t *node;
+    ecrt_config_t *conf;
+    if (master == NULL)
+        return NULL;
+    else if(master->ecrt_conf == NULL) {
+        if (ecrt_load_configuration(master) != 0)
+            return NULL;
+    }
+    if (id == ECRT_INVALID_MASTER_ID)
+        return NULL;
+    conf = master->ecrt_conf;
+    list_for_each_entry(node, &conf->list, list) {
+        if (node == NULL) {
+            return NULL;
+	}
+        if (node->master_id == id) {
+            return node;
+	 }
+    }
+    return NULL;
+}
+
+int ecrt_load_configuration(ec_master_t *master)
+{
+    ecrt_config_t *conf;
+
+    if(!master)
+        return -1;
+
+    if (master->confname == NULL)
+        conf = ecrt_config_read(ECRT_DEFAULT_CONFIG);
+    else
+        conf = ecrt_config_read(master->confname);
+    if (conf == NULL) {
+        EC_MASTER_ERR(master, "Failed to parse the configuration of EtherCAT(%s)", \
+			((master->confname == NULL)?ECRT_DEFAULT_CONFIG:master->confname));
+        return -1;
+    }
+    master->ecrt_conf = conf;
+    return 0;
+}
diff --git a/master/ecrt_config.h b/master/ecrt_config.h
new file mode 100644
index 00000000..cc808d2b
--- /dev/null
+++ b/master/ecrt_config.h
@@ -0,0 +1,31 @@
+#ifndef __ECRT_CONFIG_H__
+#define __ECRT_CONFIG_H__
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "list.h"
+
+#include "master.h"
+
+#ifndef ETH_ALEN
+#define ETH_ALEN 6
+#endif
+
+#define ECRT_INVALID_MASTER_ID    (0xffffffff)
+typedef struct ecrt_config {
+    struct list_head list;
+} ecrt_config_t;
+
+typedef struct ecrt_node {
+    struct list_head list;
+    int master_id;
+    unsigned char master_mac[ETH_ALEN];
+    int debug_level;
+    char* drv_argv;
+} ecrt_node_t;
+
+ecrt_node_t * ecrt_config_get_node_by_id(ec_master_t *, int);
+int ecrt_load_configuration(ec_master_t *master);
+#endif
diff --git a/master/eoe_request.c b/master/eoe_request.c
index f336cf34..ac946f2c 100644
--- a/master/eoe_request.c
+++ b/master/eoe_request.c
@@ -23,11 +23,14 @@
  * Ethernet-over-EtherCAT request functions.
  */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
+#endif
 
 #include "eoe_request.h"
 
diff --git a/master/eoe_request.h b/master/eoe_request.h
index 6751f1f9..f9b0399e 100644
--- a/master/eoe_request.h
+++ b/master/eoe_request.h
@@ -29,10 +29,14 @@
 #ifndef __EC_EOE_REQUEST_H__
 #define __EC_EOE_REQUEST_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
 #include <linux/etherdevice.h> // ETH_ALEN
+#endif
 
-#include "globals.h"
 
 /****************************************************************************/
 
diff --git a/master/ethercatd.c b/master/ethercatd.c
new file mode 100644
index 00000000..d5261ae5
--- /dev/null
+++ b/master/ethercatd.c
@@ -0,0 +1,801 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C) 2006-2008  Florian Pose, Ingenieurgemeinschaft IgH
+ *
+ *  This file is part of the IgH EtherCAT Master.
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT Master; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+/** \file
+ * EtherCAT master driver module.
+ */
+
+/*****************************************************************************/
+
+#include "globals.h"
+#ifndef EC_USERMODE
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#else
+#include <semaphore.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include "../ipc/ipc_iface.h"
+#include "ioctl.h"
+#include <fcntl.h>
+#if !EC_ENABLE_DAEMON
+#include <pthread.h>
+#include "ecrt.h"
+#endif
+#endif
+
+#include "master.h"
+#include "device.h"
+
+/*****************************************************************************/
+
+#define MAX_MASTERS 32 /**< Maximum number of masters. */
+
+/*****************************************************************************/
+
+static int ec_mac_parse(uint8_t *, const char *, int);
+
+static char* dpdk_argv;
+/*****************************************************************************/
+
+static char *main_devices[MAX_MASTERS]; /**< Main devices parameter. */
+static unsigned int master_count; /**< Number of masters. */
+static char *backup_devices[MAX_MASTERS]; /**< Backup devices parameter. */
+static unsigned int backup_count; /**< Number of backup devices. */
+static unsigned int debug_level = 0;  /**< Debug level parameter. */
+static unsigned int master_id= 0;
+
+static ec_master_t *masters; /**< Array of masters. */
+static ec_lock_t master_sem; /**< Master semaphore. */
+
+dev_t device_number; /**< Device number for master cdevs. */
+struct class *class; /**< Device class. */
+
+static uint8_t macs[MAX_MASTERS][2][ETH_ALEN]; /**< MAC addresses. */
+
+char *ec_master_version_str = EC_MASTER_VERSION; /**< Version string. */
+
+/*****************************************************************************/
+
+/** \cond */
+
+
+/** \endcond */
+
+/*****************************************************************************/
+static void ec_ipc_process(ec_master_t *master) {
+    char* data=master->ipcs+1;
+    unsigned int cmd;
+    int *ret;
+    int dir;
+    unsigned int arg;
+
+    ret = (int*)data;
+    data += sizeof(int);
+    cmd = *(unsigned int*)data;
+    data += sizeof(unsigned int);
+    dir = _IOC_DIR(cmd);
+    switch(dir) {
+        case _IOC_NONE:
+            arg = *(unsigned int*)data;
+            *ret = ec_ioctl(master, &master->ctx, cmd, (void*)arg);
+            break;
+        default:
+            *ret = ec_ioctl(master, &master->ctx, cmd, data);
+            break;
+    }
+}
+
+#if !EC_ENABLE_DAEMON
+static void ec_master_ipc_thread(ec_master_t *master) {
+#else
+static int terminal = 1;
+static void ec_master_ipc_run(ec_master_t *master) {
+#endif
+    char* guard = ipc_iface_atomic_create(master->ipcs);
+    master->ctx.writable = 1;
+    master->ctx.requested = 0;
+    master->ctx.process_data = NULL;
+    master->ctx.process_data_size = 0;
+#if !EC_ENABLE_DAEMON
+    while (master->ipc_thread_status) {
+#else
+    while (terminal) {
+#endif
+        if (ipc_iface_atomic_wait(guard) == 0) {
+            ec_ipc_process(master);
+            ipc_iface_atomic_notify(guard);
+	}
+    }
+    printf("ipc thread stopped\n");
+}
+
+static int ec_mac_process(uint8_t *main, uint8_t *backup){
+    int i, ret = 0;
+    // zero MAC addresses
+    memset(macs, 0x00, sizeof(uint8_t) * MAX_MASTERS * 2 *ETH_ALEN);
+    //process MAC parameters
+    for (i = 0; i < master_count; i++) {
+        if (main == NULL)
+            break;
+	memcpy(macs[i][0], main, ETH_ALEN);
+	if (backup == NULL)
+            continue;
+    }
+    return 0;
+}
+
+static void getOptions(int argc, char**argv){
+    int index;
+    uint8_t *main = NULL, *backup = NULL;
+    static struct option longOptions[] = {
+        {"master id", required_argument, NULL, 'm'},
+        {"help", no_argument, NULL, 'h'},
+        {}
+    };
+
+    do {
+        index = getopt_long(argc, argv, "m:h", longOptions, NULL);
+        switch(index) {
+            case 'm':
+                master_id = atoi(optarg);
+                break;
+            case 'h':
+                printf("Global options:\n");
+                printf("	--master_id   -m Specify master ID\n");
+                printf("	--help	 -h Show this help.\n");
+                if (main) {
+                    free(main);
+                    main = NULL;
+                }
+                if (backup) {
+                    free(backup);
+                    backup = NULL;
+                }
+                exit(0);
+                break;
+            }
+        } while(index != -1);
+}
+
+#if !EC_ENABLE_DAEMON
+static void ethercatd_ipc_start(ec_master_t *master)
+{
+    int ret;
+    pthread_attr_t attr;
+    struct sched_param schparam;
+
+    if (master->ipc_thread) {
+        EC_MASTER_WARN(master, "IPC already running!\n");
+	return;
+    }
+    EC_MASTER_INFO(master, "Starting IPC thread.\n");
+    master->ipc_thread = calloc(1, sizeof(pthread_t));
+    if (master->ipc_thread == NULL) {
+        EC_MASTER_ERR(master, "Failed to calloc IPC thread!\n");
+	return;
+    }
+    master->ipc_thread_status = 1;
+    pthread_attr_init(&attr);
+    ret = pthread_create(master->ipc_thread, &attr, ec_master_ipc_thread, master);
+    pthread_attr_destroy(&attr);
+    if (ret != 0) {
+        EC_MASTER_ERR(master, "Failed to start IPC thread (error %i)!\n",
+		ret);
+	free(master->ipc_thread);
+	master->ipc_thread = NULL;
+	return;
+    }
+    memset(&schparam, 0, sizeof(schparam));
+    schparam.sched_priority = EC_MASTER_IPC_THREAD_PRIO;
+    ret = pthread_setschedparam(*master->ipc_thread, SCHED_OTHER, &schparam);
+    if (ret < 0) {
+        EC_MASTER_ERR(master, "Failed to set thread as SCHED_IDLE (error %i)!\n",
+		ret);
+	free(master->ipc_thread);
+	master->ipc_thread = NULL;
+	return;
+    }
+}
+
+static void ethercatd_ipc_stop(ec_master_t *master)
+{
+    if (master->ipc_thread) {
+        EC_MASTER_INFO(master, "Stopping IPC thread.\n");
+	master->ipc_thread_status = 0;
+	ipc_ctrl_atomic_exit(master->ipcs);
+	if (master->ipc_thread) {
+            pthread_cancel(*master->ipc_thread);
+            pthread_join(*master->ipc_thread, NULL);
+	    free(master->ipc_thread);
+	    master->ipc_thread = NULL;
+        }
+	EC_MASTER_INFO(master, "IPC thread exited.\n");
+    }
+}
+#endif
+/** Ethercatd Entry
+ *
+ * Initialize \a master_count masters.
+ * \return 0 on success, else < 0
+ */
+#if EC_ENABLE_DAEMON
+int main(int argc, char **argv)
+#else
+int ethercatd_master_init(int master_index)
+#endif
+{
+    int i, ret = 0;
+    ecrt_node_t *node;
+
+    EC_INFO("Master driver %s\n", EC_MASTER_VERSION);
+#ifdef EC_RTDM
+    if (!realtime_core_enabled())
+        return 0;
+#endif
+    master_count = 1;
+    backup_count = 0;
+    sem_init(&master_sem, 0, 1);
+
+#if EC_ENABLE_DAEMON
+    getOptions(argc, argv);
+#endif
+    // initialize static master variables
+    ec_master_init_static();
+    if (master_count) {
+        if (!(masters = (ec_master_t*)malloc(sizeof(ec_master_t) * master_count))) {
+            EC_ERR("Failed to allocate memory"
+                    " for EtherCAT masters.\n");
+            ret = -ENOMEM;
+            goto out_class;
+        }
+        memset (masters, 0, sizeof(ec_master_t) * master_count);
+    }
+#if EC_ENABLE_DAEMON
+    node = ecrt_config_get_node_by_id(masters, master_id);
+#else
+    node = ecrt_config_get_node_by_id(masters, master_index);
+#endif
+    if (ec_mac_process(node->master_mac, NULL))
+        exit(0);
+    for (i = 0; i < master_count; i++) {
+        ret = ec_master_init(&masters[i], i, macs[i][0], macs[i][1], node->debug_level, node->drv_argv);
+        if (ret)
+            goto out_free_masters;
+    }
+    EC_INFO("%u master%s waiting for devices.\n",
+            master_count, (master_count == 1 ? "" : "s"));
+#if EC_ENABLE_DAEMON
+    ec_master_ipc_run(&masters[0]);
+    ipc_iface_release(masters[0].seg_id, masters[0].ipcs);
+    goto out_free_masters;
+#else
+    ethercatd_ipc_start(&masters[0]);
+#endif
+    return ret;
+
+out_free_masters:
+    for (i--; i >= 0; i--)
+        ec_master_clear(&masters[i]);
+    if (masters)
+    	free(masters);
+out_class:
+out_return:
+    return ret;
+}
+
+/*****************************************************************************/
+
+/*****************************************************************************/
+
+/** Get the number of masters.
+ */
+unsigned int ec_master_count(void)
+{
+    return master_count;
+}
+
+/*****************************************************************************
+ * MAC address functions
+ ****************************************************************************/
+
+/**
+ * \return true, if two MAC addresses are equal.
+ */
+int ec_mac_equal(
+        const uint8_t *mac1, /**< First MAC address. */
+        const uint8_t *mac2 /**< Second MAC address. */
+        )
+{
+    unsigned int i;
+
+    for (i = 0; i < ETH_ALEN; i++)
+        if (mac1[i] != mac2[i])
+            return 0;
+
+    return 1;
+}
+
+/*****************************************************************************/
+#ifdef EC_USERMODE
+/** Maximum MAC string size.
+ */
+#define EC_MAX_MAC_STRING_SIZE (3 * ETH_ALEN)
+
+/** Print a MAC address to a buffer.
+ *
+ * The buffer size must be at least EC_MAX_MAC_STRING_SIZE.
+ *
+ * \return number of bytes written.
+ */
+size_t ec_mac_print(
+        const uint8_t *mac, /**< MAC address */
+        char *buffer /**< Target buffer. */
+        )
+{
+    off_t off = 0;
+    unsigned int i;
+
+    for (i = 0; i < ETH_ALEN; i++) {
+        off += sprintf(buffer + off, "%02X", mac[i]);
+        if (i < ETH_ALEN - 1) off += sprintf(buffer + off, ":");
+    }
+
+    return off;
+}
+
+/*****************************************************************************/
+
+/**
+ * \return true, if the MAC address is all-zero.
+ */
+int ec_mac_is_zero(
+        const uint8_t *mac /**< MAC address. */
+        )
+{
+    unsigned int i;
+
+    for (i = 0; i < ETH_ALEN; i++)
+        if (mac[i])
+            return 0;
+
+    return 1;
+}
+
+/*****************************************************************************/
+
+/**
+ * \return true, if the given MAC address is the broadcast address.
+ */
+int ec_mac_is_broadcast(
+        const uint8_t *mac /**< MAC address. */
+        )
+{
+    unsigned int i;
+
+    for (i = 0; i < ETH_ALEN; i++)
+        if (mac[i] != 0xff)
+            return 0;
+
+    return 1;
+}
+
+/*****************************************************************************/
+
+/** Parse a MAC address from a string.
+ *
+ * The MAC address must match the regular expression
+ * "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}".
+ *
+ * \return 0 on success, else < 0
+ */
+static int ec_mac_parse(uint8_t *mac, const char *src, int allow_empty)
+{
+    unsigned int i, value;
+    const char *orig = src;
+    char *rem;
+
+    if (!strlen(src)) {
+        if (allow_empty){
+            return 0;
+        } else {
+            EC_ERR("MAC address may not be empty.\n");
+            return -EINVAL;
+        }
+    }
+
+    for (i = 0; i < ETH_ALEN; i++) {
+        value = strtoul(src, &rem, 16);
+        if (rem != src + 2
+                || value > 0xFF
+                || (i < ETH_ALEN - 1 && *rem != ':')) {
+            EC_ERR("Invalid MAC address \"%s\".\n", orig);
+            return -EINVAL;
+        }
+        mac[i] = value;
+        if (i < ETH_ALEN - 1) {
+            src = rem + 1; // skip colon
+        }
+    }
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+/** Outputs frame contents for debugging purposes.
+ * If the data block is larger than 256 bytes, only the first 128
+ * and the last 128 bytes will be shown
+ */
+void ec_print_data(const uint8_t *data, /**< pointer to data */
+                   size_t size /**< number of bytes to output */
+                   )
+{
+    unsigned int i;
+
+    EC_DBG("");
+    for (i = 0; i < size; i++) {
+        printf("%02X ", data[i]);
+
+        if ((i + 1) % 16 == 0 && i < size - 1) {
+            printf("\n");
+            EC_DBG("");
+        }
+
+        if (i + 1 == 128 && size > 256) {
+            printf("dropped %zu bytes\n", size - 128 - i);
+            i = size - 128;
+            EC_DBG("");
+        }
+    }
+    printf("\n");
+}
+
+/*****************************************************************************/
+
+/** Outputs frame contents and differences for debugging purposes.
+ */
+void ec_print_data_diff(const uint8_t *d1, /**< first data */
+                        const uint8_t *d2, /**< second data */
+                        size_t size /** number of bytes to output */
+                        )
+{
+    unsigned int i;
+
+    EC_DBG("");
+    for (i = 0; i < size; i++) {
+        if (d1[i] == d2[i]) printf(".. ");
+        else printf("%02X ", d2[i]);
+        if ((i + 1) % 16 == 0) {
+            printf("\n");
+            EC_DBG("");
+        }
+    }
+    printf("\n");
+}
+#endif
+/*****************************************************************************/
+
+/** Prints slave states in clear text.
+ *
+ * \return Size of the created string.
+ */
+size_t ec_state_string(uint8_t states, /**< slave states */
+                       char *buffer, /**< target buffer
+                                       (min. EC_STATE_STRING_SIZE bytes) */
+                       uint8_t multi /**< Show multi-state mask. */
+                       )
+{
+    off_t off = 0;
+    unsigned int first = 1;
+
+    if (!states) {
+        off += sprintf(buffer + off, "(unknown)");
+        return off;
+    }
+
+    if (multi) { // multiple slaves
+        if (states & EC_SLAVE_STATE_INIT) {
+            off += sprintf(buffer + off, "INIT");
+            first = 0;
+        }
+        if (states & EC_SLAVE_STATE_PREOP) {
+            if (!first) off += sprintf(buffer + off, ", ");
+            off += sprintf(buffer + off, "PREOP");
+            first = 0;
+        }
+        if (states & EC_SLAVE_STATE_SAFEOP) {
+            if (!first) off += sprintf(buffer + off, ", ");
+            off += sprintf(buffer + off, "SAFEOP");
+            first = 0;
+        }
+        if (states & EC_SLAVE_STATE_OP) {
+            if (!first) off += sprintf(buffer + off, ", ");
+            off += sprintf(buffer + off, "OP");
+        }
+    } else { // single slave
+        if ((states & EC_SLAVE_STATE_MASK) == EC_SLAVE_STATE_INIT) {
+            off += sprintf(buffer + off, "INIT");
+        } else if ((states & EC_SLAVE_STATE_MASK) == EC_SLAVE_STATE_PREOP) {
+            off += sprintf(buffer + off, "PREOP");
+        } else if ((states & EC_SLAVE_STATE_MASK) == EC_SLAVE_STATE_BOOT) {
+            off += sprintf(buffer + off, "BOOT");
+        } else if ((states & EC_SLAVE_STATE_MASK) == EC_SLAVE_STATE_SAFEOP) {
+            off += sprintf(buffer + off, "SAFEOP");
+        } else if ((states & EC_SLAVE_STATE_MASK) == EC_SLAVE_STATE_OP) {
+            off += sprintf(buffer + off, "OP");
+        } else {
+            off += sprintf(buffer + off, "(invalid)");
+        }
+        first = 0;
+    }
+
+    if (states & EC_SLAVE_STATE_ACK_ERR) {
+        if (!first) off += sprintf(buffer + off, " + ");
+        off += sprintf(buffer + off, "ERROR");
+    }
+
+    return off;
+}
+
+/******************************************************************************
+ *  Device interface
+ *****************************************************************************/
+
+/** Device names.
+ */
+const char *ec_device_names[2] = {
+    "main",
+    "backup"
+};
+
+/** Offers an EtherCAT device to a certain master.
+ *
+ * The master decides, if it wants to use the device for EtherCAT operation,
+ * or not. It is important, that the offered net_device is not used by the
+ * kernel IP stack. If the master, accepted the offer, the address of the
+ * newly created EtherCAT device is returned, else \a NULL is returned.
+ *
+ * \return Pointer to device, if accepted, or NULL if declined.
+ * \ingroup DeviceInterface
+ */
+ec_device_t *ecdev_offer(
+	struct dpdk_dev *dpdk_dev,
+        ec_pollfunc_t poll /**< device poll function */
+        )
+{
+    ec_master_t *master;
+    char str[EC_MAX_MAC_STRING_SIZE];
+    unsigned int i, dev_idx;
+    for (i = 0; i < master_count; i++) {
+        master = &masters[i];
+        //ec_mac_print(net_dev->dev_addr, str);
+
+        if (ec_lock_down_interruptible(&master->device_sem)) {
+            EC_MASTER_WARN(master, "%s() interrupted!\n", __func__);
+            return NULL;
+        }
+
+        for (dev_idx = EC_DEVICE_MAIN;
+                dev_idx < ec_master_num_devices(master); dev_idx++) {
+            //if (!master->devices[dev_idx].dev
+            //    && (ec_mac_equal(master->macs[dev_idx], net_dev->dev_addr)
+            //        || ec_mac_is_broadcast(master->macs[dev_idx]))) {
+
+            if (!master->devices[dev_idx].dev
+                    || ec_mac_is_broadcast(master->macs[dev_idx])) {
+                EC_INFO("Accepting %s as %s device for master %u.\n",
+                        str, ec_device_names[dev_idx != 0], master->index);
+
+                ec_device_attach(&master->devices[dev_idx],
+			dpdk_dev,
+			poll
+			);
+                ec_lock_up(&master->device_sem);
+
+                //snprintf(net_dev->name, IFNAMSIZ, "ec%c%u",
+                //        ec_device_names[dev_idx != 0][0], master->index);
+
+                return &master->devices[dev_idx]; // offer accepted
+            }
+        }
+
+        ec_lock_up(&master->device_sem);
+
+        EC_MASTER_DBG(master, 1, "Master declined device %s.\n", str);
+    }
+    return NULL; // offer declined
+}
+
+/******************************************************************************
+ * Application interface
+ *****************************************************************************/
+#if !EC_ENABLE_DAEMON
+int ecrt_master_set_send_interval(
+	ec_master_t *master,
+	size_t send_interval
+	)
+{
+    if (!master)
+        return -EFAULT;
+    ec_master_set_send_interval(master, send_interval);
+    return 0;
+}
+#endif
+
+/** Request a master.
+ *
+ * Same as ecrt_request_master(), but with ERR_PTR() return value.
+ *
+ * \return Requested master.
+ */
+ec_master_t *ecrt_request_master_err(
+        unsigned int master_index /**< Master index. */
+        )
+{
+    ec_master_t *master, *errptr = NULL;
+    unsigned int dev_idx = EC_DEVICE_MAIN;
+
+    EC_INFO("Requesting master %u...\n", master_index);
+
+    if (master_index >= master_count) {
+        EC_ERR("Invalid master index %u.\n", master_index);
+        errptr = ERR_PTR(-EINVAL);
+        goto out_return;
+    }
+    master = &masters[master_index];
+
+    if (ec_lock_down_interruptible(&master_sem)) {
+        errptr = ERR_PTR(-EINTR);
+        goto out_return;
+    }
+
+    if (master->reserved) {
+        ec_lock_up(&master_sem);
+        EC_MASTER_ERR(master, "Master already in use!\n");
+        errptr = ERR_PTR(-EBUSY);
+        goto out_return;
+    }
+    master->reserved = 1;
+    ec_lock_up(&master_sem);
+
+    if (ec_lock_down_interruptible(&master->device_sem)) {
+        errptr = ERR_PTR(-EINTR);
+        goto out_release;
+    }
+
+    while (master->phase != EC_IDLE) {sched_yield();};
+    if (master->phase != EC_IDLE) {
+        ec_lock_up(&master->device_sem);
+        EC_MASTER_ERR(master, "Master still waiting for devices!\n");
+        errptr = ERR_PTR(-ENODEV);
+        goto out_release;
+    }
+
+    ec_lock_up(&master->device_sem);
+#if !EC_ENABLE_DAEMON
+    sleep(10);
+#endif
+    if (ec_master_enter_operation_phase(master)) {
+        EC_MASTER_ERR(master, "Failed to enter OPERATION phase!\n");
+        errptr = ERR_PTR(-EIO);
+        goto out_module_put;
+    }
+
+    while (master->phase != EC_OPERATION){sched_yield();};
+    EC_INFO("Successfully requested master %u.\n", master_index);
+    return master;
+
+ out_module_put:
+    for (; dev_idx > 0; dev_idx--) {
+        ec_device_t *device = &master->devices[dev_idx - 1];
+        //module_put(device->module);
+    }
+ out_release:
+    master->reserved = 0;
+ out_return:
+    return errptr;
+}
+
+/*****************************************************************************/
+
+ec_master_t *ecrt_request_master(unsigned int master_index)
+{
+#if !EC_ENABLE_DAEMON
+    ethercatd_master_init(master_index);
+#endif
+    ec_master_t *master = ecrt_request_master_err(master_index);
+    return IS_ERR(master) ? NULL : master;
+}
+
+/*****************************************************************************/
+
+void ecrt_release_master(ec_master_t *master)
+{
+    unsigned int dev_idx;
+
+    EC_MASTER_INFO(master, "Releasing master...\n");
+
+    if (!master->reserved) {
+        EC_MASTER_WARN(master, "%s(): Master was was not requested!\n",
+                __func__);
+        return;
+    }
+
+#if !EC_ENABLE_DAEMON
+    ethercatd_ipc_stop(master);
+#endif
+    ec_master_leave_operation_phase(master);
+    master->reserved = 0;
+#if !EC_ENABLE_DAEMON
+    ec_master_clear(master);
+    if (master) {
+        free(master);
+    }
+#endif
+    EC_MASTER_INFO(master, "Released.\n");
+}
+
+/*****************************************************************************/
+
+unsigned int ecrt_version_magic(void)
+{
+    return ECRT_VERSION_MAGIC;
+}
+
+/*****************************************************************************/
+
+/** Global request state type translation table.
+ *
+ * Translates an internal request state to an external one.
+ */
+const ec_request_state_t ec_request_state_translation_table[] = {
+    EC_REQUEST_UNUSED,  // EC_INT_REQUEST_INIT,
+    EC_REQUEST_BUSY,    // EC_INT_REQUEST_QUEUED,
+    EC_REQUEST_BUSY,    // EC_INT_REQUEST_BUSY,
+    EC_REQUEST_SUCCESS, // EC_INT_REQUEST_SUCCESS,
+    EC_REQUEST_ERROR    // EC_INT_REQUEST_FAILURE
+};
+
+/*****************************************************************************/
+
+/** \cond */
+
+//EXPORT_SYMBOL(ecdev_offer);
+
+//EXPORT_SYMBOL(ecrt_request_master);
+//EXPORT_SYMBOL(ecrt_release_master);
+//EXPORT_SYMBOL(ecrt_version_magic);
+
+/** \endcond */
+
+/*****************************************************************************/
diff --git a/master/ethernet.c b/master/ethernet.c
index 089c8aec..6bafe5f2 100644
--- a/master/ethernet.c
+++ b/master/ethernet.c
@@ -26,13 +26,17 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#else
 #include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/lockdep.h>
 #include <linux/skbuff.h>
+#endif
 
-#include "globals.h"
 #include "master.h"
 #include "slave.h"
 #include "mailbox.h"
@@ -229,7 +233,11 @@ void ec_eoe_clear(ec_eoe_t *eoe /**< EoE handler */)
 
     if (eoe->tx_frame) {
         dev_kfree_skb(eoe->tx_frame->skb);
+#ifdef EC_USERMODE
+        free(eoe->tx_frame);
+#else
         kfree(eoe->tx_frame);
+#endif
     }
 
     if (eoe->rx_skb)
@@ -259,7 +267,11 @@ void ec_eoe_flush(ec_eoe_t *eoe /**< EoE handler */)
     list_for_each_entry_safe(frame, next, &tx_queue, queue) {
         list_del(&frame->queue);
         dev_kfree_skb(frame->skb);
+#ifdef EC_USERMODE
+        free(tx_frame);
+#else
         kfree(frame);
+#endif
     }
 }
 
@@ -307,14 +319,14 @@ int ec_eoe_send(ec_eoe_t *eoe /**< EoE handler */)
 #if EOE_DEBUG_LEVEL >= 3
     EC_SLAVE_DBG(eoe->slave, 0, "");
     for (i = 0; i < current_size; i++) {
-        printk(KERN_CONT "%02X ",
+        ec_print(EC_CONT "%02X ",
                 eoe->tx_frame->skb->data[eoe->tx_offset + i]);
         if ((i + 1) % 16 == 0) {
-            printk(KERN_CONT "\n");
+            ec_print(EC_CONT "\n");
             EC_SLAVE_DBG(eoe->slave, 0, "");
         }
     }
-    printk(KERN_CONT "\n");
+    ec_print(EC_CONT "\n");
 #endif
 
     data = ec_slave_mbox_prepare_send(eoe->slave, &eoe->datagram,
@@ -540,13 +552,13 @@ void ec_eoe_state_rx_fetch(ec_eoe_t *eoe /**< EoE handler */)
 #if EOE_DEBUG_LEVEL >= 3
     EC_SLAVE_DBG(eoe->slave, 0, "");
     for (i = 0; i < rec_size - 4; i++) {
-        printk(KERN_CONT "%02X ", data[i + 4]);
+        ec_print(EC_CONT "%02X ", data[i + 4]);
         if ((i + 1) % 16 == 0) {
-            printk(KERN_CONT "\n");
+            ec_print(EC_CONT "\n");
             EC_SLAVE_DBG(eoe->slave, 0, "");
         }
     }
-    printk(KERN_CONT "\n");
+    ec_print(EC_CONT "\n");
 #endif
 
     data_size = time_appended ? rec_size - 8 : rec_size - 4;
@@ -559,7 +571,9 @@ void ec_eoe_state_rx_fetch(ec_eoe_t *eoe /**< EoE handler */)
 
         // new socket buffer
         if (!(eoe->rx_skb = dev_alloc_skb(fragment_offset * 32))) {
+#ifndef EC_USERMODE
             if (printk_ratelimit())
+#endif
                 EC_SLAVE_WARN(eoe->slave, "EoE RX low on mem,"
                         " frame dropped.\n");
             eoe->stats.rx_dropped++;
@@ -843,10 +857,14 @@ int ec_eoedev_tx(struct sk_buff *skb, /**< transmit socket buffer */
 
     WARN_ON_ONCE(skb_get_queue_mapping(skb) != 0);
     lockdep_assert_held(&netdev_get_tx_queue(dev, 0)->_xmit_lock);
-
+#ifdef EC_USERMODE
+    if (!(frame =
+          (ec_eoe_frame_t *) malloc(sizeof(ec_eoe_frame_t)))) {
+#else
     if (!(frame =
           (ec_eoe_frame_t *) kmalloc(sizeof(ec_eoe_frame_t), GFP_ATOMIC))) {
         if (printk_ratelimit())
+#endif
             EC_SLAVE_WARN(eoe->slave, "EoE TX: low on mem. frame dropped.\n");
         return 1;
     }
diff --git a/master/ethernet.h b/master/ethernet.h
index ef0a8810..f73bb97d 100644
--- a/master/ethernet.h
+++ b/master/ethernet.h
@@ -29,10 +29,16 @@
 #ifndef __EC_ETHERNET_H__
 #define __EC_ETHERNET_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#include "rt_locks.h"
+#else
 #include <linux/list.h>
 #include <linux/netdevice.h>
+#endif
 
-#include "globals.h"
 #include "slave.h"
 #include "datagram.h"
 
@@ -57,7 +63,11 @@ enum {
 typedef struct
 {
     struct list_head queue; /**< list item */
+#ifdef EC_USERMODE
+    char *skb;
+#else
     struct sk_buff *skb; /**< socket buffer */
+#endif
 }
 ec_eoe_frame_t;
 
@@ -78,8 +88,10 @@ struct ec_eoe
     ec_datagram_t datagram; /**< datagram */
     unsigned int queue_datagram; /**< the datagram is ready for queuing */
     void (*state)(ec_eoe_t *); /**< state function for the state machine */
+#ifndef EC_USERMODE
     struct net_device *dev; /**< net_device for virtual ethernet device */
     struct net_device_stats stats; /**< device statistics */
+#endif
     unsigned int opened; /**< net_device is opened */
     unsigned long rate_jiffies; /**< time of last rate output */
 
diff --git a/master/flag.c b/master/flag.c
index 652d35b1..413db981 100644
--- a/master/flag.c
+++ b/master/flag.c
@@ -25,7 +25,13 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "mm.h"
+#else
 #include <linux/slab.h>
+#endif
 
 #include "flag.h"
 
@@ -42,8 +48,11 @@ int ec_flag_init(
     if (!key || strlen(key) == 0) {
         return -EINVAL;
     }
-
+#ifdef EC_USERMODE
+    if (!(flag->key = (uint8_t *) malloc(strlen(key) + 1))) {
+#else
     if (!(flag->key = (uint8_t *) kmalloc(strlen(key) + 1, GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
@@ -61,7 +70,11 @@ void ec_flag_clear(
         )
 {
     if (flag->key) {
+#ifdef EC_USERMODE
+        free(flag->key);
+#else
         kfree(flag->key);
+#endif
         flag->key = NULL;
     }
 }
diff --git a/master/flag.h b/master/flag.h
index e7679c2f..a2eb523c 100644
--- a/master/flag.h
+++ b/master/flag.h
@@ -29,7 +29,12 @@
 #ifndef __EC_FLAG_H__
 #define __EC_FLAG_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
 /****************************************************************************/
 
diff --git a/master/foe_request.c b/master/foe_request.c
index 3b68f734..e7d5dd7e 100644
--- a/master/foe_request.c
+++ b/master/foe_request.c
@@ -24,13 +24,17 @@
  * File-over-EtherCAT request functions.
  */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
-
+#else
+#include "mm.h"
+#endif
 #include "foe_request.h"
 #include "foe.h"
 
@@ -86,7 +90,11 @@ void ec_foe_request_clear_data(
         )
 {
     if (req->buffer) {
+#ifdef EC_USERMODE
+        free(req->buffer);
+#else
         vfree(req->buffer);
+#endif
         req->buffer = NULL;
     }
 
@@ -114,7 +122,11 @@ int ec_foe_request_alloc(
 
     ec_foe_request_clear_data(req);
 
+#ifdef EC_USERMODE
+    if (!(req->buffer = (uint8_t *) malloc(size))) {
+#else
     if (!(req->buffer = (uint8_t *) vmalloc(size))) {
+#endif
         EC_ERR("Failed to allocate %zu bytes of FoE memory.\n", size);
         return -ENOMEM;
     }
@@ -160,8 +172,14 @@ int ec_foe_request_timed_out(
         const ec_foe_request_t *req /**< FoE request. */
         )
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    return req->issue_timeout
+        && jiffies - req->jiffies_start > req->issue_timeout * 1000000;
+#else
     return req->issue_timeout
         && jiffies - req->jiffies_start > HZ * req->issue_timeout / 1000;
+#endif
 }
 
 /****************************************************************************/
@@ -172,6 +190,9 @@ void ec_foe_request_read(
         ec_foe_request_t *req /**< FoE request. */
         )
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->dir = EC_DIR_INPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->result = FOE_BUSY;
@@ -186,6 +207,9 @@ void ec_foe_request_write(
         ec_foe_request_t *req /**< FoE request. */
         )
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->dir = EC_DIR_OUTPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->result = FOE_BUSY;
diff --git a/master/foe_request.h b/master/foe_request.h
index ba5ceb66..7971db2b 100644
--- a/master/foe_request.h
+++ b/master/foe_request.h
@@ -29,13 +29,16 @@
 #ifndef __EC_FOE_REQUEST_H__
 #define __EC_FOE_REQUEST_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
 #include "../include/ecrt.h"
 
-#include "globals.h"
-
-/****************************************************************************/
+/*****************************************************************************/
 
 /** FoE request.
  */
diff --git a/master/fsm_change.c b/master/fsm_change.c
index 98fae184..032ea443 100644
--- a/master/fsm_change.c
+++ b/master/fsm_change.c
@@ -226,7 +226,11 @@ void ec_fsm_change_state_check(ec_fsm_change_t *fsm
     }
 
     if (datagram->working_counter == 0) {
+#ifdef EC_USERMODE
+        if (datagram->jiffies_received - fsm->jiffies_start >= 3 * NSEC_PER_SEC) {
+#else
         if (datagram->jiffies_received - fsm->jiffies_start >= 3 * HZ) {
+#endif
             char state_str[EC_STATE_STRING_SIZE];
             ec_state_string(fsm->requested_state, state_str, 0);
             fsm->state = ec_fsm_change_state_error;
@@ -337,8 +341,13 @@ void ec_fsm_change_state_status(ec_fsm_change_t *fsm
     // still old state
 
     timeout_ms = ec_fsm_change_timeout_ms(fsm);
+#ifdef EC_USERMODE
+    if (datagram->jiffies_received - fsm->jiffies_start >=
+            timeout_ms * NSEC_PER_SEC/1000) {
+#else
     if (datagram->jiffies_received - fsm->jiffies_start >=
             timeout_ms * HZ / 1000) {
+#endif
         // timeout while checking
         char state_str[EC_STATE_STRING_SIZE];
         ec_state_string(fsm->requested_state, state_str, 0);
@@ -573,8 +582,13 @@ void ec_fsm_change_state_check_ack(ec_fsm_change_t *fsm
     }
 
     timeout_ms = ec_fsm_change_timeout_ms(fsm);
+#ifdef EC_USERMODE
+    if (datagram->jiffies_received - fsm->jiffies_start >=
+            timeout_ms * NSEC_PER_SEC/1000) {
+#else
     if (datagram->jiffies_received - fsm->jiffies_start >=
             timeout_ms * HZ / 1000) {
+#endif
         // timeout while checking
         char state_str[EC_STATE_STRING_SIZE];
         ec_state_string(slave->current_state, state_str, 0);
diff --git a/master/fsm_coe.c b/master/fsm_coe.c
index 69765cd0..3358cdfd 100644
--- a/master/fsm_coe.c
+++ b/master/fsm_coe.c
@@ -31,7 +31,13 @@
 #include "fsm_coe.h"
 #include "slave_config.h"
 
-/****************************************************************************/
+#ifdef EC_USERMODE
+//#include <errno.h>
+#include <stdbool.h>
+#include "mm.h"
+#endif
+
+/*****************************************************************************/
 
 /** Maximum time in ms to wait for responses when reading out the dictionary.
  */
@@ -443,9 +449,15 @@ void ec_fsm_coe_dict_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= EC_FSM_COE_DICT_TIMEOUT) {
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout while waiting for"
@@ -607,7 +619,11 @@ void ec_fsm_coe_dict_response(
             continue;
         }
 
+#ifdef EC_USERMODE
+        if (!(sdo = (ec_sdo_t *) malloc(sizeof(ec_sdo_t)))) {
+#else
         if (!(sdo = (ec_sdo_t *) kmalloc(sizeof(ec_sdo_t), GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate memory for SDO!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -725,9 +741,15 @@ void ec_fsm_coe_dict_desc_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= EC_FSM_COE_DICT_TIMEOUT) {
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout while waiting for"
@@ -886,7 +908,11 @@ void ec_fsm_coe_dict_desc_response(
 
     name_size = rec_size - 12;
     if (name_size) {
+#ifdef EC_USERMODE
+        if (!(sdo->name = malloc(name_size + 1))) {
+#else
         if (!(sdo->name = kmalloc(name_size + 1, GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate SDO name!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -989,9 +1015,15 @@ void ec_fsm_coe_dict_entry_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= EC_FSM_COE_DICT_TIMEOUT) {
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout while waiting for"
@@ -1125,7 +1157,11 @@ void ec_fsm_coe_dict_entry_response(
         data_size = rec_size - 16;
 
         if (!(entry = (ec_sdo_entry_t *)
+#ifdef EC_USERMODE
+              malloc(sizeof(ec_sdo_entry_t)))) {
+#else
               kmalloc(sizeof(ec_sdo_entry_t), GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate entry!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -1148,7 +1184,11 @@ void ec_fsm_coe_dict_entry_response(
 
         if (data_size) {
             uint8_t *desc;
+#ifdef EC_USERMODE
+            if (!(desc = malloc(data_size + 1))) {
+#else
             if (!(desc = kmalloc(data_size + 1, GFP_KERNEL))) {
+#endif
                 EC_SLAVE_ERR(slave, "Failed to allocate SDO entry name!\n");
                 fsm->state = ec_fsm_coe_error;
                 return;
@@ -1212,7 +1252,7 @@ int ec_fsm_coe_prepare_down_start(
         data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
                 EC_COE_DOWN_REQ_HEADER_SIZE);
         if (IS_ERR(data)) {
-            request->errno = PTR_ERR(data);
+            request->err = PTR_ERR(data);
             return PTR_ERR(data);
         }
 
@@ -1253,7 +1293,7 @@ int ec_fsm_coe_prepare_down_start(
         data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
                 data_size);
         if (IS_ERR(data)) {
-            request->errno = PTR_ERR(data);
+            request->err = PTR_ERR(data);
             return PTR_ERR(data);
         }
 
@@ -1314,7 +1354,7 @@ void ec_fsm_coe_down_start(
 
     if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
-        request->errno = EPROTONOSUPPORT;
+        request->err = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -1322,12 +1362,15 @@ void ec_fsm_coe_down_start(
     if (slave->configured_rx_mailbox_size <
             EC_MBOX_HEADER_SIZE + EC_COE_DOWN_REQ_HEADER_SIZE) {
         EC_SLAVE_ERR(slave, "Mailbox too small!\n");
-        request->errno = ENOBUFS;
+        request->err = ENOBUFS;
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->request->jiffies_sent = jiffies;
     fsm->retries = EC_FSM_RETRIES;
 
@@ -1359,7 +1402,7 @@ void ec_fsm_coe_down_request(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE download"
                 " request datagram: ");
@@ -1367,7 +1410,12 @@ void ec_fsm_coe_down_request(
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    diff_ms = (jiffies - fsm->request->jiffies_sent) / 1000000;
+#else
     diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+#endif
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -1384,7 +1432,7 @@ void ec_fsm_coe_down_request(
                 return;
             }
         }
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE download request"
                 " for SDO 0x%04x:%x failed with timeout after %lu ms: ",
@@ -1424,7 +1472,7 @@ void ec_fsm_coe_down_check(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check"
                 " datagram: ");
@@ -1433,7 +1481,7 @@ void ec_fsm_coe_down_check(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check"
                 " datagram failed: ");
@@ -1442,11 +1490,17 @@ void ec_fsm_coe_down_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting"
                     " for SDO 0x%04x:%x download response.\n", diff_ms,
@@ -1503,7 +1557,7 @@ void ec_fsm_coe_down_prepare_segment_request(
     data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
             data_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -1551,7 +1605,7 @@ void ec_fsm_coe_down_response(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE download"
                 " response datagram: ");
@@ -1560,7 +1614,7 @@ void ec_fsm_coe_down_response(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE download response failed: ");
         ec_datagram_print_wc_error(fsm->datagram);
@@ -1569,13 +1623,13 @@ void ec_fsm_coe_down_response(
 
     data = ec_slave_mbox_fetch(slave, fsm->datagram, &mbox_prot, &rec_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
@@ -1596,7 +1650,7 @@ void ec_fsm_coe_down_response(
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received data are too small (%zu bytes):\n",
                 rec_size);
@@ -1607,7 +1661,7 @@ void ec_fsm_coe_down_response(
     if (EC_READ_U16(data) >> 12 == 0x2 && // SDO request
         EC_READ_U8 (data + 2) >> 5 == 0x4) { // abort SDO transfer request
         char subidxstr[10];
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         if (request->complete_access) {
             subidxstr[0] = 0x00;
@@ -1667,7 +1721,7 @@ void ec_fsm_coe_down_seg_check(
         return;
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check datagram: ");
         ec_datagram_print_state(fsm->datagram);
@@ -1675,7 +1729,7 @@ void ec_fsm_coe_down_seg_check(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox segment check"
                 " datagram failed: ");
@@ -1684,11 +1738,17 @@ void ec_fsm_coe_down_seg_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout while waiting for SDO download"
                     " segment response.\n");
@@ -1729,7 +1789,7 @@ void ec_fsm_coe_down_seg_response(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE download response"
                 " datagram: ");
@@ -1738,7 +1798,7 @@ void ec_fsm_coe_down_seg_response(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE download response failed: ");
         ec_datagram_print_wc_error(fsm->datagram);
@@ -1747,13 +1807,13 @@ void ec_fsm_coe_down_seg_response(
 
     data = ec_slave_mbox_fetch(slave, fsm->datagram, &mbox_prot, &rec_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
@@ -1774,7 +1834,7 @@ void ec_fsm_coe_down_seg_response(
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received data are too small (%zu bytes):\n",
                 rec_size);
@@ -1785,7 +1845,7 @@ void ec_fsm_coe_down_seg_response(
     if (EC_READ_U16(data) >> 12 == 0x2 && // SDO request
         EC_READ_U8 (data + 2) >> 5 == 0x4) { // abort SDO transfer request
         char subidxstr[10];
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         if (request->complete_access) {
             subidxstr[0] = 0x00;
@@ -1822,7 +1882,7 @@ void ec_fsm_coe_down_seg_response(
         EC_SLAVE_ERR(slave, "Invalid toggle received during"
                 " segmented download:\n");
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -1856,7 +1916,7 @@ int ec_fsm_coe_prepare_up(
     u8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
 			10);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         return PTR_ERR(data);
     }
 
@@ -1894,11 +1954,14 @@ void ec_fsm_coe_up_start(
 
     if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
-        request->errno = EPROTONOSUPPORT;
+        request->err = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->retries = EC_FSM_RETRIES;
     fsm->request->jiffies_sent = jiffies;
 
@@ -1929,14 +1992,19 @@ void ec_fsm_coe_up_request(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload request: ");
         ec_datagram_print_state(fsm->datagram);
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    diff_ms = (jiffies - fsm->request->jiffies_sent) / 1000000;
+#else
     diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+#endif
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -1953,7 +2021,7 @@ void ec_fsm_coe_up_request(
                 return;
             }
         }
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload request for"
                 " SDO 0x%04x:%x failed with timeout after %lu ms: ",
@@ -1995,7 +2063,7 @@ void ec_fsm_coe_up_check(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check datagram: ");
         ec_datagram_print_state(fsm->datagram);
@@ -2003,7 +2071,7 @@ void ec_fsm_coe_up_check(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check"
                 " datagram failed: ");
@@ -2012,11 +2080,17 @@ void ec_fsm_coe_up_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting for"
                     " SDO 0x%04x:%x upload response.\n", diff_ms,
@@ -2048,7 +2122,7 @@ void ec_fsm_coe_up_prepare_segment_request(
         ec_slave_mbox_prepare_send(fsm->slave, datagram, EC_MBOX_TYPE_COE,
 				10);
     if (IS_ERR(data)) {
-        fsm->request->errno = PTR_ERR(data);
+        fsm->request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2091,7 +2165,7 @@ void ec_fsm_coe_up_response(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload response"
                 " datagram: ");
@@ -2100,7 +2174,7 @@ void ec_fsm_coe_up_response(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload response failed: ");
         ec_datagram_print_wc_error(fsm->datagram);
@@ -2109,7 +2183,7 @@ void ec_fsm_coe_up_response(
 
     data = ec_slave_mbox_fetch(slave, fsm->datagram, &mbox_prot, &rec_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2120,7 +2194,7 @@ void ec_fsm_coe_up_response(
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_WARN(slave, "Received mailbox protocol 0x%02X"
                 " as response.\n", mbox_prot);
@@ -2136,7 +2210,7 @@ void ec_fsm_coe_up_response(
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received currupted SDO upload response"
                 " (%zu bytes)!\n", rec_size);
@@ -2154,7 +2228,7 @@ void ec_fsm_coe_up_response(
         } else {
             EC_SLAVE_ERR(slave, "No abort message.\n");
         }
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2165,7 +2239,7 @@ void ec_fsm_coe_up_response(
                 " uploading SDO 0x%04X:%02X.\n",
                 request->index, request->subindex);
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2198,7 +2272,7 @@ void ec_fsm_coe_up_response(
         }
 
         if (rec_size < 6 + fsm->complete_size) {
-            request->errno = EIO;
+            request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Received corrupted SDO expedited upload"
                     " response (only %zu bytes)!\n", rec_size);
@@ -2208,13 +2282,13 @@ void ec_fsm_coe_up_response(
 
         ret = ec_sdo_request_copy_data(request, data + 6, fsm->complete_size);
         if (ret) {
-            request->errno = -ret;
+            request->err = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
     } else { // normal
         if (rec_size < 10) {
-            request->errno = EIO;
+            request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Received currupted SDO normal upload"
                     " response (only %zu bytes)!\n", rec_size);
@@ -2227,14 +2301,14 @@ void ec_fsm_coe_up_response(
 
         ret = ec_sdo_request_alloc(request, fsm->complete_size);
         if (ret) {
-            request->errno = -ret;
+            request->err = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
 
         ret = ec_sdo_request_copy_data(request, data + 10, data_size);
         if (ret) {
-            request->errno = -ret;
+            request->err = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
@@ -2279,7 +2353,7 @@ void ec_fsm_coe_up_seg_request(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload segment"
                 " request datagram: ");
@@ -2288,7 +2362,7 @@ void ec_fsm_coe_up_seg_request(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload segment"
                 " request failed: ");
@@ -2322,7 +2396,7 @@ void ec_fsm_coe_up_seg_check(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check"
                 " datagram: ");
@@ -2331,7 +2405,7 @@ void ec_fsm_coe_up_seg_check(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check datagram"
                 " failed: ");
@@ -2340,11 +2414,17 @@ void ec_fsm_coe_up_seg_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Timeout while waiting for SDO upload"
                     " segment response.\n");
@@ -2387,7 +2467,7 @@ void ec_fsm_coe_up_seg_response(
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload segment"
                 " response datagram: ");
@@ -2396,7 +2476,7 @@ void ec_fsm_coe_up_seg_response(
     }
 
     if (fsm->datagram->working_counter != 1) {
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload segment"
                 " response failed: ");
@@ -2406,7 +2486,7 @@ void ec_fsm_coe_up_seg_response(
 
     data = ec_slave_mbox_fetch(slave, fsm->datagram, &mbox_prot, &rec_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2419,7 +2499,7 @@ void ec_fsm_coe_up_seg_response(
     if (mbox_prot != EC_MBOX_TYPE_COE) {
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2436,7 +2516,7 @@ void ec_fsm_coe_up_seg_response(
         EC_SLAVE_ERR(slave, "Received currupted SDO upload"
                 " segment response!\n");
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2447,7 +2527,7 @@ void ec_fsm_coe_up_seg_response(
                request->index, request->subindex);
         request->abort_code = EC_READ_U32(data + 6);
         ec_canopen_abort_msg(slave, request->abort_code);
-        request->errno = EIO;
+        request->err = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2476,7 +2556,7 @@ void ec_fsm_coe_up_seg_response(
         EC_SLAVE_ERR(slave, "SDO upload 0x%04X:%02X failed: Fragment"
                 " exceeding complete size!\n",
                 request->index, request->subindex);
-        request->errno = ENOBUFS;
+        request->err = ENOBUFS;
         fsm->state = ec_fsm_coe_error;
         return;
     }
diff --git a/master/fsm_foe.c b/master/fsm_foe.c
index 378ae369..567fac0b 100644
--- a/master/fsm_foe.c
+++ b/master/fsm_foe.c
@@ -36,7 +36,11 @@
 
 /** Maximum time in ms to wait for responses when reading out the dictionary.
  */
+#ifdef EC_USERMODE
+#define EC_FSM_FOE_TIMEOUT (3 * NSEC_PER_SEC)
+#else
 #define EC_FSM_FOE_TIMEOUT 3000
+#endif
 
 /** Size of the FoE header.
  */
@@ -357,8 +361,13 @@ void ec_fsm_foe_state_ack_check(
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
         // slave did not put anything in the mailbox yet
+#ifdef EC_USERMODE
+	unsigned long diff_ms = (fsm->datagram->jiffies_received - 
+		fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
         unsigned long diff_ms = (fsm->datagram->jiffies_received -
                 fsm->jiffies_start) * 1000 / HZ;
+#endif
         if (diff_ms >= EC_FSM_FOE_TIMEOUT) {
             ec_foe_set_tx_error(fsm, FOE_TIMEOUT_ERROR);
             EC_SLAVE_ERR(slave, "Timeout while waiting for ack response.\n");
@@ -528,6 +537,9 @@ void ec_fsm_foe_state_data_sent(
     }
 
     ec_slave_mbox_prepare_check(slave, datagram);
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->jiffies_start = jiffies;
     fsm->retries = EC_FSM_RETRIES;
     fsm->state = ec_fsm_foe_state_ack_check;
@@ -696,8 +708,13 @@ void ec_fsm_foe_state_data_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
+#ifdef EC_USERMODE
+	unsigned long diff_ms = (fsm->datagram->jiffies_received - 
+		fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
         unsigned long diff_ms = (fsm->datagram->jiffies_received -
                 fsm->jiffies_start) * 1000 / HZ;
+#endif
         if (diff_ms >= EC_FSM_FOE_TIMEOUT) {
             ec_foe_set_tx_error(fsm, FOE_TIMEOUT_ERROR);
             EC_SLAVE_ERR(slave, "Timeout while waiting for ack response.\n");
@@ -830,12 +847,12 @@ void ec_fsm_foe_state_data_read(
         // no more data fits into the delivered buffer
         // ... wait for new read request
         EC_SLAVE_ERR(slave, "Data do not fit in receive buffer!\n");
-        printk(KERN_CONT "  rx_buffer_size = %d\n", fsm->rx_buffer_size);
-        printk(KERN_CONT "rx_buffer_offset = %d\n", fsm->rx_buffer_offset);
-        printk(KERN_CONT "        rec_size = %zd\n", rec_size);
-        printk(KERN_CONT " rx_mailbox_size = %d\n",
+        ec_print(EC_CONT "  rx_buffer_size = %d\n", fsm->rx_buffer_size);
+        ec_print(EC_CONT "rx_buffer_offset = %d\n", fsm->rx_buffer_offset);
+        ec_print(EC_CONT "        rec_size = %zd\n", rec_size);
+        ec_print(EC_CONT " rx_mailbox_size = %d\n",
                 slave->configured_rx_mailbox_size);
-        printk(KERN_CONT "  rx_last_packet = %d\n", fsm->rx_last_packet);
+        ec_print(EC_CONT "  rx_last_packet = %d\n", fsm->rx_last_packet);
         fsm->request->result = FOE_READY;
     }
 }
diff --git a/master/fsm_master.c b/master/fsm_master.c
index 2290608b..bbc7ac57 100644
--- a/master/fsm_master.c
+++ b/master/fsm_master.c
@@ -33,6 +33,12 @@
 #include "ethernet.h"
 #endif
 
+#ifdef EC_USERMODE
+#include "mm.h"
+#include "wq.h"
+#include "string.h"
+#endif
+
 #include "fsm_master.h"
 #include "fsm_foe.h"
 
@@ -340,20 +346,23 @@ void ec_fsm_master_state_broadcast(
     }
 
     if (fsm->rescan_required) {
-        down(&master->scan_sem);
+        ec_lock_down(&master->scan_sem);
         if (!master->allow_scan) {
-            up(&master->scan_sem);
+            ec_lock_up(&master->scan_sem);
         } else {
             unsigned int count = 0, next_dev_slave, ring_position;
             ec_device_index_t dev_idx;
 
             master->scan_busy = 1;
             master->scan_index = 0;
-            up(&master->scan_sem);
+            ec_lock_up(&master->scan_sem);
 
             // clear all slaves and scan the bus
             fsm->rescan_required = 0;
             fsm->idle = 0;
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
             fsm->scan_jiffies = jiffies;
 
 #ifdef EC_EOE
@@ -377,7 +386,11 @@ void ec_fsm_master_state_broadcast(
 
             size = sizeof(ec_slave_t) * count;
             if (!(master->slaves =
+#ifdef EC_USERMODE
+                        (ec_slave_t *) malloc(size))) {
+#else
                         (ec_slave_t *) kmalloc(size, GFP_KERNEL))) {
+#endif
                 EC_MASTER_ERR(master, "Failed to allocate %u bytes"
                         " of slave memory!\n", size);
                 master->scan_busy = 0;
@@ -617,6 +630,9 @@ void ec_fsm_master_action_idle(
         ec_fsm_slave_set_ready(&slave->fsm);
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     // check, if slaves have an SDO dictionary to read out.
     for (slave = master->slaves;
             slave < master->slaves + master->slave_count;
@@ -627,7 +643,11 @@ void ec_fsm_master_action_idle(
                 || slave->sdo_dictionary_fetched
                 || slave->current_state == EC_SLAVE_STATE_INIT
                 || slave->current_state == EC_SLAVE_STATE_UNKNOWN
+#ifdef EC_USERMODE
+                || jiffies - slave->jiffies_preop < EC_WAIT_SDO_DICT / NSEC_PER_SEC
+#else
                 || jiffies - slave->jiffies_preop < EC_WAIT_SDO_DICT * HZ
+#endif
                 ) continue;
 
         EC_SLAVE_DBG(slave, 1, "Fetching SDO dictionary.\n");
@@ -710,9 +730,9 @@ void ec_fsm_master_action_configure(
                 || slave->force_config) && !slave->error_flag) {
 
         // Start slave configuration
-        down(&master->config_sem);
+        ec_lock_down(&master->config_sem);
         master->config_busy = 1;
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
 
         if (master->debug_level) {
             char old_state[EC_STATE_STRING_SIZE],
@@ -976,8 +996,14 @@ void ec_fsm_master_state_scan_slave(
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    EC_MASTER_INFO(master, "Bus scanning completed in %lu ms.\n",
+            (jiffies - fsm->scan_jiffies) * 1000 / NSEC_PER_SEC);
+#else
     EC_MASTER_INFO(master, "Bus scanning completed in %lu ms.\n",
             (jiffies - fsm->scan_jiffies) * 1000 / HZ);
+#endif
 
     master->scan_busy = 0;
     master->scan_index = master->slave_count;
@@ -1100,7 +1126,11 @@ u64 ec_fsm_master_dc_offset32(
     old_offset32 = (u32) old_offset;
 
     // correct read system time by elapsed time since read operation
+#ifdef EC_USERMODE
+    correction = jiffies_since_read * 1000 / NSEC_PER_SEC * 1000000;
+#else
     correction = jiffies_since_read * 1000 / HZ * 1000000;
+#endif
     system_time32 += correction;
     time_diff = (u32) slave->master->app_time - system_time32;
 
@@ -1139,7 +1169,11 @@ u64 ec_fsm_master_dc_offset64(
     s64 time_diff;
 
     // correct read system time by elapsed time since read operation
+#ifdef EC_USERMODE
+    correction = jiffies_since_read * 1000 / NSEC_PER_SEC * 1000000;
+#else
     correction = (u64) (jiffies_since_read * 1000 / HZ) * 1000000;
+#endif
     system_time += correction;
     time_diff = fsm->slave->master->app_time - system_time;
 
@@ -1195,6 +1229,9 @@ void ec_fsm_master_state_dc_read_offset(
 
     system_time = EC_READ_U64(datagram->data);     // 0x0910
     old_offset = EC_READ_U64(datagram->data + 16); // 0x0920
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     jiffies_since_read = jiffies - datagram->jiffies_sent;
 
     if (slave->base_dc_range == EC_DC_32) {
diff --git a/master/fsm_pdo.c b/master/fsm_pdo.c
index 0d5f87e1..d208ef15 100644
--- a/master/fsm_pdo.c
+++ b/master/fsm_pdo.c
@@ -29,7 +29,9 @@
 #include "master.h"
 #include "mailbox.h"
 #include "slave_config.h"
-
+#ifdef EC_USERMODE
+#include "mm.h"
+#endif
 #include "fsm_pdo.h"
 
 /****************************************************************************/
@@ -105,11 +107,11 @@ void ec_fsm_pdo_print(
         const ec_fsm_pdo_t *fsm /**< PDO configuration state machine. */
         )
 {
-    printk(KERN_CONT "Currently assigned PDOs: ");
+    ec_print(KERN_CONT "Currently assigned PDOs: ");
     ec_pdo_list_print(&fsm->sync->pdos);
-    printk(KERN_CONT ". PDOs to assign: ");
+    ec_print(KERN_CONT ". PDOs to assign: ");
     ec_pdo_list_print(&fsm->pdos);
-    printk(KERN_CONT "\n");
+    ec_print(KERN_CONT "\n");
 }
 
 /****************************************************************************/
@@ -329,8 +331,13 @@ void ec_fsm_pdo_read_state_pdo(
         return;
     }
 
+#ifdef EC_USERMODE
+    if (!(fsm->pdo = (ec_pdo_t *)
+                malloc(sizeof(ec_pdo_t)))) {
+#else
     if (!(fsm->pdo = (ec_pdo_t *)
                 kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+#endif
         EC_SLAVE_ERR(fsm->slave, "Failed to allocate PDO.\n");
         ec_fsm_pdo_read_action_next_sync(fsm, datagram);
         return;
@@ -544,11 +551,11 @@ void ec_fsm_pdo_conf_action_check_mapping(
         EC_SLAVE_WARN(fsm->slave, "Slave does not support"
                 " changing the PDO mapping!\n");
         EC_SLAVE_WARN(fsm->slave, "");
-        printk(KERN_CONT "Currently mapped PDO entries: ");
+        ec_print(EC_CONT "Currently mapped PDO entries: ");
         ec_pdo_print_entries(&fsm->slave_pdo);
-        printk(KERN_CONT ". Entries to map: ");
+        ec_print(EC_CONT ". Entries to map: ");
         ec_pdo_print_entries(fsm->pdo);
-        printk(KERN_CONT "\n");
+        ec_print(EC_CONT "\n");
     }
 
     ec_fsm_pdo_conf_action_next_pdo_mapping(fsm, datagram);
diff --git a/master/fsm_pdo_entry.c b/master/fsm_pdo_entry.c
index 3c7be428..aa183fe2 100644
--- a/master/fsm_pdo_entry.c
+++ b/master/fsm_pdo_entry.c
@@ -30,6 +30,9 @@
 #include "mailbox.h"
 #include "slave_config.h"
 
+#ifdef EC_USERMODE
+#include "mm.h"
+#endif
 #include "fsm_pdo_entry.h"
 
 /****************************************************************************/
@@ -93,11 +96,11 @@ void ec_fsm_pdo_entry_print(
         const ec_fsm_pdo_entry_t *fsm /**< PDO mapping state machine. */
         )
 {
-    printk(KERN_CONT "Currently mapped PDO entries: ");
+    ec_print(KERN_CONT "Currently mapped PDO entries: ");
     ec_pdo_print_entries(fsm->cur_pdo);
-    printk(KERN_CONT ". Entries to map: ");
+    ec_print(KERN_CONT ". Entries to map: ");
     ec_pdo_print_entries(fsm->source_pdo);
-    printk(KERN_CONT "\n");
+    ec_print(KERN_CONT "\n");
 }
 
 /****************************************************************************/
@@ -297,7 +300,11 @@ void ec_fsm_pdo_entry_read_state_entry(
         pdo_entry_info = EC_READ_U32(fsm->request.data);
 
         if (!(pdo_entry = (ec_pdo_entry_t *)
+#ifdef EC_USERMODE
+                    malloc(sizeof(ec_pdo_entry_t)))) {
+#else
                     kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(fsm->slave, "Failed to allocate PDO entry.\n");
             fsm->state = ec_fsm_pdo_entry_state_error;
             return;
@@ -311,7 +318,11 @@ void ec_fsm_pdo_entry_read_state_entry(
         if (!pdo_entry->index && !pdo_entry->subindex) {
             if (ec_pdo_entry_set_name(pdo_entry, "Gap")) {
                 ec_pdo_entry_clear(pdo_entry);
+#ifdef EC_USERMODE
+                free(pdo_entry);
+#else
                 kfree(pdo_entry);
+#endif
                 fsm->state = ec_fsm_pdo_entry_state_error;
                 return;
             }
diff --git a/master/fsm_sii.c b/master/fsm_sii.c
index 7e595491..a6220b4e 100644
--- a/master/fsm_sii.c
+++ b/master/fsm_sii.c
@@ -280,8 +280,13 @@ void ec_fsm_sii_state_read_fetch(
     if (EC_READ_U8(datagram->data + 1) & 0x81) { /* busy bit or
                                                     read operation busy */
         // still busy... timeout?
+#ifdef EC_USERMODE
+        unsigned long diff_ms =
+            (datagram->jiffies_received - fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
         unsigned long diff_ms =
             (datagram->jiffies_received - fsm->jiffies_start) * 1000 / HZ;
+#endif
         if (diff_ms >= SII_TIMEOUT) {
             if (fsm->check_once_more) {
                 fsm->check_once_more = 0;
@@ -417,7 +422,11 @@ void ec_fsm_sii_state_write_check2(
 
     /* FIXME: some slaves never answer with the busy flag set...
      * wait a few ms for the write operation to complete. */
+#ifdef EC_USERMODE
+    diff_ms = (datagram->jiffies_received - fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
     diff_ms = (datagram->jiffies_received - fsm->jiffies_start) * 1000 / HZ;
+#endif
     if (diff_ms < SII_INHIBIT) {
 #ifdef SII_DEBUG
         EC_SLAVE_DBG(fsm->slave, 0, "too early.\n");
diff --git a/master/fsm_slave.c b/master/fsm_slave.c
index 6e1f9c36..f3cc0d85 100644
--- a/master/fsm_slave.c
+++ b/master/fsm_slave.c
@@ -26,6 +26,12 @@
 /****************************************************************************/
 
 #include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#include "wq.h"
+#endif
+
 #include "master.h"
 #include "mailbox.h"
 #include "slave_config.h"
diff --git a/master/fsm_slave_config.c b/master/fsm_slave_config.c
index 25887ad6..81cf4690 100644
--- a/master/fsm_slave_config.c
+++ b/master/fsm_slave_config.c
@@ -23,11 +23,15 @@
  * EtherCAT slave configuration state machine.
  */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
+#ifndef EC_USERMODE
 #include <asm/div64.h>
+#else
+#include <stdbool.h>
+#endif
 
-#include "globals.h"
 #include "master.h"
 #include "mailbox.h"
 #include "slave_config.h"
@@ -589,15 +593,24 @@ void ec_fsm_slave_config_state_mbox_sync(
     if (datagram->working_counter == 0) {
         unsigned long diff = datagram->jiffies_received - fsm->jiffies_start;
 
+#ifdef EC_USERMODE
+        if (diff >= NSEC_PER_SEC) {
+#else
         if (diff >= HZ) {
+#endif
             slave->error_flag = 1;
             fsm->state = ec_fsm_slave_config_state_error;
             EC_SLAVE_ERR(slave, "Timeout while configuring"
                     " mailbox sync managers.\n");
             return;
         } else {
+#ifdef EC_USERMODE
+            EC_SLAVE_DBG(slave, 1, "Resending after %u ms...\n",
+                    (unsigned int) diff * 1000 / NSEC_PER_SEC);
+#else
             EC_SLAVE_DBG(slave, 1, "Resending after %u ms...\n",
                     (unsigned int) diff * 1000 / HZ);
+#endif
         }
 
         // send configuration datagram again
@@ -1424,6 +1437,9 @@ void ec_fsm_slave_config_state_dc_cycle(
 
     EC_SLAVE_DBG(slave, 1, "Checking for synchrony.\n");
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->jiffies_start = jiffies;
     ec_datagram_fprd(datagram, slave->station_address, 0x092c, 4);
     fsm->retries = EC_FSM_RETRIES;
@@ -1472,7 +1488,11 @@ void ec_fsm_slave_config_state_dc_sync_check(
     }
 
     abs_sync_diff = EC_READ_U32(datagram->data) & 0x7fffffff;
+#ifdef EC_USERMODE
+    diff_ms = (datagram->jiffies_received - fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
     diff_ms = (datagram->jiffies_received - fsm->jiffies_start) * 1000 / HZ;
+#endif
 
     if (abs_sync_diff > EC_DC_MAX_SYNC_DIFF_NS) {
 
@@ -1504,7 +1524,11 @@ void ec_fsm_slave_config_state_dc_sync_check(
 
             diff = start_time - master->dc_ref_time;
             cycle = sync0->cycle_time + sync1->cycle_time;
+#ifdef EC_USERMODE
+            remainder = diff%cycle;
+#else
             remainder = do_div(diff, cycle);
+#endif
 
             start = start_time + cycle - remainder + sync0->shift_time;
 
@@ -1637,6 +1661,9 @@ void ec_fsm_slave_config_enter_wait_safeop(
         ec_datagram_fprd(fsm->datagram, fsm->slave->station_address,
                 0x0600, 1);
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
         fsm->jiffies_start = jiffies;
     }
     else {
@@ -1652,9 +1679,16 @@ void ec_fsm_slave_config_state_wait_safeop(
         ec_fsm_slave_config_t *fsm /**< slave state machine */
         )
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     unsigned long diff = jiffies - fsm->jiffies_start;
 
+#ifdef EC_USERMODE
+    if (diff * 1000 / NSEC_PER_SEC < fsm->wait_ms) {
+#else
     if (diff * 1000 / HZ < fsm->wait_ms) {
+#endif
         return;
     }
 
diff --git a/master/fsm_slave_scan.c b/master/fsm_slave_scan.c
index e4b56358..8fe265c2 100644
--- a/master/fsm_slave_scan.c
+++ b/master/fsm_slave_scan.c
@@ -31,6 +31,9 @@
 #include "mailbox.h"
 #include "slave_config.h"
 
+#ifdef EC_USERMODE
+#include "mm.h"
+#endif
 #include "fsm_slave_scan.h"
 
 /****************************************************************************/
@@ -626,11 +629,19 @@ void ec_fsm_slave_scan_state_sii_size(
 alloc_sii:
     if (slave->sii_words) {
         EC_SLAVE_WARN(slave, "Freeing old SII data...\n");
+#ifdef EC_USERMODE
+        free(slave->sii_words);
+#else
         kfree(slave->sii_words);
+#endif
     }
 
     if (!(slave->sii_words =
+#ifdef EC_USERMODE
+                (uint16_t *) malloc(slave->sii_nwords * 2))) {
+#else
                 (uint16_t *) kmalloc(slave->sii_nwords * 2, GFP_KERNEL))) {
+#endif
         EC_SLAVE_ERR(slave, "Failed to allocate %zu words of SII data.\n",
                slave->sii_nwords);
         slave->sii_nwords = 0;
@@ -727,38 +738,38 @@ void ec_fsm_slave_scan_state_sii_data(ec_fsm_slave_scan_t *fsm
                 slave->master->debug_level >= 1) {
             EC_SLAVE_DBG(slave, 1, "Slave announces to support ");
             if (slave->sii.mailbox_protocols & EC_MBOX_AOE) {
-                printk(KERN_CONT "AoE");
+                ec_print(EC_CONT "AoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_COE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    ec_print(EC_CONT ", ");
                 }
-                printk(KERN_CONT "CoE");
+                ec_print(EC_CONT "CoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_FOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    ec_print(EC_CONT ", ");
                 }
-                printk(KERN_CONT "FoE");
+                ec_print(EC_CONT "FoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_SOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    ec_print(EC_CONT ", ");
                 }
-                printk(KERN_CONT "SoE");
+                ec_print(EC_CONT "SoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_VOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    ec_print(EC_CONT ", ");
                 }
-                printk(KERN_CONT "VoE");
+                ec_print(EC_CONT "VoE");
                 need_delim = 1;
             }
-            printk(KERN_CONT ".\n");
+            ec_print(EC_CONT ".\n");
         }
         if (slave->sii.mailbox_protocols & ~all) {
             EC_SLAVE_DBG(slave, 1, "Slave announces to support unknown"
diff --git a/master/fsm_soe.c b/master/fsm_soe.c
index b24f03a9..7725f2b1 100644
--- a/master/fsm_soe.c
+++ b/master/fsm_soe.c
@@ -200,12 +200,12 @@ void ec_fsm_soe_print_error(ec_fsm_soe_t *fsm /**< Finite state machine */)
     EC_SLAVE_ERR(fsm->slave, "");
 
     if (request->dir == EC_DIR_OUTPUT) {
-        printk(KERN_CONT "Writing");
+        ec_print(EC_CONT "Writing");
     } else {
-        printk(KERN_CONT "Reading");
+        ec_print(EC_CONT "Reading");
     }
 
-    printk(KERN_CONT " IDN 0x%04X failed.\n", request->idn);
+    ec_print(EC_CONT " IDN 0x%04X failed.\n", request->idn);
 }
 
 /*****************************************************************************
@@ -241,6 +241,9 @@ int ec_fsm_soe_prepare_read(
         ec_print_data(data, EC_SOE_SIZE);
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->request->jiffies_sent = jiffies;
     fsm->state = ec_fsm_soe_read_request;
 
@@ -306,7 +309,12 @@ void ec_fsm_soe_read_request(
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    diff_ms = (jiffies - fsm->request->jiffies_sent) / 1000000;
+#else
     diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+#endif
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -367,9 +375,16 @@ void ec_fsm_soe_read_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+
+#ifdef EC_USERMODE
+        diff_ms = (fsm->datagram->jiffies_received - fsm->jiffies_start) *
+        1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (fsm->datagram->jiffies_received - fsm->jiffies_start) *
             1000 / HZ;
+#endif
         if (diff_ms >= EC_SOE_RESPONSE_TIMEOUT) {
             fsm->state = ec_fsm_soe_error;
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting for"
@@ -592,6 +607,9 @@ void ec_fsm_soe_write_start(
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     fsm->offset = 0;
     fsm->retries = EC_FSM_RETRIES;
     ec_fsm_soe_write_next_fragment(fsm, datagram);
@@ -623,7 +641,12 @@ void ec_fsm_soe_write_request(
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    diff_ms = (jiffies - fsm->request->jiffies_sent) / 1000000;
+#else
     diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+#endif
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -691,8 +714,14 @@ void ec_fsm_soe_write_check(
     }
 
     if (!ec_slave_mbox_check(fsm->datagram)) {
-        unsigned long diff_ms =
+        unsigned long diff_ms = 0;
+
+#ifdef EC_USERMODE
+        diff_ms = (datagram->jiffies_received - fsm->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
+        diff_ms =
             (datagram->jiffies_received - fsm->jiffies_start) * 1000 / HZ;
+#endif
         if (diff_ms >= EC_SOE_RESPONSE_TIMEOUT) {
             fsm->state = ec_fsm_soe_error;
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting"
diff --git a/master/globals.h b/master/globals.h
index da738e8b..735a4433 100644
--- a/master/globals.h
+++ b/master/globals.h
@@ -75,6 +75,31 @@
 /** Size of the EtherCAT address field. */
 #define EC_ADDR_LEN 4
 
+#ifdef EC_USERMODE
+#ifndef ETH_HLEN
+#define ETH_HLEN 14
+#endif
+#ifndef ETH_DATA_LEN
+#define ETH_DATA_LEN 1500
+#endif
+
+#ifndef ETH_FRAME_LEN
+#define ETH_FRAME_LEN 1514
+#endif
+
+#ifndef ETH_ZLEN
+#define ETH_ZLEN 60
+#endif
+
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN 4
+#endif
+struct ethhdr {
+	unsigned char h_dest[ETH_ALEN];
+	unsigned char h_source[ETH_ALEN];
+	unsigned short h_proto;
+} __attribute__((packed));
+#endif
 /** Resulting maximum data size of a single datagram in a frame. */
 #define EC_MAX_DATA_SIZE (ETH_DATA_LEN - EC_FRAME_HEADER_SIZE \
                           - EC_DATAGRAM_HEADER_SIZE - EC_DATAGRAM_FOOTER_SIZE)
@@ -202,7 +227,26 @@ typedef enum {
 
 extern const char *ec_device_names[2]; // only main and backup!
 
-/****************************************************************************/
+/** Macro for print syslog
+ *
+ * */
+#ifdef EC_USERMODE
+#define EC_INFO_LEVEL
+#define EC_ERR_LEVEL
+#define EC_WARNING_LEVEL
+#define EC_DEBUG_LEVEL
+#define ec_print printf
+#define EC_CONT
+#else
+#define EC_INFO_LEVEL		KERN_INFO
+#define EC_ERR_LEVEL		KERN_ERR
+#define EC_WARNING_LEVEL	KERN_WARNING
+#define EC_DEBUG_LEVEL		KERN_DEBUG
+#define EC_CONT KERN_CONT
+#define ec_print printk
+#endif
+
+/*****************************************************************************/
 
 /** Convenience macro for printing EtherCAT-specific information to syslog.
  *
@@ -212,7 +256,7 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param args arguments (optional)
  */
 #define EC_INFO(fmt, args...) \
-    printk(KERN_INFO "EtherCAT: " fmt, ##args)
+    ec_print(EC_INFO_LEVEL "EtherCAT: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT-specific errors to syslog.
  *
@@ -222,7 +266,7 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param args arguments (optional)
  */
 #define EC_ERR(fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR: " fmt, ##args)
+    ec_print(EC_ERR_LEVEL "EtherCAT ERROR: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT-specific warnings to syslog.
  *
@@ -232,7 +276,7 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param args arguments (optional)
  */
 #define EC_WARN(fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING: " fmt, ##args)
+    ec_print(EC_WARNING_LEVEL "EtherCAT WARNING: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT debug messages to syslog.
  *
@@ -242,7 +286,7 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param args arguments (optional)
  */
 #define EC_DBG(fmt, args...) \
-    printk(KERN_DEBUG "EtherCAT DEBUG: " fmt, ##args)
+    ec_print(EC_DEBUG_LEVEL "EtherCAT DEBUG: " fmt, ##args)
 
 /****************************************************************************/
 
@@ -260,7 +304,11 @@ unsigned int ec_master_count(void);
 void ec_print_data(const uint8_t *, size_t);
 void ec_print_data_diff(const uint8_t *, const uint8_t *, size_t);
 size_t ec_state_string(uint8_t, char *, uint8_t);
+#ifdef EC_USERMODE
+size_t ec_mac_print(const uint8_t *, char *);
+#else
 ssize_t ec_mac_print(const uint8_t *, char *);
+#endif
 int ec_mac_is_zero(const uint8_t *);
 
 ec_master_t *ecrt_request_master_err(unsigned int);
diff --git a/master/ioctl.c b/master/ioctl.c
index 9a0e5c1b..58b86668 100644
--- a/master/ioctl.c
+++ b/master/ioctl.c
@@ -23,11 +23,20 @@
    EtherCAT master character device.
 */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/vmalloc.h>
+#include <linux/rtmutex.h>
+#else
+#include "wq.h"
+#include "../ipc/ecat_ipc.h"
+#include "sdo_request.h"
+#endif
 
+#include "rt_locks.h"
 #include "master.h"
 #include "slave_config.h"
 #include "voe_handler.h"
@@ -55,10 +64,32 @@
 # define ec_ioctl_lock(lock) do {} while(0)
 # define ec_ioctl_unlock(lock) do {} while(0)
 # define ec_ioctl_lock_interruptible(lock) (0)
+#ifdef EC_USERMODE
+# define ec_copy_to_user(to, from, n, ctx) \
+    memcpy(to, from, n)
+# define ec_copy_from_user(to, from, n, ctx) \
+    rtdm_safe_copy_from_user(ec_ioctl_to_rtdm(ctx), to, from, n)
+#else
 # define ec_copy_to_user(to, from, n, ctx) \
     rtdm_safe_copy_to_user(ec_ioctl_to_rtdm(ctx), to, from, n)
 # define ec_copy_from_user(to, from, n, ctx) \
     rtdm_safe_copy_from_user(ec_ioctl_to_rtdm(ctx), to, from, n)
+#endif
+#else
+#ifdef EC_USERMODE
+# define ec_ioctl_lock(lock)   ec_lock_down(lock)
+# define ec_ioctl_unlock(lock) ec_lock_up(lock)
+# define ec_ioctl_lock_interruptible(lock) \
+         ec_lock_down_interruptible(lock)
+static int ec_copy_to_user(void *to, const void *from, size_t n, void *ctx) {
+    memcpy(to, from, n);
+    return 0;
+}
+
+static int ec_copy_from_user(void *to, const void *from, size_t n, void *ctx) {
+    memcpy(to, from, n);
+    return 0;
+}
 #else
 # define ec_ioctl_lock(lock)   rt_mutex_lock(lock)
 # define ec_ioctl_unlock(lock) rt_mutex_unlock(lock)
@@ -72,6 +103,7 @@
 # endif
 # define ec_copy_to_user(to, from, n, ctx) copy_to_user(to, from, n)
 # define ec_copy_from_user(to, from, n, ctx) copy_from_user(to, from, n)
+#endif
 #endif  // EC_IOCTL_RTDM
 
 /****************************************************************************/
@@ -106,7 +138,6 @@ static ATTRIBUTES int ec_ioctl_module(
 
     data.ioctl_version_magic = EC_IOCTL_VERSION_MAGIC;
     data.master_count = ec_master_count();
-
     if (ec_copy_to_user((void __user *) arg, &data, sizeof(data), ctx))
         return -EFAULT;
 
@@ -127,7 +158,7 @@ static ATTRIBUTES int ec_ioctl_master(
     ec_ioctl_master_t io;
     unsigned int dev_idx, j;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
@@ -144,9 +175,9 @@ static ATTRIBUTES int ec_ioctl_master(
     io.active = (uint8_t) master->active;
     io.scan_busy = master->scan_busy;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
-    if (down_interruptible(&master->device_sem)) {
+    if (ec_lock_down_interruptible(&master->device_sem)) {
         return -EINTR;
     }
 
@@ -155,8 +186,13 @@ static ATTRIBUTES int ec_ioctl_master(
         ec_device_t *device = &master->devices[dev_idx];
 
         if (device->dev) {
+#ifdef EC_USERMODE
+            memcpy(io.devices[dev_idx].address, device->dev->mac,
+                    ETH_ALEN);
+#else
             memcpy(io.devices[dev_idx].address, device->dev->dev_addr,
                     ETH_ALEN);
+#endif
         } else {
             memcpy(io.devices[dev_idx].address, master->macs[dev_idx],
                     ETH_ALEN);
@@ -178,6 +214,39 @@ static ATTRIBUTES int ec_ioctl_master(
             io.devices[dev_idx].rx_byte_rates[j] =
                 device->rx_byte_rates[j];
         }
+#ifdef EC_BENCHMARK
+        unsigned int i;
+        if (device->tx_cnt) {
+            for (i = 0; i < NUM_TX_LATENCY; i++) {
+                io.devices[dev_idx].tx_latency[i][0] = device->tx_latency[i][0];
+                io.devices[dev_idx].tx_latency[i][1] = device->tx_latency[i][1];
+                io.devices[dev_idx].tx_latency[i][2] = device->tx_latency[i][2] / device->tx_cnt;
+            }
+        }
+        else {
+            for (i = 0; i < NUM_TX_LATENCY; i++) {
+                io.devices[dev_idx].tx_latency[i][0] = 0;
+                io.devices[dev_idx].tx_latency[i][1] = 0;
+                io.devices[dev_idx].tx_latency[i][2] = 0;
+            }
+        }
+        if (device->rx_cnt) {
+            for (i = 0; i < NUM_RX_LATENCY; i++) {
+                io.devices[dev_idx].rx_latency[i][0] = device->rx_latency[i][0];
+                io.devices[dev_idx].rx_latency[i][1] = device->rx_latency[i][1];
+                io.devices[dev_idx].rx_latency[i][2] = device->rx_latency[i][2] / device->rx_cnt;
+            }
+        }
+        else {
+            for (i = 0; i < NUM_RX_LATENCY; i++) {
+                io.devices[dev_idx].rx_latency[i][0] = 0;
+                io.devices[dev_idx].rx_latency[i][1] = 0;
+                io.devices[dev_idx].rx_latency[i][2] = 0;
+            }
+        }
+#endif
+
+
     }
     io.num_devices = ec_master_num_devices(master);
 
@@ -198,17 +267,20 @@ static ATTRIBUTES int ec_ioctl_master(
             master->device_stats.loss_rates[j];
     }
 
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 
     io.app_time = master->app_time;
     io.dc_ref_time = master->dc_ref_time;
     io.ref_clock =
         master->dc_ref_clock ? master->dc_ref_clock->ring_position : 0xffff;
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (copy_to_user((void __user *) arg, &io, sizeof(io))) {
         return -EFAULT;
     }
-
+#endif
     return 0;
 }
 
@@ -227,16 +299,20 @@ static ATTRIBUTES int ec_ioctl_slave(
     const ec_slave_t *slave;
     int i;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", data.position);
         return -EINVAL;
     }
@@ -291,11 +367,14 @@ static ATTRIBUTES int ec_ioctl_slave(
     ec_ioctl_strcpy(data.order, slave->sii.order);
     ec_ioctl_strcpy(data.name, slave->sii.name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -314,23 +393,27 @@ static ATTRIBUTES int ec_ioctl_slave_sync(
     const ec_slave_t *slave;
     const ec_sync_t *sync;
 
+#ifdef EC_USERMODE
+    memcpy(&data, (void __user *) arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -344,11 +427,14 @@ static ATTRIBUTES int ec_ioctl_slave_sync(
     data.enable = sync->enable;
     data.pdo_count = ec_pdo_list_count(&sync->pdos);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -367,24 +453,27 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo(
     const ec_slave_t *slave;
     const ec_sync_t *sync;
     const ec_pdo_t *pdo;
-
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -393,7 +482,7 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo(
     sync = &slave->sii.syncs[data.sync_index];
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sync->pdos, data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
                 "position %u!\n", data.sync_index, data.pdo_pos);
         return -EINVAL;
@@ -403,10 +492,14 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo(
     data.entry_count = ec_pdo_entry_count(pdo);
     ec_ioctl_strcpy(data.name, pdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
+#endif
 
     return 0;
 }
@@ -428,23 +521,27 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo_entry(
     const ec_pdo_t *pdo;
     const ec_pdo_entry_t *entry;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -453,7 +550,7 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo_entry(
     sync = &slave->sii.syncs[data.sync_index];
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sync->pdos, data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
                 "position %u!\n", data.sync_index, data.pdo_pos);
         return -EINVAL;
@@ -461,7 +558,7 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo_entry(
 
     if (!(entry = ec_pdo_find_entry_by_pos_const(
                     pdo, data.entry_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "PDO 0x%04X does not contain an entry with "
                 "position %u!\n", data.pdo_pos, data.entry_pos);
         return -EINVAL;
@@ -472,11 +569,14 @@ static ATTRIBUTES int ec_ioctl_slave_sync_pdo_entry(
     data.bit_length = entry->bit_length;
     ec_ioctl_strcpy(data.name, entry->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -495,15 +595,19 @@ static ATTRIBUTES int ec_ioctl_domain(
     const ec_domain_t *domain;
     unsigned int dev_idx;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n", data.index);
         return -EINVAL;
     }
@@ -517,11 +621,14 @@ static ATTRIBUTES int ec_ioctl_domain(
     data.expected_working_counter = domain->expected_working_counter;
     data.fmmu_count = ec_domain_fmmu_count(domain);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -540,22 +647,26 @@ static ATTRIBUTES int ec_ioctl_domain_fmmu(
     const ec_domain_t *domain;
     const ec_fmmu_config_t *fmmu;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n",
                 data.domain_index);
         return -EINVAL;
     }
 
     if (!(fmmu = ec_domain_find_fmmu(domain, data.fmmu_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u has less than %u"
                 " fmmu configurations.\n",
                 data.domain_index, data.fmmu_index + 1);
@@ -569,11 +680,14 @@ static ATTRIBUTES int ec_ioctl_domain_fmmu(
     data.logical_address = fmmu->logical_start_address;
     data.data_size = fmmu->data_size;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -591,34 +705,42 @@ static ATTRIBUTES int ec_ioctl_domain_data(
     ec_ioctl_domain_data_t data;
     const ec_domain_t *domain;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.target = arg + sizeof(ec_ioctl_domain_data_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n",
                 data.domain_index);
         return -EINVAL;
     }
 
     if (domain->data_size != data.data_size) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Data size mismatch %u/%zu!\n",
                 data.data_size, domain->data_size);
         return -EFAULT;
     }
 
+#ifdef EC_USERMODE
+    memcpy(data.target, domain->data, domain->data_size);
+#else
     if (copy_to_user((void __user *) data.target, domain->data,
                 domain->data_size)) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -EFAULT;
     }
-
-    up(&master->master_sem);
+#endif
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -665,16 +787,20 @@ static ATTRIBUTES int ec_ioctl_slave_state(
     ec_ioctl_slave_state_t data;
     ec_slave_t *slave;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -682,7 +808,7 @@ static ATTRIBUTES int ec_ioctl_slave_state(
 
     ec_slave_request_state(slave, data.al_state);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -701,16 +827,20 @@ static ATTRIBUTES int ec_ioctl_slave_sdo(
     const ec_slave_t *slave;
     const ec_sdo_t *sdo;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -718,7 +848,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo(
 
     if (!(sdo = ec_slave_get_sdo_by_pos_const(
                     slave, data.sdo_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "SDO %u does not exist!\n", data.sdo_position);
         return -EINVAL;
     }
@@ -727,11 +857,14 @@ static ATTRIBUTES int ec_ioctl_slave_sdo(
     data.max_subindex = sdo->max_subindex;
     ec_ioctl_strcpy(data.name, sdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -751,16 +884,20 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_entry(
     const ec_sdo_t *sdo;
     const ec_sdo_entry_t *entry;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -769,14 +906,14 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_entry(
     if (data.sdo_spec <= 0) {
         if (!(sdo = ec_slave_get_sdo_by_pos_const(
                         slave, -data.sdo_spec))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_SLAVE_ERR(slave, "SDO %u does not exist!\n", -data.sdo_spec);
             return -EINVAL;
         }
     } else {
         if (!(sdo = ec_slave_get_sdo_const(
                         slave, data.sdo_spec))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_SLAVE_ERR(slave, "SDO 0x%04X does not exist!\n",
                     data.sdo_spec);
             return -EINVAL;
@@ -785,7 +922,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_entry(
 
     if (!(entry = ec_sdo_get_entry_const(
                     sdo, data.sdo_entry_subindex))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "SDO entry 0x%04X:%02X does not exist!\n",
                 sdo->index, data.sdo_entry_subindex);
         return -EINVAL;
@@ -807,11 +944,14 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_entry(
         entry->write_access[EC_SDO_ENTRY_ACCESS_OP];
     ec_ioctl_strcpy(data.description, entry->description);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -830,11 +970,20 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_upload(
     uint8_t *target;
     int ret;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.target = arg + sizeof(ec_ioctl_slave_sdo_upload_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    if (!(target = malloc(data.target_size))) {
+#else
     if (!(target = kmalloc(data.target_size, GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO upload.\n", data.target_size);
         return -ENOMEM;
@@ -845,19 +994,29 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_upload(
             data.target_size, &data.data_size, &data.abort_code);
 
     if (!ret) {
+#ifdef EC_USERMODE
+        memcpy(data.target, target, data.data_size);
+#else
         if (copy_to_user((void __user *) data.target,
                     target, data.data_size)) {
             kfree(target);
             return -EFAULT;
         }
+#endif
     }
-
+#ifdef EC_USERMODE
+    free(target);
+#else
     kfree(target);
+#endif
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (__copy_to_user((void __user *) arg, &data, sizeof(data))) {
         return -EFAULT;
     }
-
+#endif
     return ret;
 }
 
@@ -876,20 +1035,32 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_download(
     uint8_t *sdo_data;
     int retval;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.data = arg + sizeof(ec_ioctl_slave_sdo_download_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
-
+#endif
+#ifdef EC_USERMODE
+    if (!(sdo_data = malloc(data.data_size))) {
+#else
     if (!(sdo_data = kmalloc(data.data_size, GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO download.\n", data.data_size);
         return -ENOMEM;
     }
 
-    if (copy_from_user(sdo_data, (void __user *) data.data, data.data_size)) {
+#ifdef EC_USERMODE
+    memcpy(sdo_data, data.data, data.data_size);
+#else
+    if (copy_from_user(sdo_data, (const void __user *) data.data, data.data_size)) {
         kfree(sdo_data);
         return -EFAULT;
     }
+#endif
 
     if (data.complete_access) {
         retval = ecrt_master_sdo_download_complete(master, data.slave_position,
@@ -900,12 +1071,19 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_download(
                 data.data_size, &data.abort_code);
     }
 
+#ifdef EC_USERMODE
+    free(sdo_data);
+#else
     kfree(sdo_data);
+#endif
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (__copy_to_user((void __user *) arg, &data, sizeof(data))) {
         retval = -EFAULT;
     }
-
+#endif
     return retval;
 }
 
@@ -924,16 +1102,20 @@ static ATTRIBUTES int ec_ioctl_slave_sii_read(
     const ec_slave_t *slave;
     int retval;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.words = arg + sizeof(ec_ioctl_slave_sii_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -941,19 +1123,23 @@ static ATTRIBUTES int ec_ioctl_slave_sii_read(
 
     if (!data.nwords
             || data.offset + data.nwords > slave->sii_nwords) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Invalid SII read offset/size %u/%u for slave SII"
                 " size %zu!\n", data.offset, data.nwords, slave->sii_nwords);
         return -EINVAL;
     }
 
+#ifdef EC_USERMODE
+    memcpy(data.words, slave->sii_words + data.offset, data.nwords * 2);
+#else
     if (copy_to_user((void __user *) data.words,
                 slave->sii_words + data.offset, data.nwords * 2))
         retval = -EFAULT;
     else
+#endif
         retval = 0;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return retval;
 }
 
@@ -974,38 +1160,59 @@ static ATTRIBUTES int ec_ioctl_slave_sii_write(
     uint16_t *words;
     ec_sii_write_request_t request;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.words = arg + sizeof(ec_ioctl_slave_sii_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     if (!data.nwords) {
         return 0;
     }
 
     byte_size = sizeof(uint16_t) * data.nwords;
+#ifdef EC_USERMODE
+    if (!(words = malloc(byte_size))) {
+#else
     if (!(words = kmalloc(byte_size, GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(master, "Failed to allocate %u bytes"
                 " for SII contents.\n", byte_size);
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(words, data.words, byte_size);
+#else
     if (copy_from_user(words,
                 (void __user *) data.words, byte_size)) {
         kfree(words);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(words);
+#else
         kfree(words);
+#endif
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
+#ifdef EC_USERMODE
+        free(words);
+#else
         kfree(words);
+#endif
         return -EINVAL;
     }
 
@@ -1020,27 +1227,44 @@ static ATTRIBUTES int ec_ioctl_slave_sii_write(
     // schedule SII write request.
     list_add_tail(&request.list, &master->sii_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
+#ifdef EC_USERMODE
+            free(words);
+#else
             kfree(words);
+#endif
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
+#ifdef EC_USERMODE
+    free(words);
+#else
     kfree(words);
+#endif
 
     return request.state == EC_INT_REQUEST_SUCCESS ? 0 : -EIO;
 }
@@ -1061,9 +1285,14 @@ static ATTRIBUTES int ec_ioctl_slave_reg_read(
     ec_reg_request_t request;
     int ret;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.data = arg + sizeof(ec_ioctl_slave_reg_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     if (!io.size) {
         return 0;
@@ -1080,14 +1309,14 @@ static ATTRIBUTES int ec_ioctl_slave_reg_read(
         return ret;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_reg_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_reg_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
@@ -1097,30 +1326,43 @@ static ATTRIBUTES int ec_ioctl_slave_reg_read(
     // schedule request.
     list_add_tail(&request.list, &slave->reg_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     if (request.state == EC_INT_REQUEST_SUCCESS) {
+#ifdef EC_USERMODE
+        memcpy(io.data, request.data, io.size);
+#else
         if (copy_to_user((void __user *) io.data, request.data, io.size)) {
             return -EFAULT;
         }
+#endif
     }
     ec_reg_request_clear(&request);
 
@@ -1143,10 +1385,14 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
     ec_reg_request_t request;
     int ret;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.data = arg + sizeof(ec_ioctl_slave_reg_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
-
+#endif
     if (!io.size) {
         return 0;
     }
@@ -1157,17 +1403,21 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
         return ret;
     }
 
+#ifdef EC_USERMODE
+    memcpy(request.data, io.data, io.size);
+#else
     if (copy_from_user(request.data, (void __user *) io.data, io.size)) {
         ec_reg_request_clear(&request);
         return -EFAULT;
     }
+#endif
 
     ret = ecrt_reg_request_write(&request, io.address, io.size);
     if (ret) {
         return ret;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_reg_request_clear(&request);
         return -EINTR;
     }
@@ -1179,7 +1429,7 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
     }
     else {
         if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                     io.slave_position);
@@ -1190,25 +1440,34 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
         list_add_tail(&request.list, &slave->reg_requests);
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     ec_reg_request_clear(&request);
 
@@ -1230,16 +1489,19 @@ static ATTRIBUTES int ec_ioctl_config(
     const ec_slave_config_t *sc;
     uint8_t i;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1266,11 +1528,13 @@ static ATTRIBUTES int ec_ioctl_config(
         data.dc_sync[i] = sc->dc_sync[i];
     }
 
-    up(&master->master_sem);
-
+    ec_lock_up(&master->master_sem);
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -1289,9 +1553,13 @@ static ATTRIBUTES int ec_ioctl_config_pdo(
     const ec_slave_config_t *sc;
     const ec_pdo_t *pdo;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     if (data.sync_index >= EC_MAX_SYNC_MANAGERS) {
         EC_MASTER_ERR(master, "Invalid sync manager index %u!\n",
@@ -1299,12 +1567,12 @@ static ATTRIBUTES int ec_ioctl_config_pdo(
         return -EINVAL;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1313,7 +1581,7 @@ static ATTRIBUTES int ec_ioctl_config_pdo(
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sc->sync_configs[data.sync_index].pdos,
                     data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid PDO position!\n");
         return -EINVAL;
     }
@@ -1322,11 +1590,14 @@ static ATTRIBUTES int ec_ioctl_config_pdo(
     data.entry_count = ec_pdo_entry_count(pdo);
     ec_ioctl_strcpy(data.name, pdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -1346,9 +1617,13 @@ static ATTRIBUTES int ec_ioctl_config_pdo_entry(
     const ec_pdo_t *pdo;
     const ec_pdo_entry_t *entry;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     if (data.sync_index >= EC_MAX_SYNC_MANAGERS) {
         EC_MASTER_ERR(master, "Invalid sync manager index %u!\n",
@@ -1356,12 +1631,12 @@ static ATTRIBUTES int ec_ioctl_config_pdo_entry(
         return -EINVAL;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1370,14 +1645,14 @@ static ATTRIBUTES int ec_ioctl_config_pdo_entry(
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sc->sync_configs[data.sync_index].pdos,
                     data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid PDO position!\n");
         return -EINVAL;
     }
 
     if (!(entry = ec_pdo_find_entry_by_pos_const(
                     pdo, data.entry_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Entry not found!\n");
         return -EINVAL;
     }
@@ -1387,11 +1662,14 @@ static ATTRIBUTES int ec_ioctl_config_pdo_entry(
     data.bit_length = entry->bit_length;
     ec_ioctl_strcpy(data.name, entry->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -1410,34 +1688,54 @@ static ATTRIBUTES int ec_ioctl_config_sdo(
     const ec_slave_config_t *sc;
     const ec_sdo_request_t *req;
 
+#ifdef EC_USERMODE
+    if (!(ioctl = malloc(sizeof(*ioctl)))) {
+#else
     if (!(ioctl = kmalloc(sizeof(*ioctl), GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(ioctl, arg, sizeof(*ioctl));
+#else
     if (copy_from_user(ioctl, (void __user *) arg, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config_const(
                     master, ioctl->config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 ioctl->config_index);
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
     if (!(req = ec_slave_config_get_sdo_by_pos_const(
                     sc, ioctl->sdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid SDO position!\n");
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
@@ -1448,14 +1746,22 @@ static ATTRIBUTES int ec_ioctl_config_sdo(
             min((u32) ioctl->size, (u32) EC_MAX_SDO_DATA_SIZE));
     ioctl->complete_access = req->complete_access;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, ioctl, sizeof(*ioctl));
+#else
     if (copy_to_user((void __user *) arg, ioctl, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    free(ioctl);
+#else
     kfree(ioctl);
+#endif
     return 0;
 }
 
@@ -1474,34 +1780,54 @@ static ATTRIBUTES int ec_ioctl_config_idn(
     const ec_slave_config_t *sc;
     const ec_soe_request_t *req;
 
+#ifdef EC_USERMODE
+    if (!(ioctl = malloc(sizeof(*ioctl)))) {
+#else
     if (!(ioctl = kmalloc(sizeof(*ioctl), GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(ioctl, (void __user *) arg, sizeof(*ioctl));
+#else
     if (copy_from_user(ioctl, (void __user *) arg, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config_const(
                     master, ioctl->config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 ioctl->config_index);
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
     if (!(req = ec_slave_config_get_idn_by_pos_const(
                     sc, ioctl->idn_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid IDN position!\n");
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
@@ -1512,14 +1838,22 @@ static ATTRIBUTES int ec_ioctl_config_idn(
     memcpy(ioctl->data, req->data,
             min((u32) ioctl->size, (u32) EC_MAX_IDN_DATA_SIZE));
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, ioctl, sizeof(*ioctl));
+#else
     if (copy_to_user((void __user *) arg, ioctl, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    free(ioctl);
+#else
     kfree(ioctl);
+#endif
     return 0;
 }
 
@@ -1539,34 +1873,54 @@ static ATTRIBUTES int ec_ioctl_config_flag(
     const ec_flag_t *flag;
     size_t size;
 
+#ifdef EC_USERMODE
+    if (!(ioctl = malloc(sizeof(*ioctl)))) {
+#else
     if (!(ioctl = kmalloc(sizeof(*ioctl), GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(ioctl, arg, sizeof(*ioctl));
+#else
     if (copy_from_user(ioctl, (void __user *) arg, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config_const(
                     master, ioctl->config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 ioctl->config_index);
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
     if (!(flag = ec_slave_config_get_flag_by_pos_const(
                     sc, ioctl->flag_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid flag position!\n");
+#ifdef EC_USERMODE
+        free(ioctl);
+#else
         kfree(ioctl);
+#endif
         return -EINVAL;
     }
 
@@ -1575,14 +1929,22 @@ static ATTRIBUTES int ec_ioctl_config_flag(
     ioctl->key[size] = 0x00;
     ioctl->value = flag->value;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, ioctl, sizeof(*ioctl));
+#else
     if (copy_to_user((void __user *) arg, ioctl, sizeof(*ioctl))) {
         kfree(ioctl);
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    free(ioctl);
+#else
     kfree(ioctl);
+#endif
     return 0;
 }
 
@@ -1670,15 +2032,19 @@ static ATTRIBUTES int ec_ioctl_eoe_handler(
     ec_ioctl_eoe_handler_t data;
     const ec_eoe_t *eoe;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(eoe = ec_master_get_eoe_handler_const(master, data.eoe_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "EoE handler %u does not exist!\n",
                 data.eoe_index);
         return -EINVAL;
@@ -1698,11 +2064,14 @@ static ATTRIBUTES int ec_ioctl_eoe_handler(
     data.tx_queued_frames = eoe->tx_queued_frames;
     data.tx_queue_size = eoe->tx_queue_size;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -1724,9 +2093,13 @@ static ATTRIBUTES int ec_ioctl_slave_eoe_ip_param(
     ec_eoe_request_t req;
     ec_slave_t *slave;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     // init EoE request
     ec_eoe_request_init(&req);
@@ -1747,13 +2120,13 @@ static ATTRIBUTES int ec_ioctl_slave_eoe_ip_param(
 
     req.state = EC_INT_REQUEST_QUEUED;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
         return -EINVAL;
@@ -1764,30 +2137,43 @@ static ATTRIBUTES int ec_ioctl_slave_eoe_ip_param(
     // schedule request.
     list_add_tail(&req.list, &slave->eoe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&req.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 req.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (req.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&req.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&req.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, req.state != EC_INT_REQUEST_BUSY);
+#endif
 
     io.result = req.result;
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (copy_to_user((void __user *) arg, &io, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     return req.state == EC_INT_REQUEST_SUCCESS ? 0 : -EIO;
 }
@@ -1860,9 +2246,13 @@ static ATTRIBUTES int ec_ioctl_create_slave_config(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     sc = ecrt_master_slave_config_err(master, data.alias, data.position,
             data.vendor_id, data.product_code);
@@ -1871,7 +2261,7 @@ static ATTRIBUTES int ec_ioctl_create_slave_config(
 
     data.config_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     list_for_each_entry(entry, &master->configs, list) {
@@ -1880,11 +2270,14 @@ static ATTRIBUTES int ec_ioctl_create_slave_config(
         data.config_index++;
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -1909,7 +2302,7 @@ static ATTRIBUTES int ec_ioctl_select_ref_clock(
         goto out_return;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -1924,7 +2317,7 @@ static ATTRIBUTES int ec_ioctl_select_ref_clock(
     ecrt_master_select_reference_clock(master, sc);
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -1955,17 +2348,21 @@ static ATTRIBUTES int ec_ioctl_activate(
 
     ctx->process_data_size = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     list_for_each_entry(domain, &master->domains, list) {
         ctx->process_data_size += ecrt_domain_size(domain);
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (ctx->process_data_size) {
+#ifdef EC_USERMODE
+            ipc_iface_mmap(&ctx->process_data,ctx->process_data_size);
+#else
         ctx->process_data = vmalloc(ctx->process_data_size);
+#endif
         if (!ctx->process_data) {
             ctx->process_data_size = 0;
             return -ENOMEM;
@@ -2005,11 +2402,13 @@ static ATTRIBUTES int ec_ioctl_activate(
     ret = ecrt_master_activate(master);
     if (ret < 0)
         return ret;
-
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(ec_ioctl_master_activate_t));
+#else
     if (copy_to_user((void __user *) arg, &io,
                 sizeof(ec_ioctl_master_activate_t)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -2048,18 +2447,22 @@ static ATTRIBUTES int ec_ioctl_set_send_interval(
     if (unlikely(!ctx->requested)) {
         return -EPERM;
     }
-
+#ifdef EC_USERMODE
+    memcpy(&send_interval, arg,
+                sizeof(send_interval));
+#else
     if (copy_from_user(&send_interval, (void __user *) arg,
                 sizeof(send_interval))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     ec_master_set_send_interval(master, send_interval);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -2189,7 +2592,6 @@ static ATTRIBUTES int ec_ioctl_app_time(
 
     if (unlikely(!ctx->requested))
         return -EPERM;
-
     if (ec_copy_from_user(&time, (void __user *) arg, sizeof(time), ctx)) {
         return -EFAULT;
     }
@@ -2358,7 +2760,6 @@ static ATTRIBUTES int ec_ioctl_sync_mon_process(
     if (ec_copy_to_user((void __user *) arg, &time_diff,
                         sizeof(time_diff), ctx))
         return -EFAULT;
-
     return 0;
 }
 
@@ -2374,11 +2775,13 @@ static ATTRIBUTES int ec_ioctl_reset(
         ec_ioctl_context_t *ctx /**< Private data structure of file handle. */
         )
 {
+#ifndef EC_USERMODE
 #ifdef EC_IOCTL_RTDM
     /* Xenomai/LXRT is like NMI context, so we do a two-stage schedule. */
     irq_work_queue(&master->sc_reset_work_kicker);
 #else
     schedule_work(&master->sc_reset_work);
+#endif
 #endif
     return 0;
 }
@@ -2405,12 +2808,16 @@ static ATTRIBUTES int ec_ioctl_sc_sync(
         goto out_return;
     }
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         ret = -EFAULT;
         goto out_return;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -2431,7 +2838,7 @@ static ATTRIBUTES int ec_ioctl_sc_sync(
     }
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -2457,12 +2864,16 @@ static ATTRIBUTES int ec_ioctl_sc_watchdog(
         goto out_return;
     }
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         ret = -EFAULT;
         goto out_return;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -2476,7 +2887,7 @@ static ATTRIBUTES int ec_ioctl_sc_watchdog(
             data.watchdog_divider, data.watchdog_intervals);
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -2499,18 +2910,21 @@ static ATTRIBUTES int ec_ioctl_sc_add_pdo(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     return ecrt_slave_config_pdo_assign_add(sc, data.sync_index, data.index);
 }
@@ -2533,20 +2947,24 @@ static ATTRIBUTES int ec_ioctl_sc_clear_pdos(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
-    return ecrt_slave_config_pdo_assign_clear(sc, data.sync_index);
+    ecrt_slave_config_pdo_assign_clear(sc, data.sync_index);
+    return 0;
 }
 
 /****************************************************************************/
@@ -2567,18 +2985,21 @@ static ATTRIBUTES int ec_ioctl_sc_add_entry(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     return ecrt_slave_config_pdo_mapping_add(sc, data.pdo_index,
             data.entry_index, data.entry_subindex, data.entry_bit_length);
@@ -2602,18 +3023,21 @@ static ATTRIBUTES int ec_ioctl_sc_clear_entries(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     return ecrt_slave_config_pdo_mapping_clear(sc, data.index);
 }
@@ -2638,30 +3062,36 @@ static ATTRIBUTES int ec_ioctl_sc_reg_pdo_entry(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     if (!(domain = ec_master_find_domain(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc or domain could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc or domain could be invalidated */
 
     ret = ecrt_slave_config_reg_pdo_entry(sc, data.entry_index,
             data.entry_subindex, domain, &data.bit_position);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return ret;
 }
 
@@ -2686,32 +3116,39 @@ static ATTRIBUTES int ec_ioctl_sc_reg_pdo_pos(
         return -EPERM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(&io, (void __user *) arg, sizeof(io));
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, io.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     if (!(domain = ec_master_find_domain(master, io.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc or domain could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc or domain could be invalidated */
 
     ret = ecrt_slave_config_reg_pdo_entry_pos(sc, io.sync_index,
             io.pdo_pos, io.entry_pos, domain, &io.bit_position);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (copy_to_user((void __user *) arg, &io, sizeof(io)))
         return -EFAULT;
-
+#endif
     return ret;
 }
 
@@ -2734,24 +3171,27 @@ static ATTRIBUTES int ec_ioctl_sc_dc(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem))
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    ret = ecrt_slave_config_dc(sc, data.dc_assign_activate,
+    ecrt_slave_config_dc(sc, data.dc_assign_activate,
             data.dc_sync[0].cycle_time,
             data.dc_sync[0].shift_time,
             data.dc_sync[1].cycle_time,
             data.dc_sync[1].shift_time);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return ret;
 }
@@ -2776,33 +3216,53 @@ static ATTRIBUTES int ec_ioctl_sc_sdo(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.data = arg + sizeof(ec_ioctl_sc_sdo_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
-
+#endif
     if (!data.size)
         return -EINVAL;
 
+#ifdef EC_USERMODE
+    if (!(sdo_data = (uint8_t *)malloc(data.size))) {
+#else
     if (!(sdo_data = kmalloc(data.size, GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(sdo_data, data.data, data.size);
+#else
     if (copy_from_user(sdo_data, (void __user *) data.data, data.size)) {
         kfree(sdo_data);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(sdo_data);
+#else
         kfree(sdo_data);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
+#ifdef EC_USERMODE
+        free(sdo_data);
+#else
         kfree(sdo_data);
+#endif
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     if (data.complete_access) {
         ret = ecrt_slave_config_complete_sdo(sc,
@@ -2811,7 +3271,11 @@ static ATTRIBUTES int ec_ioctl_sc_sdo(
         ret = ecrt_slave_config_sdo(sc, data.index, data.subindex, sdo_data,
                 data.size);
     }
+#ifdef EC_USERMODE
+    free(sdo_data);
+#else
     kfree(sdo_data);
+#endif
     return ret;
 }
 
@@ -2834,21 +3298,25 @@ static ATTRIBUTES int ec_ioctl_sc_emerg_size(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.target = arg + sizeof(ec_ioctl_sc_emerg_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io)))
         return -EFAULT;
-
-    if (down_interruptible(&master->master_sem)) {
+#endif
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, io.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     ret = ecrt_slave_config_emerg_size(sc, io.size);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return ret;
 }
@@ -2877,6 +3345,9 @@ static ATTRIBUTES int ec_ioctl_sc_emerg_pop(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.target = arg + sizeof(ec_ioctl_sc_emerg_t);
+#endif
 
     /* no locking of master_sem needed, because configuration will not be
      * deleted in the meantime. */
@@ -2919,6 +3390,9 @@ static ATTRIBUTES int ec_ioctl_sc_emerg_clear(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.target = arg + sizeof(ec_ioctl_sc_emerg_t);
+#endif
 
     /* no locking of master_sem needed, because configuration will not be
      * deleted in the meantime. */
@@ -2953,6 +3427,9 @@ static ATTRIBUTES int ec_ioctl_sc_emerg_overruns(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.target = arg + sizeof(ec_ioctl_sc_emerg_t);
+#endif
 
     /* no locking of master_sem needed, because configuration will not be
      * deleted in the meantime. */
@@ -2994,18 +3471,23 @@ static ATTRIBUTES int ec_ioctl_sc_create_sdo_request(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     data.request_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     sc = ec_master_get_config(master, data.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3013,16 +3495,19 @@ static ATTRIBUTES int ec_ioctl_sc_create_sdo_request(
         data.request_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     req = ecrt_slave_config_create_sdo_request_err(sc, data.sdo_index,
             data.sdo_subindex, data.size);
     if (IS_ERR(req))
         return PTR_ERR(req);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -3045,18 +3530,23 @@ static ATTRIBUTES int ec_ioctl_sc_create_soe_request(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     data.request_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     sc = ec_master_get_config(master, data.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3064,7 +3554,7 @@ static ATTRIBUTES int ec_ioctl_sc_create_soe_request(
         data.request_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     req = ecrt_slave_config_create_soe_request_err(sc, data.drive_no,
             data.idn, data.size);
@@ -3072,10 +3562,13 @@ static ATTRIBUTES int ec_ioctl_sc_create_soe_request(
         return PTR_ERR(req);
     }
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data))) {
         return -EFAULT;
     }
-
+#endif
     return 0;
 }
 
@@ -3099,19 +3592,24 @@ static ATTRIBUTES int ec_ioctl_sc_create_reg_request(
         return -EPERM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.data = arg + sizeof(ec_ioctl_reg_request_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     io.request_index = 0;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     sc = ec_master_get_config(master, io.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3119,16 +3617,20 @@ static ATTRIBUTES int ec_ioctl_sc_create_reg_request(
         io.request_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     reg = ecrt_slave_config_create_reg_request_err(sc, io.mem_size);
     if (IS_ERR(reg)) {
         return PTR_ERR(reg);
     }
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (copy_to_user((void __user *) arg, &io, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     return 0;
 }
@@ -3152,18 +3654,23 @@ static ATTRIBUTES int ec_ioctl_sc_create_voe_handler(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&data, arg, sizeof(data));
+    data.data = arg + sizeof(ec_ioctl_voe_t);
+#else
     if (copy_from_user(&data, (void __user *) arg, sizeof(data))) {
         return -EFAULT;
     }
+#endif
 
     data.voe_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     sc = ec_master_get_config(master, data.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3171,15 +3678,18 @@ static ATTRIBUTES int ec_ioctl_sc_create_voe_handler(
         data.voe_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     voe = ecrt_slave_config_create_voe_handler_err(sc, data.size);
     if (IS_ERR(voe))
         return PTR_ERR(voe);
 
+#ifdef EC_USERMODE
+    memcpy(arg, &data, sizeof(data));
+#else
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
-
+#endif
     return 0;
 }
 
@@ -3206,6 +3716,9 @@ static ATTRIBUTES int ec_ioctl_sc_state(
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    data.state = arg + sizeof(ec_ioctl_sc_state_t);
+#endif
 
     /* no locking of master_sem needed, because sc will not be deleted in the
      * meantime. */
@@ -3221,7 +3734,6 @@ static ATTRIBUTES int ec_ioctl_sc_state(
     if (ec_copy_to_user((void __user *) data.state,
                         &state, sizeof(state), ctx))
         return -EFAULT;
-
     return 0;
 }
 
@@ -3245,37 +3757,61 @@ static ATTRIBUTES int ec_ioctl_sc_idn(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
+#ifdef EC_USERMODE
+    memcpy(&ioctl, arg, sizeof(ioctl));
+    ioctl.data = arg + sizeof(ec_ioctl_sc_idn_t);
+#else
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl)))
         return -EFAULT;
-
+#endif
     if (!ioctl.size)
         return -EINVAL;
 
+#ifdef EC_USERMODE
+    if (!(data = malloc(ioctl.size))) {
+#else
     if (!(data = kmalloc(ioctl.size, GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(data, ioctl.data, ioctl.size);
+#else
     if (copy_from_user(data, (void __user *) ioctl.data, ioctl.size)) {
         kfree(data);
         return -EFAULT;
     }
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(data);
+#else
         kfree(data);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, ioctl.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
+#ifdef EC_USERMODE
+        free(data);
+#else
         kfree(data);
+#endif
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     ret = ecrt_slave_config_idn(
             sc, ioctl.drive_no, ioctl.idn, ioctl.al_state, data, ioctl.size);
+#ifdef EC_USERMODE
+    free(data);
+#else
     kfree(data);
+#endif
     return ret;
 }
 
@@ -3300,39 +3836,63 @@ static ATTRIBUTES int ec_ioctl_sc_flag(
         return -EPERM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(&ioctl, arg, sizeof(ioctl));
+    ioctl.key = arg + sizeof(ec_ioctl_sc_flag_t);
+#else
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
         return -EFAULT;
     }
+#endif
 
     if (!ioctl.key_size) {
         return -EINVAL;
     }
 
+#ifdef EC_USERMODE
+    if (!(key = malloc(ioctl.key_size + 1))) {
+#else
     if (!(key = kmalloc(ioctl.key_size + 1, GFP_KERNEL))) {
+#endif
         return -ENOMEM;
     }
 
+#ifdef EC_USERMODE
+    memcpy(key, ioctl.key, ioctl.key_size);
+#else
     if (copy_from_user(key, (void __user *) ioctl.key, ioctl.key_size)) {
         kfree(key);
         return -EFAULT;
     }
-    key[ioctl.key_size] = '\0';
+#endif
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
+#ifdef EC_USERMODE
+        free(key);
+#else
         kfree(key);
+#endif
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, ioctl.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
+#ifdef EC_USERMODE
+        free(key);
+#else
         kfree(key);
+#endif
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     ret = ecrt_slave_config_flag(sc, key, ioctl.value);
+#ifdef EC_USERMODE
+    free(key);
+#else
     kfree(key);
+#endif
     return ret;
 }
 
@@ -3455,19 +4015,19 @@ static ATTRIBUTES int ec_ioctl_domain_size(
         return -EPERM;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     list_for_each_entry(domain, &master->domains, list) {
         if (domain->index == (unsigned long) arg) {
             size_t size = ecrt_domain_size(domain);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return size;
         }
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return -ENOENT;
 }
 
@@ -3489,19 +4049,19 @@ static ATTRIBUTES int ec_ioctl_domain_offset(
     if (unlikely(!ctx->requested))
         return -EPERM;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     list_for_each_entry(domain, &master->domains, list) {
         if (domain->index == (unsigned long) arg) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return offset;
         }
         offset += ecrt_domain_size(domain);
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return -ENOENT;
 }
 
@@ -3588,6 +4148,9 @@ static ATTRIBUTES int ec_ioctl_domain_state(
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    data.state = arg + sizeof(ec_ioctl_domain_state_t);
+#endif
 
     /* no locking of master_sem needed, because domain will not be deleted in
      * the meantime. */
@@ -3628,6 +4191,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_index(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor req will not be
      * deleted in the meantime. */
@@ -3664,6 +4230,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_timeout(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor req will not be
      * deleted in the meantime. */
@@ -3702,6 +4271,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_state(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor req will not be
      * deleted in the meantime. */
@@ -3747,6 +4319,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_read(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor req will not be
      * deleted in the meantime. */
@@ -3783,6 +4358,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_write(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     if (!data.size) {
         EC_MASTER_ERR(master, "SDO download: Data size may not be zero!\n");
@@ -3832,6 +4410,9 @@ static ATTRIBUTES int ec_ioctl_sdo_request_data(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.data = arg + sizeof(ec_ioctl_sdo_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor req will not be
      * deleted in the meantime. */
@@ -4118,6 +4699,9 @@ static ATTRIBUTES int ec_ioctl_reg_request_data(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.data = arg + sizeof(ec_ioctl_reg_request_t);
+#endif
 
     if (io.mem_size <= 0) {
         return 0;
@@ -4165,6 +4749,9 @@ static ATTRIBUTES int ec_ioctl_reg_request_state(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.data = arg + sizeof(ec_ioctl_reg_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor reg will not be
      * deleted in the meantime. */
@@ -4210,6 +4797,9 @@ static ATTRIBUTES int ec_ioctl_reg_request_write(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.data = arg + sizeof(ec_ioctl_reg_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor reg will not be
      * deleted in the meantime. */
@@ -4257,6 +4847,9 @@ static ATTRIBUTES int ec_ioctl_reg_request_read(
     if (ec_copy_from_user(&io, (void __user *) arg, sizeof(io), ctx)) {
         return -EFAULT;
     }
+#ifdef EC_USERMODE
+    io.data = arg + sizeof(ec_ioctl_reg_request_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor reg will not be
      * deleted in the meantime. */
@@ -4306,6 +4899,13 @@ static ATTRIBUTES int ec_ioctl_voe_send_header(
     if (ec_copy_from_user(&vendor_type, data.vendor_type,
                           sizeof(vendor_type), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    vendor_id = data.vendor_id;
+    vendor_type = data.vendor_type;
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4345,6 +4945,13 @@ static ATTRIBUTES int ec_ioctl_voe_rec_header(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    vendor_id = data.vendor_id;
+    vendor_type = data.vendor_type;
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4395,6 +5002,11 @@ static ATTRIBUTES int ec_ioctl_voe_read(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4431,6 +5043,11 @@ static ATTRIBUTES int ec_ioctl_voe_read_nosync(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4467,6 +5084,11 @@ static ATTRIBUTES int ec_ioctl_voe_write(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4512,6 +5134,11 @@ static ATTRIBUTES int ec_ioctl_voe_exec(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4561,6 +5188,11 @@ static ATTRIBUTES int ec_ioctl_voe_data(
 
     if (ec_copy_from_user(&data, (void __user *) arg, sizeof(data), ctx))
         return -EFAULT;
+#ifdef EC_USERMODE
+    data.vendor_id = arg + sizeof(ec_ioctl_voe_t);
+    data.vendor_type = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t);
+    data.data = arg + sizeof(ec_ioctl_voe_t) + sizeof(uint32_t) + sizeof(uint16_t);
+#endif
 
     /* no locking of master_sem needed, because neither sc nor voe will not be
      * deleted in the meantime. */
@@ -4596,9 +5228,14 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
     ec_slave_t *slave;
     int ret;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.buffer = arg + sizeof(ec_ioctl_slave_foe_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     ec_foe_request_init(&request, io.file_name);
     ret = ec_foe_request_alloc(&request, 10000); // FIXME
@@ -4609,13 +5246,13 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
 
     ec_foe_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_foe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_foe_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
@@ -4627,25 +5264,34 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
     // schedule request.
     list_add_tail(&request.list, &slave->foe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_foe_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     io.result = request.result;
     io.error_code = request.error_code;
@@ -4660,17 +5306,25 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
             return -ENOBUFS;
         }
         io.data_size = request.data_size;
+#ifdef EC_USERMODE
+        memcpy(io.buffer, request.buffer, io.data_size);
+#else
         if (copy_to_user((void __user *) io.buffer,
                     request.buffer, io.data_size)) {
             ec_foe_request_clear(&request);
             return -EFAULT;
         }
+#endif
         ret = 0;
     }
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (__copy_to_user((void __user *) arg, &io, sizeof(io))) {
         ret = -EFAULT;
     }
+#endif
 
     ec_foe_request_clear(&request);
     return ret;
@@ -4692,9 +5346,14 @@ static ATTRIBUTES int ec_ioctl_slave_foe_write(
     ec_slave_t *slave;
     int ret;
 
+#ifdef EC_USERMODE
+    memcpy(&io, arg, sizeof(io));
+    io.buffer = arg + sizeof(ec_ioctl_slave_foe_t);
+#else
     if (copy_from_user(&io, (void __user *) arg, sizeof(io))) {
         return -EFAULT;
     }
+#endif
 
     ec_foe_request_init(&request, io.file_name);
 
@@ -4704,22 +5363,26 @@ static ATTRIBUTES int ec_ioctl_slave_foe_write(
         return ret;
     }
 
+#ifdef EC_USERMODE
+    memcpy(request.buffer, io.buffer, io.buffer_size);
+#else
     if (copy_from_user(request.buffer,
                 (void __user *) io.buffer, io.buffer_size)) {
         ec_foe_request_clear(&request);
         return -EFAULT;
     }
+#endif
 
     request.data_size = io.buffer_size;
     ec_foe_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_foe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
         ec_foe_request_clear(&request);
@@ -4731,34 +5394,47 @@ static ATTRIBUTES int ec_ioctl_slave_foe_write(
     // schedule FoE write request.
     list_add_tail(&request.list, &slave->foe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_foe_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     io.result = request.result;
     io.error_code = request.error_code;
 
     ret = request.state == EC_INT_REQUEST_SUCCESS ? 0 : -EIO;
 
+#ifdef EC_USERMODE
+    memcpy(arg, &io, sizeof(io));
+#else
     if (__copy_to_user((void __user *) arg, &io, sizeof(io))) {
         ret = -EFAULT;
     }
+#endif
 
     ec_foe_request_clear(&request);
     return ret;
@@ -4779,11 +5455,20 @@ static ATTRIBUTES int ec_ioctl_slave_soe_read(
     u8 *data;
     int retval;
 
+#ifdef EC_USERMODE
+    memcpy(&ioctl, arg, sizeof(ioctl));
+    ioctl.data = arg + sizeof(ec_ioctl_slave_soe_read_t);
+#else
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    data = malloc(ioctl.mem_size);
+#else
     data = kmalloc(ioctl.mem_size, GFP_KERNEL);
+#endif
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
                 ioctl.mem_size);
@@ -4794,20 +5479,36 @@ static ATTRIBUTES int ec_ioctl_slave_soe_read(
             ioctl.drive_no, ioctl.idn, data, ioctl.mem_size, &ioctl.data_size,
             &ioctl.error_code);
     if (retval) {
+#ifdef EC_USERMODE
+        free(data);
+#else
         kfree(data);
+#endif
         return retval;
     }
 
+#ifdef EC_USERMODE
+    memcpy(ioctl.data, data, ioctl.data_size);
+#else
     if (copy_to_user((void __user *) ioctl.data,
                 data, ioctl.data_size)) {
         kfree(data);
         return -EFAULT;
     }
+#endif
+#ifdef EC_USERMODE
+    free(data);
+#else
     kfree(data);
+#endif
 
+#ifdef EC_USERMODE
+    memcpy(arg, &ioctl, sizeof(ioctl));
+#else
     if (__copy_to_user((void __user *) arg, &ioctl, sizeof(ioctl))) {
         retval = -EFAULT;
     }
+#endif
 
     EC_MASTER_DBG(master, 1, "Finished SoE read request.\n");
     return retval;
@@ -4828,32 +5529,53 @@ static ATTRIBUTES int ec_ioctl_slave_soe_write(
     u8 *data;
     int retval;
 
+#ifdef EC_USERMODE
+    memcpy(&ioctl, arg, sizeof(ioctl));
+    ioctl.data = arg + sizeof(ec_ioctl_slave_soe_write_t);
+#else
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
         return -EFAULT;
     }
+#endif
 
+#ifdef EC_USERMODE
+    data = malloc(ioctl.data_size);
+#else
     data = kmalloc(ioctl.data_size, GFP_KERNEL);
+#endif
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
                 ioctl.data_size);
         return -ENOMEM;
     }
+#ifdef EC_USERMODE
+    memcpy(data, ioctl.data, ioctl.data_size);
+#else
     if (copy_from_user(data, (void __user *) ioctl.data, ioctl.data_size)) {
         kfree(data);
         return -EFAULT;
     }
+#endif
 
     retval = ecrt_master_write_idn(master, ioctl.slave_position,
             ioctl.drive_no, ioctl.idn, data, ioctl.data_size,
             &ioctl.error_code);
+#ifdef EC_USERMODE
+    free(data);
+#else
     kfree(data);
+#endif
     if (retval) {
         return retval;
     }
 
+#ifdef EC_USERMODE
+    memcpy(arg, &ioctl, sizeof(ioctl));
+#else
     if (__copy_to_user((void __user *) arg, &ioctl, sizeof(ioctl))) {
         retval = -EFAULT;
     }
+#endif
 
     EC_MASTER_DBG(master, 1, "Finished SoE write request.\n");
     return retval;
diff --git a/master/ioctl.h b/master/ioctl.h
index 0c51e638..78e35f23 100644
--- a/master/ioctl.h
+++ b/master/ioctl.h
@@ -166,7 +166,9 @@
 
 #define EC_IOCTL_STRING_SIZE 64
 
-/****************************************************************************/
+/*****************************************************************************/
+
+/*****************************************************************************/
 
 typedef struct {
     uint32_t ioctl_version_magic;
@@ -197,6 +199,20 @@ typedef struct {
         int32_t rx_frame_rates[EC_RATE_COUNT];
         int32_t tx_byte_rates[EC_RATE_COUNT];
         int32_t rx_byte_rates[EC_RATE_COUNT];
+#ifdef EC_BENCHMARK
+/*
+  NUM_TX_LATENCY 0: tx total latency
+  NUM_TX_LATENCY 1: tx sw latency
+  NUM_TX_LATENCY 2: tx hw latency
+  NUM_RX_LATENCY 0: rx sw latency
+  NUM_STATISTIC 0: min
+  NUM_STATISTIC 1: max
+  NUM_STATISTIC 2: avg
+*/
+        uint64_t tx_latency[NUM_TX_LATENCY][NUM_STATISTIC];
+        uint64_t rx_latency[NUM_RX_LATENCY][NUM_STATISTIC];
+
+#endif
     } devices[EC_MAX_NUM_DEVICES];
     uint32_t num_devices;
     uint64_t tx_count;
@@ -841,8 +857,21 @@ typedef struct {
     ec_master_link_state_t *state;
 } ec_ioctl_link_state_t;
 
-/****************************************************************************/
+/*****************************************************************************/
+#ifdef EC_USERMODE
+/** Context data structure for file handles.
+ */
+typedef struct {
+    unsigned int writable; /**< Device was opened with write permission. */
+    unsigned int requested; /**< Master was requested via this file handle. */
+    uint8_t *process_data; /**< Total process data area. */
+    size_t process_data_size; /**< Size of the \a process_data. */
+} ec_ioctl_context_t;
 
+#define __user
+long ec_ioctl(ec_master_t *, ec_ioctl_context_t *, unsigned int,
+        void __user *);
+#else
 #ifdef __KERNEL__
 
 /** Context data structure for file handles.
@@ -871,7 +900,7 @@ int ec_rtdm_mmap(ec_ioctl_context_t *, void **);
 #endif
 
 #endif
-
+#endif
 /****************************************************************************/
 
 /** \endcond */
diff --git a/master/list.h b/master/list.h
new file mode 100644
index 00000000..f90b2b3c
--- /dev/null
+++ b/master/list.h
@@ -0,0 +1,210 @@
+/*
+ Copyright (C) 2020 Intel Corporation. All rights reserved.
+
+ This program is free software; you can redistribute it and/or modify it
+ under the terms and conditions of the GNU Lesser General Public License,
+ version 2.1, as published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program; if not, write to the Free Software Foundation, Inc.,
+ 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+/**
+ * 
+ * @file list.h
+ * 
+ */
+
+#ifndef __LIST_H__
+#define __LIST_H__
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#ifndef offsetof
+#define offsetof(type, member) (size_t)&(((type*)0)->member)
+#endif
+
+#ifndef container_of
+#define container_of(ptr, type, member) ({ \
+    const typeof( ((type *)0)->member ) \
+    *__mptr = (ptr); \
+    (type *)( (char *)__mptr - offsetof(type, member) );})
+#endif
+
+struct list_head {
+    struct list_head *next;
+    struct list_head *prev;
+};
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+    list->next = list;
+    list->prev = list;
+}
+
+static inline bool __list_add_valid(struct list_head *new,
+				struct list_head *prev,
+				struct list_head *next)
+{
+	return true;
+}
+static inline bool __list_del_entry_valid(struct list_head *entry)
+{
+	return true;
+}
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new_node,
+                  struct list_head *prev_node,
+                  struct list_head *next_node)
+{
+    next_node->prev = new_node;
+    new_node->next = next_node;
+    new_node->prev = prev_node;
+    prev_node->next = new_node;
+}
+
+static inline void __list_del(struct list_head *prev, struct list_head *next)
+{
+    if (!next) {
+        return;
+    }
+    next->prev = prev;
+    prev->next = next;
+}
+
+static inline void list_del(struct list_head *entry)
+{
+    if (!entry) {
+        return;
+    }
+    __list_del(entry->prev, entry->next);
+    entry->next = NULL;
+    entry->prev = NULL;
+}
+
+/*
+ * Delete a list entry and clear the 'prev' pointer.
+ *
+ * This is a special-purpose list clearing method used in the networking code
+ * for lists allocated as per-cpu, where we don't want to incur the extra
+ * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this
+ * needs to check the node 'prev' pointer instead of calling list_empty().
+ */
+static inline void __list_del_clearprev(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->prev = NULL;
+}
+
+static inline void __list_del_entry(struct list_head *entry)
+{
+	if (!__list_del_entry_valid(entry))
+		return;
+
+	__list_del(entry->prev, entry->next);
+}
+
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del_entry(entry);
+	INIT_LIST_HEAD(entry);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new_node, struct list_head *head_node)
+{
+    __list_add(new_node, head_node->prev, head_node);
+}
+
+static inline int list_empty(const struct list_head *head_node)
+{
+    return head_node->next == head_node;
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:    the &struct list_head pointer.
+ * @type:   the type of the struct this is embedded in.
+ * @member: the name of the list_head within the struct.
+ */
+#define list_entry(ptr, type, member) \
+    container_of(ptr, type, member)
+
+/**
+ * list_first_entry - get the first element from a list
+ * @ptr:    the list head to take the element from.
+ * @type:   the type of the struct this is embedded in.
+ * @member: the name of the list_head within the struct.
+ *
+ * Note, that list is expected to be not empty.
+ */
+#define list_first_entry(ptr, type, member) \
+    list_entry((ptr)->next, type, member)
+
+/**
+ * list_next_entry - get the next element in list
+ * @pos:    the type * to cursor
+ * @member: the name of the list_head within the struct.
+ */
+#define list_next_entry(pos, member) \
+    list_entry((pos)->member.next, typeof(*(pos)), member)
+
+/**
+ * list_for_each        -       iterate over a list
+ * @pos:        the &struct list_head to use as a loop cursor.
+ * @head:       the head for your list.
+ */
+#define list_for_each(pos, head) \
+        for (pos = (head)->next; pos && (pos != (head)); pos = pos->next)
+
+/**
+ * list_for_each_entry  -   iterate over list of given type
+ * @pos:    the type * to use as a loop cursor.
+ * @head:   the head for your list.
+ * @member: the name of the list_head within the struct.
+ */
+#define list_for_each_entry(pos, head, member)              \
+    for (pos = list_first_entry(head, typeof(*pos), member);    \
+         pos && (&pos->member != (head));                    \
+         pos = list_next_entry(pos, member))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:        the type * to use as a loop cursor.
+ * @n:          another type * to use as temporary storage
+ * @head:       the head for your list.
+ * @member:     the name of the list_head within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)                  \
+        for (pos = list_first_entry(head, typeof(*pos), member),        \
+                n = list_next_entry(pos, member);                       \
+             pos && (&pos->member != (head));                                    \
+             pos = n, n = list_next_entry(n, member))
+
+#endif
diff --git a/master/mailbox.c b/master/mailbox.c
index 05a10fd1..7233a188 100644
--- a/master/mailbox.c
+++ b/master/mailbox.c
@@ -26,9 +26,15 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifndef EC_USERMODE
+//#include <stdio.h>
+//#include "mm.h"
+//#else
 #include <linux/slab.h>
 #include <linux/delay.h>
-
+#endif
 #include "mailbox.h"
 #include "datagram.h"
 #include "master.h"
@@ -182,13 +188,13 @@ uint8_t *ec_slave_mbox_fetch(const ec_slave_t *slave, /**< slave */
         for (mbox_msg = mbox_error_messages; mbox_msg->code; mbox_msg++) {
             if (mbox_msg->code != code)
                 continue;
-            printk(KERN_CONT "Code 0x%04X: \"%s\".\n",
+            ec_print(EC_CONT "Code 0x%04X: \"%s\".\n",
                     mbox_msg->code, mbox_msg->message);
             break;
         }
 
         if (!mbox_msg->code) {
-            printk(KERN_CONT "Unknown error reply code 0x%04X.\n", code);
+            ec_print(EC_CONT "Unknown error reply code 0x%04X.\n", code);
         }
 
         if (slave->master->debug_level)
diff --git a/master/master.c b/master/master.c
index 77f646f1..745e1792 100644
--- a/master/master.c
+++ b/master/master.c
@@ -28,6 +28,9 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -37,8 +40,16 @@
 #include <linux/version.h>
 #include <linux/hrtimer.h>
 #include <linux/kthread.h>
+#else
+#include "list.h"
+#include "wq.h"
+#include "rt_locks.h"
+#include <string.h>
+#include "../ipc/ecat_ipc.h"
+#include <time.h>
+#include <sys/time.h>
+#endif
 
-#include "globals.h"
 #include "slave.h"
 #include "slave_config.h"
 #include "device.h"
@@ -135,6 +146,10 @@ static void sc_reset_task(struct work_struct *work);
 */
 void ec_master_init_static(void)
 {
+#ifdef EC_USERMODE
+    timeout_jiffies = EC_IO_TIMEOUT * 1000;
+    ext_injection_timeout_jiffies = EC_SDO_INJECTION_TIMEOUT * 1000;
+#else
 #ifdef EC_HAVE_CYCLES
     timeout_cycles = (cycles_t) EC_IO_TIMEOUT /* us */ * (cpu_khz / 1000);
     ext_injection_timeout_cycles =
@@ -145,6 +160,7 @@ void ec_master_init_static(void)
     ext_injection_timeout_jiffies =
         max(EC_SDO_INJECTION_TIMEOUT * HZ / 1000000, 1);
 #endif
+#endif
 }
 
 /****************************************************************************/
@@ -158,19 +174,26 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
         unsigned int index, /**< master index */
         const uint8_t *main_mac, /**< MAC address of main device */
         const uint8_t *backup_mac, /**< MAC address of backup device */
+#ifndef EC_USERMODE
         dev_t device_number, /**< Character device number. */
         struct class *class, /**< Device class. */
-        unsigned int debug_level, /**< Debug level (module parameter). */
-        unsigned int run_on_cpu /**< bind created kernel threads to a cpu */
+#endif
+        unsigned int debug_level /**< Debug level (module parameter). */
+#ifndef EC_USERMODE
+        , unsigned int run_on_cpu /**< bind created kernel threads to a cpu */
+#else
+        , char* argv
+#endif
         )
 {
     int ret;
     unsigned int dev_idx, i;
-
+#ifdef EC_USERMODE
+    char name[10];
+#endif
     master->index = index;
     master->reserved = 0;
-
-    sema_init(&master->master_sem, 1);
+    ec_lock_init(&master->master_sem);
 
     for (dev_idx = EC_DEVICE_MAIN; dev_idx < EC_MAX_NUM_DEVICES; dev_idx++) {
         master->macs[dev_idx] = NULL;
@@ -189,7 +212,7 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
 
     ec_master_clear_device_stats(master);
 
-    sema_init(&master->device_sem, 1);
+    ec_lock_init(&master->device_sem);
 
     master->phase = EC_ORPHANED;
     master->active = 0;
@@ -209,18 +232,18 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
     master->scan_busy = 0;
     master->scan_index = 0;
     master->allow_scan = 1;
-    sema_init(&master->scan_sem, 1);
+    ec_lock_init(&master->scan_sem);
     init_waitqueue_head(&master->scan_queue);
 
     master->config_busy = 0;
-    sema_init(&master->config_sem, 1);
+    ec_lock_init(&master->config_sem);
     init_waitqueue_head(&master->config_queue);
 
     INIT_LIST_HEAD(&master->datagram_queue);
     master->datagram_index = 0;
 
     INIT_LIST_HEAD(&master->ext_datagram_queue);
-    sema_init(&master->ext_queue_sem, 1);
+    ec_lock_init(&master->ext_queue_sem);
 
     master->ext_ring_idx_rt = 0;
     master->ext_ring_idx_fsm = 0;
@@ -233,14 +256,20 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
     }
 
     // send interval in IDLE phase
+#ifdef EC_USERMODE
+    ec_master_set_send_interval(master, 1000);
+#else
     ec_master_set_send_interval(master, 1000000 / HZ);
+#endif
 
     master->fsm_slave = NULL;
     INIT_LIST_HEAD(&master->fsm_exec_list);
     master->fsm_exec_count = 0U;
 
     master->debug_level = debug_level;
+#ifndef EC_USERMODE
     master->run_on_cpu = run_on_cpu;
+#endif
     master->stats.timeouts = 0;
     master->stats.corrupted = 0;
     master->stats.unmatched = 0;
@@ -253,7 +282,11 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
     INIT_LIST_HEAD(&master->eoe_handlers);
 #endif
 
+#ifdef EC_USERMODE
+    ec_lock_init(&master->io_mutex);
+#else
     rt_mutex_init(&master->io_mutex);
+#endif
     master->send_cb = NULL;
     master->receive_cb = NULL;
     master->cb_data = NULL;
@@ -336,10 +369,13 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
 
     master->dc_ref_config = NULL;
     master->dc_ref_clock = NULL;
-
+#ifndef EC_USERMODE
     INIT_WORK(&master->sc_reset_work, sc_reset_task);
     init_irq_work(&master->sc_reset_work_kicker, sc_reset_task_kicker);
-
+#endif
+#ifdef EC_USERMODE
+    master->seg_id = ipc_iface_init(&master->ipcs);
+#else
     // init character device
     ret = ec_cdev_init(&master->cdev, master, device_number);
     if (ret)
@@ -361,15 +397,20 @@ int ec_master_init(ec_master_t *master, /**< EtherCAT master */
         goto out_unregister_class_device;
     }
 #endif
-
+#endif
+#ifdef EC_USERMODE
+    ec_device_bind(master, argv);
+#endif
     return 0;
 
+#ifndef EC_USERMODE
 #ifdef EC_RTDM
 out_unregister_class_device:
     device_unregister(master->class_device);
 #endif
 out_clear_cdev:
     ec_cdev_clear(&master->cdev);
+#endif
 out_clear_sync_mon:
     ec_datagram_clear(&master->sync_mon_datagram);
 out_clear_sync:
@@ -399,6 +440,9 @@ void ec_master_clear(
 {
     unsigned int dev_idx, i;
 
+#ifdef EC_USERMODE
+    ipc_iface_release(master->seg_id,master->ipcs);
+#else
 #ifdef EC_RTDM
     ec_rtdm_dev_clear(&master->rtdm_dev);
 #endif
@@ -406,9 +450,11 @@ void ec_master_clear(
     device_unregister(master->class_device);
 
     ec_cdev_clear(&master->cdev);
-
+#endif
+#ifndef EC_USERMODE
     irq_work_sync(&master->sc_reset_work_kicker);
     cancel_work_sync(&master->sc_reset_work);
+#endif
 
 #ifdef EC_EOE
     ec_master_clear_eoe_handlers(master);
@@ -448,7 +494,11 @@ void ec_master_clear_eoe_handlers(
     list_for_each_entry_safe(eoe, next, &master->eoe_handlers, list) {
         list_del(&eoe->list);
         ec_eoe_clear(eoe);
+#ifdef EC_USERMODE
+        free(eoe);
+#else
         kfree(eoe);
+#endif
     }
 }
 #endif
@@ -467,7 +517,11 @@ void ec_master_clear_slave_configs(ec_master_t *master)
     list_for_each_entry_safe(sc, next, &master->configs, list) {
         list_del(&sc->list);
         ec_slave_config_clear(sc);
+#ifdef EC_USERMODE
+        free(sc);
+#else
         kfree(sc);
+#endif
     }
 }
 
@@ -506,7 +560,11 @@ void ec_master_clear_slaves(ec_master_t *master)
     }
 
     if (master->slaves) {
+#ifdef EC_USERMODE
+        free(master->slaves);
+#else
         kfree(master->slaves);
+#endif
         master->slaves = NULL;
     }
 
@@ -524,7 +582,11 @@ void ec_master_clear_domains(ec_master_t *master)
     list_for_each_entry_safe(domain, next, &master->domains, list) {
         list_del(&domain->list);
         ec_domain_clear(domain);
+#ifdef EC_USERMODE
+        free(domain);
+#else
         kfree(domain);
+#endif
     }
 }
 
@@ -536,10 +598,10 @@ void ec_master_clear_config(
         ec_master_t *master /**< EtherCAT master. */
         )
 {
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
     ec_master_clear_domains(master);
     ec_master_clear_slave_configs(master);
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 }
 
 /****************************************************************************/
@@ -551,10 +613,18 @@ void ec_master_internal_send_cb(
         )
 {
     ec_master_t *master = (ec_master_t *) cb_data;
+#ifdef EC_USERMODE
+    if (ec_lock_down_interruptible(&master->io_mutex))
+#else
     if (ec_rt_lock_interruptible(&master->io_mutex))
+#endif
         return;
     ecrt_master_send_ext(master);
+#ifdef EC_USERMODE
+    ec_lock_up(&master->io_mutex);
+#else
     rt_mutex_unlock(&master->io_mutex);
+#endif
 }
 
 /****************************************************************************/
@@ -566,10 +636,18 @@ void ec_master_internal_receive_cb(
         )
 {
     ec_master_t *master = (ec_master_t *) cb_data;
+#ifdef EC_USERMODE
+    if (ec_lock_down_interruptible(&master->io_mutex))
+#else
     if (ec_rt_lock_interruptible(&master->io_mutex))
+#endif
         return;
     ecrt_master_receive(master);
+#ifdef EC_USERMODE
+    ec_lock_up(&master->io_mutex);
+#else
     rt_mutex_unlock(&master->io_mutex);
+#endif
 }
 
 /****************************************************************************/
@@ -585,7 +663,41 @@ int ec_master_thread_start(
         const char *name /**< Thread name. */
         )
 {
+#ifdef EC_USERMODE
+    int ret;
+    pthread_attr_t thattr;
+    struct sched_param schparam;
+#endif
     EC_MASTER_INFO(master, "Starting %s thread.\n", name);
+#ifdef EC_USERMODE
+    master->thread = calloc(1,sizeof(pthread_t));
+    if (master->thread == NULL) {
+	    EC_MASTER_ERR(master, "Failed to calloc master thread\n!");
+	    return -1;
+    }
+    master->thread_status = 1;
+    pthread_attr_init(&thattr);
+    //pthread_attr_setstacksize(&thattr, stacksize);
+    ret = pthread_create(master->thread, &thattr, thread_func, master);
+    pthread_attr_destroy(&thattr);
+    if (ret != 0) {
+            EC_MASTER_ERR(master, "Failed to start master thread (error %i)!\n",
+		    ret);
+	    free(master->thread);
+	    master->thread = NULL;
+	    return ret;
+    }
+    memset(&schparam, 0, sizeof(schparam));
+    schparam.sched_priority = EC_MASTER_ETHERCAT_THREAD_PRIO;
+    ret = pthread_setschedparam(*master->thread, SCHED_FIFO, &schparam);
+    if (ret < 0) {
+            EC_MASTER_ERR(master, "Failed to set thread as SCHED_FIFO (error %i)!\n",
+		    ret);
+	    free(master->thread);
+	    master->thread = NULL;
+	    return ret;
+    }
+#else
     master->thread = kthread_create(thread_func, master, name);
     if (IS_ERR(master->thread)) {
         int err = (int) PTR_ERR(master->thread);
@@ -598,8 +710,11 @@ int ec_master_thread_start(
         EC_MASTER_INFO(master, " binding thread to cpu %u\n",master->run_on_cpu);
         kthread_bind(master->thread,master->run_on_cpu);
     }
+#endif
+#ifndef EC_USERMODE
     /* Ignoring return value of wake_up_process */
     (void) wake_up_process(master->thread);
+#endif
 
     return 0;
 }
@@ -621,7 +736,14 @@ void ec_master_thread_stop(
 
     EC_MASTER_DBG(master, 1, "Stopping master thread.\n");
 
+#ifdef EC_USERMODE
+    master->thread_status = 0;
+    pthread_cancel(*master->thread);
+    pthread_join(*master->thread, NULL);
+    free(master->thread);
+#else
     kthread_stop(master->thread);
+#endif
     master->thread = NULL;
     EC_MASTER_INFO(master, "Master thread exited.\n");
 
@@ -630,8 +752,13 @@ void ec_master_thread_stop(
     }
 
     // wait for FSM datagram
+#ifndef EC_USERMODE
     sleep_jiffies = max(HZ / 100, 1); // 10 ms, at least 1 jiffy
     schedule_timeout(sleep_jiffies);
+#else
+    sleep_jiffies = 10000000;
+    ec_nanosleep(sleep_jiffies);
+#endif
 }
 
 /****************************************************************************/
@@ -684,9 +811,9 @@ void ec_master_leave_idle_phase(ec_master_t *master /**< EtherCAT master */)
 #endif
     ec_master_thread_stop(master);
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
     ec_master_clear_slaves(master);
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     ec_fsm_master_reset(&master->fsm);
 }
@@ -709,11 +836,14 @@ int ec_master_enter_operation_phase(
 
     EC_MASTER_DBG(master, 1, "IDLE -> OPERATION.\n");
 
-    down(&master->config_sem);
+    ec_lock_down(&master->config_sem);
     if (master->config_busy) {
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
 
         // wait for slave configuration to complete
+#ifdef EC_USERMODE
+        while(atomic_load((atomic_bool*)&master->config_busy) == true){sched_yield();};
+#else
         ret = wait_event_interruptible(master->config_queue,
                     !master->config_busy);
         if (ret) {
@@ -721,21 +851,24 @@ int ec_master_enter_operation_phase(
                     " interrupted by signal.\n");
             goto out_return;
         }
-
+#endif
         EC_MASTER_DBG(master, 1, "Waiting for pending slave"
                 " configuration returned.\n");
     } else {
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
     }
 
-    down(&master->scan_sem);
+    ec_lock_down(&master->scan_sem);
     master->allow_scan = 0; // 'lock' the slave list
     if (!master->scan_busy) {
-        up(&master->scan_sem);
+        ec_lock_up(&master->scan_sem);
     } else {
-        up(&master->scan_sem);
+        ec_lock_up(&master->scan_sem);
 
         // wait for slave scan to complete
+#ifdef EC_USERMODE
+        while(atomic_load((atomic_bool*)&master->scan_busy) == true){sched_yield();};
+#else
         ret = wait_event_interruptible(master->scan_queue,
                 !master->scan_busy);
         if (ret) {
@@ -743,7 +876,7 @@ int ec_master_enter_operation_phase(
                     " interrupted by signal.\n");
             goto out_allow;
         }
-
+#endif
         EC_MASTER_DBG(master, 1, "Waiting for pending"
                 " slave scan returned.\n");
     }
@@ -866,6 +999,9 @@ void ec_master_inject_external_datagrams(
             if (cycles_now - datagram->cycles_sent
                     > ext_injection_timeout_cycles)
 #else
+#ifdef EC_USERMODE
+            uint64_t jiffies = get_jiffies();
+#endif
             if (jiffies - datagram->jiffies_sent
                     > ext_injection_timeout_jiffies)
 #endif
@@ -877,6 +1013,10 @@ void ec_master_inject_external_datagrams(
                 datagram->state = EC_DATAGRAM_ERROR;
 
 #if defined EC_RT_SYSLOG || DEBUG_INJECT
+#ifdef EC_USERMODE
+                time_us = (unsigned int)
+                    ((jiffies - datagram->jiffies_sent) * 1000000 / NSEC_PER_SEC);
+#else
 #ifdef EC_HAVE_CYCLES
                 time_us = (unsigned int)
                     ((cycles_now - datagram->cycles_sent) * 1000LL)
@@ -884,6 +1024,7 @@ void ec_master_inject_external_datagrams(
 #else
                 time_us = (unsigned int)
                     ((jiffies - datagram->jiffies_sent) * 1000000 / HZ);
+#endif
 #endif
                 EC_MASTER_ERR(master, "Timeout %u us: Injecting"
                         " external datagram %s size=%zu,"
@@ -989,9 +1130,9 @@ void ec_master_queue_datagram_ext(
         ec_datagram_t *datagram /**< datagram */
         )
 {
-    down(&master->ext_queue_sem);
+    ec_lock_down(&master->ext_queue_sem);
     list_add_tail(&datagram->ext_queue, &master->ext_datagram_queue);
-    up(&master->ext_queue_sem);
+    ec_lock_up(&master->ext_queue_sem);
 }
 
 /****************************************************************************/
@@ -1102,7 +1243,11 @@ void ec_master_send_datagrams(
 #ifdef EC_HAVE_CYCLES
         cycles_sent = get_cycles();
 #endif
+#ifdef EC_USERMODE
+	jiffies_sent = get_jiffies();
+#else
         jiffies_sent = jiffies;
+#endif
 
         // set datagram states and sending timestamps
         list_for_each_entry_safe(datagram, next, &sent_datagrams, sent) {
@@ -1151,9 +1296,15 @@ void ec_master_receive_datagrams(
 
     if (unlikely(size < EC_FRAME_HEADER_SIZE)) {
         if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
+#ifndef EC_USERMODE
             EC_MASTER_DBG(master, 0, "Corrupted frame received"
                     " on %s (size %zu < %u byte):\n",
                     device->dev->name, size, EC_FRAME_HEADER_SIZE);
+#else
+            EC_MASTER_DBG(master, 0, "Corrupted frame received"
+                    " (size %zu < %u byte):\n",
+                    size, EC_FRAME_HEADER_SIZE);
+#endif
             ec_print_data(frame_data, size);
         }
         master->stats.corrupted++;
@@ -1171,10 +1322,17 @@ void ec_master_receive_datagrams(
 
     if (unlikely(frame_size > size)) {
         if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
+#ifndef EC_USERMODE
             EC_MASTER_DBG(master, 0, "Corrupted frame received"
                     " on %s (invalid frame size %zu for "
                     "received size %zu):\n", device->dev->name,
                     frame_size, size);
+#else
+            EC_MASTER_DBG(master, 0, "Corrupted frame received"
+                    "(invalid frame size %zu for "
+                    "received size %zu):\n",
+                    frame_size, size);
+#endif
             ec_print_data(frame_data, size);
         }
         master->stats.corrupted++;
@@ -1196,9 +1354,15 @@ void ec_master_receive_datagrams(
         if (unlikely(cur_data - frame_data
                      + data_size + EC_DATAGRAM_FOOTER_SIZE > size)) {
             if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
+#ifndef EC_USERMODE
                 EC_MASTER_DBG(master, 0, "Corrupted frame received"
                         " on %s (invalid data size %zu):\n",
                         device->dev->name, data_size);
+#else
+                EC_MASTER_DBG(master, 0, "Corrupted frame received"
+                        "(invalid data size %zu):\n",
+                        data_size);
+#endif
                 ec_print_data(frame_data, size);
             }
             master->stats.corrupted++;
@@ -1276,7 +1440,12 @@ void ec_master_receive_datagrams(
  */
 void ec_master_output_stats(ec_master_t *master /**< EtherCAT master */)
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    if (unlikely(jiffies - master->stats.output_jiffies >= NSEC_PER_SEC)) {
+#else
     if (unlikely(jiffies - master->stats.output_jiffies >= HZ)) {
+#endif
         master->stats.output_jiffies = jiffies;
 
         if (master->stats.timeouts) {
@@ -1346,7 +1515,12 @@ void ec_master_update_device_stats(
     unsigned int i, dev_idx;
 
     // frame statistics
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    if (likely(jiffies - s->jiffies < NSEC_PER_SEC)) {
+#else
     if (likely(jiffies - s->jiffies < HZ)) {
+#endif
         return;
     }
 
@@ -1387,7 +1561,7 @@ void ec_master_update_device_stats(
 /****************************************************************************/
 
 #ifdef EC_USE_HRTIMER
-
+#ifndef EC_USERMODE
 /*
  * Sleep related functions:
  */
@@ -1398,19 +1572,31 @@ static enum hrtimer_restart ec_master_nanosleep_wakeup(struct hrtimer *timer)
     struct task_struct *task = t->task;
 
     t->task = NULL;
+#ifndef EC_USERMODE
     if (task)
         wake_up_process(task);
+#endif
 
     return HRTIMER_NORESTART;
 }
 
 /****************************************************************************/
-
+#endif
 
 /****************************************************************************/
 
 void ec_master_nanosleep(const unsigned long nsecs)
 {
+#ifdef EC_USERMODE
+    struct timespec dt;
+    clock_gettime(CLOCK_MONOTONIC, &dt);
+    dt.tv_nsec += nsecs;
+    while (dt.tv_nsec >= NSEC_PER_SEC) {
+        dt.tv_nsec -= NSEC_PER_SEC;
+	dt.tv_sec++;
+    }
+    clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &dt, NULL);
+#else
     struct hrtimer_sleeper t;
     enum hrtimer_mode mode = HRTIMER_MODE_REL;
 
@@ -1430,6 +1616,7 @@ void ec_master_nanosleep(const unsigned long nsecs)
         mode = HRTIMER_MODE_ABS;
 
     } while (t.task && !signal_pending(current));
+#endif
 }
 
 #endif // EC_USE_HRTIMER
@@ -1537,23 +1724,40 @@ static int ec_master_idle_thread(void *priv_data)
 #endif
 
     // send interval in IDLE phase
+#ifdef EC_USERMODE
+    ec_master_set_send_interval(master, 1000);
+#else
     ec_master_set_send_interval(master, 1000000 / HZ);
+#endif
 
     EC_MASTER_DBG(master, 1, "Idle thread running with send interval = %u us,"
             " max data size=%zu\n", master->send_interval,
             master->max_queue_size);
 
+#ifdef EC_USERMODE
+    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);
+    while(master->thread_status) {
+#else
     while (!kthread_should_stop()) {
+#endif
         ec_datagram_output_stats(&master->fsm_datagram);
 
         // receive
+#ifdef EC_USERMODE
+        if (ec_lock_down_interruptible(&master->io_mutex))
+#else
         if (ec_rt_lock_interruptible(&master->io_mutex))
+#endif
             break;
         ecrt_master_receive(master);
+#ifdef EC_USERMODE
+        ec_lock_up(&master->io_mutex);
+#else
         rt_mutex_unlock(&master->io_mutex);
+#endif
 
         // execute master & slave state machines
-        if (down_interruptible(&master->master_sem)) {
+        if (ec_lock_down_interruptible(&master->master_sem)) {
             break;
         }
 
@@ -1561,39 +1765,62 @@ static int ec_master_idle_thread(void *priv_data)
 
         ec_master_exec_slave_fsms(master);
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
 
         // queue and send
+#ifdef EC_USERMODE
+        if (ec_lock_down_interruptible(&master->io_mutex))
+#else
         if (ec_rt_lock_interruptible(&master->io_mutex))
+#endif
             break;
         if (fsm_exec) {
             ec_master_queue_datagram(master, &master->fsm_datagram);
         }
+#ifdef EC_USERMODE
+        sent_bytes = ecrt_master_send(master);
+#else
         ecrt_master_send(master);
 #ifdef EC_USE_HRTIMER
         sent_bytes = master->devices[EC_DEVICE_MAIN].tx_skb[
             master->devices[EC_DEVICE_MAIN].tx_ring_index]->len;
 #endif
+#endif
+#ifdef EC_USERMODE
+        ec_lock_up(&master->io_mutex);
+#else
         rt_mutex_unlock(&master->io_mutex);
+#endif
 
         if (ec_fsm_master_idle(&master->fsm)) {
 #ifdef EC_USE_HRTIMER
             ec_master_nanosleep(master->send_interval * 1000);
+#else
+#ifdef EC_USERMODE
+            ec_nanosleep(1000000);
 #else
             set_current_state(TASK_INTERRUPTIBLE);
             schedule_timeout(1);
+#endif
 #endif
         } else {
 #ifdef EC_USE_HRTIMER
             ec_master_nanosleep(sent_bytes * EC_BYTE_TRANSMISSION_TIME_NS);
+#else
+#ifdef EC_USERMODE
+	          sched_yield();
 #else
             schedule();
+#endif
 #endif
         }
     }
 
     EC_MASTER_DBG(master, 1, "Master IDLE thread exiting...\n");
 
+#ifdef EC_USERMODE
+    pthread_exit(0);
+#endif
     return 0;
 }
 
@@ -1608,8 +1835,12 @@ static int ec_master_operation_thread(void *priv_data)
     EC_MASTER_DBG(master, 1, "Operation thread running"
             " with fsm interval = %u us, max data size=%zu\n",
             master->send_interval, master->max_queue_size);
-
+#ifdef EC_USERMODE
+    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);
+    while(master->thread_status) {
+#else
     while (!kthread_should_stop()) {
+#endif
         ec_datagram_output_stats(&master->fsm_datagram);
 
         if (master->injection_seq_rt == master->injection_seq_fsm) {
@@ -1617,7 +1848,7 @@ static int ec_master_operation_thread(void *priv_data)
             ec_master_output_stats(master);
 
             // execute master & slave state machines
-            if (down_interruptible(&master->master_sem)) {
+            if (ec_lock_down_interruptible(&master->master_sem)) {
                 break;
             }
 
@@ -1629,7 +1860,7 @@ static int ec_master_operation_thread(void *priv_data)
 
             ec_master_exec_slave_fsms(master);
 
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
         }
 
 #ifdef EC_USE_HRTIMER
@@ -1637,16 +1868,27 @@ static int ec_master_operation_thread(void *priv_data)
         ec_master_nanosleep(master->send_interval * 1000);
 #else
         if (ec_fsm_master_idle(&master->fsm)) {
+#ifdef EC_USERMODE
+            ec_nanosleep(1000000);
+#else
             set_current_state(TASK_INTERRUPTIBLE);
             schedule_timeout(1);
+#endif
         }
         else {
+#ifdef EC_USERMODE
+	    sched_yield();
+#else
             schedule();
+#endif
         }
 #endif
     }
 
     EC_MASTER_DBG(master, 1, "Master OP thread exiting...\n");
+#ifdef EC_USERMODE
+    pthread_exit(0);
+#endif
     return 0;
 }
 
@@ -1672,6 +1914,11 @@ static inline void set_normal_priority(struct task_struct *p, int nice)
  */
 void ec_master_eoe_start(ec_master_t *master /**< EtherCAT master */)
 {
+#ifdef EC_USERMODE
+    int ret;
+    pthread_attr_t attr;
+    struct sched_param schparam;
+#endif
     if (master->eoe_thread) {
         EC_MASTER_WARN(master, "EoE already running!\n");
         return;
@@ -1687,6 +1934,34 @@ void ec_master_eoe_start(ec_master_t *master /**< EtherCAT master */)
     }
 
     EC_MASTER_INFO(master, "Starting EoE thread.\n");
+#ifdef EC_USERMODE
+    master->eoe_thread = calloc(1,sizeof(pthread_t));
+    if (master->eoe_thread == NULL) {
+	    EC_MASTER_ERR(master, "Failed to calloc eoe thread!\n");
+	    return;
+    }
+    pthread_attr_init(&attr);
+    ret = pthread_create(master->eoe_thread, &thattr, ec_master_eoe_thread, master);
+    pthread_attr_destroy(&attr);
+    if (ret != 0) {
+            EC_MASTER_ERR(master, "Failed to start eoe thread (error %i)!\n",
+		    ret);
+	    free(master->eoe_thread);
+	    master->eoe_thread = NULL;
+	    return;
+    }
+    memset(&schparam, 0, sizeof(schparam));
+    schparam.sched_priority = 0;
+    ret = pthread_setschedparam(*master->eoe_thread, SCHED_FIFO, &schparam);
+    if (ret < 0) {
+            EC_MASTER_ERR(master, "Failed to set thread as SCHED_FIFO (error %i)!\n",
+		    ret);
+	    free(master->eoe_thread);
+	    master->eoe_thread = NULL;
+	    return;
+    }
+#else
+
     master->eoe_thread = kthread_run(ec_master_eoe_thread, master,
             "EtherCAT-EoE");
     if (IS_ERR(master->eoe_thread)) {
@@ -1698,6 +1973,7 @@ void ec_master_eoe_start(ec_master_t *master /**< EtherCAT master */)
     }
 
     set_normal_priority(master->eoe_thread, 0);
+#endif
 }
 
 /****************************************************************************/
@@ -1709,7 +1985,13 @@ void ec_master_eoe_stop(ec_master_t *master /**< EtherCAT master */)
     if (master->eoe_thread) {
         EC_MASTER_INFO(master, "Stopping EoE thread.\n");
 
+#ifdef EC_USERMODE
+        pthread_cancel(*master->eoe_thread);
+        pthread_join(*master->eoe_thread, NULL);
+        free(master->eoe_thread);
+#else
         kthread_stop(master->eoe_thread);
+#endif
         master->eoe_thread = NULL;
         EC_MASTER_INFO(master, "EoE thread exited.\n");
     }
@@ -1727,7 +2009,11 @@ static int ec_master_eoe_thread(void *priv_data)
 
     EC_MASTER_DBG(master, 1, "EoE thread running.\n");
 
+#ifdef EC_USERMODE
+    while (1) {
+#else
     while (!kthread_should_stop()) {
+#endif
         none_open = 1;
         all_idle = 1;
 
@@ -1765,10 +2051,18 @@ static int ec_master_eoe_thread(void *priv_data)
 
 schedule:
         if (all_idle) {
+#ifdef EC_USERMODE
+            ec_nanosleep(1000000);
+#else
             set_current_state(TASK_INTERRUPTIBLE);
             schedule_timeout(1);
+#endif
         } else {
+#ifdef EC_USERMODE
+	    sched_yield();
+#else
             schedule();
+#endif
         }
     }
 
@@ -2259,12 +2553,16 @@ ec_domain_t *ecrt_master_create_domain_err(
             master);
 
     if (!(domain =
+#ifdef EC_USERMODE
+                (ec_domain_t *) malloc(sizeof(ec_domain_t)))) {
+#else
                 (ec_domain_t *) kmalloc(sizeof(ec_domain_t), GFP_KERNEL))) {
+#endif
         EC_MASTER_ERR(master, "Error allocating domain memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
 
     if (list_empty(&master->domains)) {
         index = 0;
@@ -2276,7 +2574,7 @@ ec_domain_t *ecrt_master_create_domain_err(
     ec_domain_init(domain, master, index);
     list_add_tail(&domain->list, &master->domains);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     EC_MASTER_DBG(master, 1, "Created domain %u.\n", domain->index);
 
@@ -2311,21 +2609,21 @@ int ecrt_master_activate(ec_master_t *master)
         return 0;
     }
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
 
     // finish all domains
     domain_offset = 0;
     list_for_each_entry(domain, &master->domains, list) {
         ret = ec_domain_finish(domain, domain_offset);
         if (ret < 0) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_MASTER_ERR(master, "Failed to finish domain 0x%p!\n", domain);
             return ret;
         }
         domain_offset += domain->data_size;
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // restart EoE process and master thread with new locking
 
@@ -2442,6 +2740,24 @@ int ecrt_master_deactivate(ec_master_t *master)
 
 int ecrt_master_send(ec_master_t *master)
 {
+
+#ifdef EC_BENCHMARK
+    ec_device_t *dev;
+    unsigned int op_state = 1;
+    struct timespec tx_start_time, tx_end_time;
+    uint64_t tx_start, tx_end, tx_sw_end;
+    u64 tx_latency[3];
+    u64 i; 
+    for(i = 0; i < EC_MAX_NUM_DEVICES; i++) {
+        if(master->fsm.slave_states[i] != EC_SLAVE_STATE_OP)
+            op_state = 0;
+    }
+    
+    if(op_state == 1) {
+        clock_gettime(CLOCK_MONOTONIC, &tx_start_time);
+    }
+    
+#endif
     ec_datagram_t *datagram, *n;
     ec_device_index_t dev_idx;
 
@@ -2479,6 +2795,36 @@ int ecrt_master_send(ec_master_t *master)
 
         // send frames
         ec_master_send_datagrams(master, dev_idx);
+#ifdef EC_BENCHMARK
+        if(op_state == 1) {
+            dev = &master->devices[dev_idx];
+            clock_gettime(CLOCK_MONOTONIC, &tx_end_time);
+            tx_sw_end = dev->dev->dpdk_tx_sw_end_time;
+            tx_start = TIMESPEC2NS(tx_start_time);
+            tx_end = TIMESPEC2NS(tx_end_time);
+            /* tx total latency */
+            tx_latency[0] = tx_end - tx_start;
+            /* tx sw latency */
+            tx_latency[1] = tx_sw_end - tx_start;
+            /* tx hw latency */
+            tx_latency[2] = tx_end - tx_sw_end;
+/*
+  NUM_TX_LATENCY 0: tx total latency
+  NUM_TX_LATENCY 1: tx sw latency
+  NUM_TX_LATENCY 2: tx hw latency
+  NUM_RX_LATENCY 0: rx sw latency
+*/
+
+            for(i = 0; i < NUM_TX_LATENCY; i++) {
+                if(dev->tx_latency[i][0] > tx_latency[i])
+                    dev->tx_latency[i][0] = tx_latency[i];
+                if(dev->tx_latency[i][1] < tx_latency[i])
+                    dev->tx_latency[i][1] = tx_latency[i];
+                dev->tx_latency[i][2] += tx_latency[i];
+            }
+            dev->tx_cnt++;
+        }
+#endif
     }
     return 0;
 }
@@ -2487,6 +2833,22 @@ int ecrt_master_send(ec_master_t *master)
 
 int ecrt_master_receive(ec_master_t *master)
 {
+
+#ifdef EC_BENCHMARK
+    ec_device_t *dev;
+    unsigned int op_state = 1;
+    struct timespec rx_start_time, rx_end_time;
+    uint64_t rx_hw_end;
+    // NUM_RX_LATENCY 0: rx sw latency
+    u64 rx_latency[NUM_RX_LATENCY];
+    for(int i = 0; i < EC_MAX_NUM_DEVICES; i++) {
+        if(master->fsm.slave_states[i] != EC_SLAVE_STATE_OP)
+            op_state = 0;
+    }
+    if(op_state == 1) {
+        clock_gettime(CLOCK_MONOTONIC, &rx_start_time);
+    }
+#endif
     unsigned int dev_idx;
     ec_datagram_t *datagram, *next;
 
@@ -2494,6 +2856,24 @@ int ecrt_master_receive(ec_master_t *master)
     for (dev_idx = EC_DEVICE_MAIN; dev_idx < ec_master_num_devices(master);
             dev_idx++) {
         ec_device_poll(&master->devices[dev_idx]);
+#ifdef EC_BENCHMARK
+        if(op_state == 1) {
+	        dev = &master->devices[dev_idx];
+            clock_gettime(CLOCK_MONOTONIC, &rx_end_time);
+	        rx_hw_end = dev->dev->dpdk_rx_hw_end_time;
+            /* rx sw latency */
+            rx_latency[0] = TIMESPEC2NS(rx_end_time) - TIMESPEC2NS(rx_start_time);
+            rx_latency[1] = TIMESPEC2NS(rx_end_time) - rx_hw_end;
+            for(int i = 0; i < NUM_RX_LATENCY; i++) {
+                if(dev->rx_latency[i][0] > rx_latency[i])
+                    dev->rx_latency[i][0] = rx_latency[i];
+                if(dev->rx_latency[i][1] < rx_latency[i])
+                    dev->rx_latency[i][1] = rx_latency[i];
+                dev->rx_latency[i][2] += rx_latency[i];
+            }
+            dev->rx_cnt++;
+        }
+#endif
     }
     ec_master_update_device_stats(master);
 
@@ -2517,6 +2897,11 @@ int ecrt_master_receive(ec_master_t *master)
 
             if (unlikely(master->debug_level > 0)) {
                 unsigned int time_us;
+#ifdef EC_USERMODE
+                time_us = (unsigned int)
+			((master->devices[EC_DEVICE_MAIN].jiffies_poll -
+			 datagram->jiffies_sent)/1000);
+#else
 #ifdef EC_HAVE_CYCLES
                 time_us = (unsigned int)
                     (master->devices[EC_DEVICE_MAIN].cycles_poll -
@@ -2525,6 +2910,7 @@ int ecrt_master_receive(ec_master_t *master)
                 time_us = (unsigned int)
                     ((master->devices[EC_DEVICE_MAIN].jiffies_poll -
                             datagram->jiffies_sent) * 1000000 / HZ);
+#endif
 #endif
                 EC_MASTER_DBG(master, 0, "TIMED OUT datagram %p,"
                         " index %02X waited %u us.\n",
@@ -2542,15 +2928,19 @@ int ecrt_master_send_ext(ec_master_t *master)
 {
     ec_datagram_t *datagram, *next;
 
+#ifdef EC_USERMODE
+		ec_lock_down(&master->ext_queue_sem)
+#else
     if (down_trylock(&master->ext_queue_sem))
         return -EAGAIN;
+#endif
 
     list_for_each_entry_safe(datagram, next, &master->ext_datagram_queue,
             ext_queue) {
         list_del_init(&datagram->ext_queue);
         ec_master_queue_datagram(master, datagram);
     }
-    up(&master->ext_queue_sem);
+    ec_lock_up(&master->ext_queue_sem);
 
     return ecrt_master_send(master);
 }
@@ -2591,9 +2981,12 @@ ec_slave_config_t *ecrt_master_slave_config_err(ec_master_t *master,
         EC_MASTER_DBG(master, 1, "Creating slave configuration for %u:%u,"
                 " 0x%08X/0x%08X.\n",
                 alias, position, vendor_id, product_code);
-
+#ifdef EC_USERMODE
+        if (!(sc = (ec_slave_config_t *) malloc(sizeof(ec_slave_config_t)))) {
+#else
         if (!(sc = (ec_slave_config_t *) kmalloc(sizeof(ec_slave_config_t),
                         GFP_KERNEL))) {
+#endif
             EC_MASTER_ERR(master, "Failed to allocate memory"
                     " for slave configuration.\n");
             return ERR_PTR(-ENOMEM);
@@ -2602,14 +2995,14 @@ ec_slave_config_t *ecrt_master_slave_config_err(ec_master_t *master,
         ec_slave_config_init(sc, master,
                 alias, position, vendor_id, product_code);
 
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
 
         // try to find the addressed slave
         ec_slave_config_attach(sc);
         ec_slave_config_load_default_sync_config(sc);
         list_add_tail(&sc->list, &master->configs);
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     return sc;
@@ -2682,7 +3075,7 @@ int ecrt_master_get_slave(ec_master_t *master, uint16_t slave_position,
     unsigned int i;
     int ret = 0;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
@@ -2730,7 +3123,7 @@ int ecrt_master_get_slave(ec_master_t *master, uint16_t slave_position,
     }
 
 out_get_slave:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return ret;
 }
@@ -2911,13 +3304,13 @@ int ecrt_master_sdo_download(ec_master_t *master, uint16_t slave_position,
     request.data_size = data_size;
     ecrt_sdo_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -2928,32 +3321,41 @@ int ecrt_master_sdo_download(ec_master_t *master, uint16_t slave_position,
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     *abort_code = request.abort_code;
 
     if (request.state == EC_INT_REQUEST_SUCCESS) {
         ret = 0;
-    } else if (request.errno) {
-        ret = -request.errno;
+    } else if (request.err) {
+        ret = -request.err;
     } else {
         ret = -EIO;
     }
@@ -2991,13 +3393,13 @@ int ecrt_master_sdo_download_complete(ec_master_t *master,
     request.data_size = data_size;
     ecrt_sdo_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -3009,32 +3411,41 @@ int ecrt_master_sdo_download_complete(ec_master_t *master,
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     *abort_code = request.abort_code;
 
     if (request.state == EC_INT_REQUEST_SUCCESS) {
         ret = 0;
-    } else if (request.errno) {
-        ret = -request.errno;
+    } else if (request.err) {
+        ret = -request.err;
     } else {
         ret = -EIO;
     }
@@ -3064,13 +3475,13 @@ int ecrt_master_sdo_upload(ec_master_t *master, uint16_t slave_position,
     ecrt_sdo_request_index(&request, index, subindex);
     ecrt_sdo_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_sdo_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3081,32 +3492,41 @@ int ecrt_master_sdo_upload(ec_master_t *master, uint16_t slave_position,
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     *abort_code = request.abort_code;
 
     if (request.state != EC_INT_REQUEST_SUCCESS) {
         *result_size = 0;
-        if (request.errno) {
-            ret = -request.errno;
+        if (request.err) {
+            ret = -request.err;
         } else {
             ret = -EIO;
         }
@@ -3155,13 +3575,13 @@ int ecrt_master_write_idn(ec_master_t *master, uint16_t slave_position,
     request.data_size = data_size;
     ec_soe_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_soe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 slave_position);
         ec_soe_request_clear(&request);
@@ -3173,25 +3593,34 @@ int ecrt_master_write_idn(ec_master_t *master, uint16_t slave_position,
     // schedule SoE write request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     if (error_code) {
         *error_code = request.error_code;
@@ -3222,13 +3651,13 @@ int ecrt_master_read_idn(ec_master_t *master, uint16_t slave_position,
     ec_soe_request_set_idn(&request, idn);
     ec_soe_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_soe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_soe_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3239,25 +3668,34 @@ int ecrt_master_read_idn(ec_master_t *master, uint16_t slave_position,
     // schedule request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) == EC_INT_REQUEST_QUEUED);
+    {
+#else
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
+#endif
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
+#ifdef EC_USERMODE
+    while(atomic_load((atomic_int*)&request.state) <= EC_INT_REQUEST_BUSY);
+#else
     wait_event(master->request_queue, request.state != EC_INT_REQUEST_BUSY);
+#endif
 
     if (error_code) {
         *error_code = request.error_code;
@@ -3301,7 +3739,7 @@ int ecrt_master_reset(ec_master_t *master)
 }
 
 /****************************************************************************/
-
+#ifndef EC_USERMODE
 static void sc_reset_task_kicker(struct irq_work *work)
 {
     struct ec_master *master =
@@ -3320,11 +3758,11 @@ static void sc_reset_task(struct work_struct *work)
     ecrt_master_reset(master);
     up(&master->master_sem);
 }
-
+#endif
 /****************************************************************************/
 
 /** \cond */
-
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_master_create_domain);
 EXPORT_SYMBOL(ecrt_master_activate);
 EXPORT_SYMBOL(ecrt_master_deactivate);
@@ -3352,7 +3790,7 @@ EXPORT_SYMBOL(ecrt_master_sdo_upload);
 EXPORT_SYMBOL(ecrt_master_write_idn);
 EXPORT_SYMBOL(ecrt_master_read_idn);
 EXPORT_SYMBOL(ecrt_master_reset);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/master.h b/master/master.h
index 77bd97be..56f91c77 100644
--- a/master/master.h
+++ b/master/master.h
@@ -29,6 +29,11 @@
 #ifndef __EC_MASTER_H__
 #define __EC_MASTER_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include <pthread.h>
+#else
 #include <linux/version.h>
 #include <linux/irq_work.h>
 #include <linux/list.h>
@@ -37,12 +42,23 @@
 #include <linux/kthread.h>
 #include <linux/rtmutex.h>
 #include <linux/workqueue.h>
+#endif
 
 #include "device.h"
 #include "domain.h"
 #include "ethernet.h"
 #include "fsm_master.h"
+
+#include "rt_locks.h"
+
+#ifndef EC_USERMODE
 #include "cdev.h"
+#else
+#include <mqueue.h>
+#include "wq.h"
+#include "ioctl.h"
+#include "ecrt_config.h"
+#endif
 
 #ifdef EC_RTDM
 #include "rtdm.h"
@@ -60,7 +76,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_INFO(master, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u: " fmt, master->index, ##args)
+    ec_print(EC_INFO_LEVEL "EtherCAT %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific errors to syslog.
  *
@@ -72,7 +88,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_ERR(master, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u: " fmt, master->index, ##args)
+    ec_print(EC_ERR_LEVEL "EtherCAT ERROR %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific warnings to syslog.
  *
@@ -84,7 +100,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_WARN(master, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u: " fmt, master->index, ##args)
+    ec_print(EC_WARNING_LEVEL "EtherCAT WARNING %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific debug messages to syslog.
  *
@@ -100,7 +116,7 @@
 #define EC_MASTER_DBG(master, level, fmt, args...) \
     do { \
         if (master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u: " fmt, \
+            ec_print(EC_DEBUG_LEVEL "EtherCAT DEBUG %u: " fmt, \
                     master->index, ##args); \
         } \
     } while (0)
@@ -174,7 +190,11 @@ typedef struct {
 #error Invalid number of devices
 #endif
 
-/****************************************************************************/
+#ifdef EC_USERMODE
+#define EC_MASTER_ETHERCAT_THREAD_PRIO        (40)
+#define EC_MASTER_IPC_THREAD_PRIO             (EC_MASTER_ETHERCAT_THREAD_PRIO-1)
+#endif
+/*****************************************************************************/
 
 /** EtherCAT master.
  *
@@ -184,14 +204,21 @@ struct ec_master {
     unsigned int index; /**< Index. */
     unsigned int reserved; /**< \a True, if the master is in use. */
 
+#ifndef EC_USERMODE
     ec_cdev_t cdev; /**< Master character device. */
     struct device *class_device; /**< Master class device. */
-
+#else
+    char *confname; /* ecrt master configuration filename */
+    struct ecrt_config *ecrt_conf;
+    char* ipcs; /**< ipc service device. */
+    int seg_id;
+    ec_ioctl_context_t ctx;
+#endif
 #ifdef EC_RTDM
     ec_rtdm_dev_t rtdm_dev; /**< RTDM device. */
 #endif
 
-    struct semaphore master_sem; /**< Master semaphore. */
+    ec_lock_t master_sem; /**< Master semaphore. */
 
     ec_device_t devices[EC_MAX_NUM_DEVICES]; /**< EtherCAT devices. */
     const uint8_t *macs[EC_MAX_NUM_DEVICES]; /**< Device MAC addresses. */
@@ -200,7 +227,7 @@ struct ec_master {
                                 ec_master_num_devices(), because it may be
                                 optimized! */
 #endif
-    struct semaphore device_sem; /**< Device semaphore. */
+    ec_lock_t device_sem; /**< Device semaphore. */
     ec_device_stats_t device_stats; /**< Device statistics. */
 
     ec_fsm_master_t fsm; /**< Master state machine. */
@@ -235,13 +262,13 @@ struct ec_master {
     unsigned int scan_busy; /**< Current scan state. */
     unsigned int scan_index; /**< Index of slave currently scanned. */
     unsigned int allow_scan; /**< \a True, if slave scanning is allowed. */
-    struct semaphore scan_sem; /**< Semaphore protecting the \a scan_busy
+    ec_lock_t scan_sem; /**< Semaphore protecting the \a scan_busy
                                  variable and the \a allow_scan flag. */
     wait_queue_head_t scan_queue; /**< Queue for processes that wait for
                                     slave scanning. */
 
     unsigned int config_busy; /**< State of slave configuration. */
-    struct semaphore config_sem; /**< Semaphore protecting the \a config_busy
+    ec_lock_t config_sem; /**< Semaphore protecting the \a config_busy
                                    variable and the allow_config flag. */
     wait_queue_head_t config_queue; /**< Queue for processes that wait for
                                       slave configuration. */
@@ -251,7 +278,7 @@ struct ec_master {
 
     struct list_head ext_datagram_queue; /**< Queue for non-application
                                            datagrams. */
-    struct semaphore ext_queue_sem; /**< Semaphore protecting the \a
+    ec_lock_t ext_queue_sem; /**< Semaphore protecting the \a
                                       ext_datagram_queue. */
 
     ec_datagram_t ext_datagram_ring[EC_EXT_RING_SIZE]; /**< External datagram
@@ -272,14 +299,32 @@ struct ec_master {
     unsigned int run_on_cpu;  /**< bind kernel threads to this cpu */
     ec_stats_t stats; /**< Cyclic statistics. */
 
+#ifdef EC_USERMODE
+    pthread_t* thread; /**< Master thread. */
+    unsigned char thread_status; /* Master thread status*/
+#if !EC_ENABLE_DAEMON
+    pthread_t* ipc_thread; /**< IPC thread. */
+    unsigned char ipc_thread_status; /* IPC thread status*/
+#endif
+#else
     struct task_struct *thread; /**< Master thread. */
+#endif
 
 #ifdef EC_EOE
+#ifdef EC_USERMODE
+    pthread_t* eoe_thread; /**< EoE thread. */
+    unsigned char eoe_thread_status; /* EoE thread status*/
+#else
     struct task_struct *eoe_thread; /**< EoE thread. */
+#endif
     struct list_head eoe_handlers; /**< Ethernet over EtherCAT handlers. */
 #endif
 
-    struct rt_mutex io_mutex;  /**< Mutex used in \a IDLE and \a OP phase. */
+#ifdef EC_USERMODE
+    ec_lock_t io_mutex; /**< Semaphore used in \a IDLE and \a OP phase. */
+#else
+    struct rt_mutex io_mutex; /**< Semaphore used in \a IDLE and \a OP phase. */
+#endif
 
     void (*send_cb)(void *); /**< Current send datagrams callback. */
     void (*receive_cb)(void *); /**< Current receive datagrams callback. */
@@ -296,9 +341,11 @@ struct ec_master {
 
     wait_queue_head_t request_queue; /**< Wait queue for external requests
                                        from user space. */
+#ifndef EC_USERMODE
     struct work_struct sc_reset_work; /**< Task to reset slave configuration. */
     struct irq_work sc_reset_work_kicker; /**< NMI-Safe kicker to trigger
                                             reset task above. */
+#endif
 };
 
 /****************************************************************************/
@@ -308,7 +355,19 @@ void ec_master_init_static(void);
 
 // master creation/deletion
 int ec_master_init(ec_master_t *, unsigned int, const uint8_t *,
-        const uint8_t *, dev_t, struct class *, unsigned int, unsigned int);
+    const uint8_t *,
+#ifndef EC_USERMODE
+    dev_t, struct class *,
+#endif
+    unsigned int
+#ifndef EC_USERMODE
+    ,unsigned int
+#endif
+#ifdef EC_USERMODE
+    , char*
+#endif
+);
+
 void ec_master_clear(ec_master_t *);
 
 /** Number of Ethernet devices.
diff --git a/master/mm.h b/master/mm.h
new file mode 100644
index 00000000..42f33a43
--- /dev/null
+++ b/master/mm.h
@@ -0,0 +1,72 @@
+#ifndef __EC_MM_H__
+#define __EC_MM_H__
+
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include <stdio.h>
+
+/*****************************************************************************/
+
+#define GFP_KERNEL  0
+
+#ifndef ENOMEM
+#define ENOMEM	12
+#endif
+#ifndef ENOENT
+#define ENOENT	2
+#endif
+#ifndef ENODEV
+#define ENODEV  19
+#endif
+#ifndef EINVAL
+#define EINVAL  22
+#endif
+#endif
+
+
+typedef struct sk_buff{
+	  void* data;
+	  uint16_t len;
+};
+
+static inline void* ec_malloc( size_t size, int flag) {
+    struct sk_buff *buff;
+    buff = (struct sk_buff *)malloc(sizeof(struct sk_buff));
+    buff->data = (void *)malloc(size);
+    buff->len = size;
+    return buff;
+}
+
+static inline void ec_free(void *p) {
+    if (p) {
+	      struct sk_buff *buff = (struct sk_buff*)p;
+	      if (buff->data) {
+	          free(buff->data);
+	          buff->data = NULL;
+	      }
+        free(p);
+	      p = NULL;
+    }
+}
+
+static inline void* ec_skb_push(void *p, size_t size)
+{
+    if (!p)
+        return NULL;
+    struct sk_buff *skb = (struct sk_buff*)p;
+    skb->data -= size;
+    skb->len += size;
+    return skb->data;
+}
+
+static inline void* ec_reserve( void* p, size_t n) {
+    struct sk_buff *buff = (struct sk_buff *)p;
+    buff->data += n;
+    buff->len -= n;
+    return (void*)buff;
+}
+
+/*****************************************************************************/
+
+#endif
diff --git a/master/module.c b/master/module.c
index 3e81f25e..3812903d 100644
--- a/master/module.c
+++ b/master/module.c
@@ -23,13 +23,12 @@
  * EtherCAT master driver module.
  */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/err.h>
-
-#include "globals.h"
 #include "master.h"
 #include "device.h"
 
@@ -60,11 +59,10 @@ static unsigned int run_on_cpu = 0xffffffff; /**< Bind created kernel threads
                                               */
 
 static ec_master_t *masters; /**< Array of masters. */
-static struct semaphore master_sem; /**< Master semaphore. */
+static ec_lock_t master_sem; /**< Master semaphore. */
 
 dev_t device_number; /**< Device number for master cdevs. */
 struct class *class; /**< Device class. */
-
 static uint8_t macs[MAX_MASTERS][2][ETH_ALEN]; /**< MAC addresses. */
 
 char *ec_master_version_str = EC_MASTER_VERSION; /**< Version string. */
@@ -73,7 +71,7 @@ char *ec_master_version_str = EC_MASTER_VERSION; /**< Version string. */
 
 /** \cond */
 
-MODULE_AUTHOR("Florian Pose <fp@igh.de>");
+MODULE_AUTHOR("Florian Pose <fp@igh-essen.com>");
 MODULE_DESCRIPTION("EtherCAT master driver module");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(EC_MASTER_VERSION);
@@ -86,7 +84,6 @@ module_param_named(debug_level, debug_level, uint, S_IRUGO);
 MODULE_PARM_DESC(debug_level, "Debug level");
 module_param_named(run_on_cpu, run_on_cpu, uint, S_IRUGO);
 MODULE_PARM_DESC(run_on_cpu, "Bind kthreads to a specific cpu");
-
 /** \endcond */
 
 /****************************************************************************/
@@ -102,7 +99,7 @@ int __init ec_init_module(void)
 
     EC_INFO("Master driver %s\n", EC_MASTER_VERSION);
 
-    sema_init(&master_sem, 1);
+    ec_lock_init(&master_sem);
 
     if (master_count) {
         if (alloc_chrdev_region(&device_number,
@@ -493,7 +490,7 @@ ec_device_t *ecdev_offer(
         master = &masters[i];
         ec_mac_print(net_dev->dev_addr, str);
 
-        if (down_interruptible(&master->device_sem)) {
+        if (ec_lock_down_interruptible(&master->device_sem)) {
             EC_MASTER_WARN(master, "%s() interrupted!\n", __func__);
             return NULL;
         }
@@ -509,7 +506,7 @@ ec_device_t *ecdev_offer(
 
                 ec_device_attach(&master->devices[dev_idx],
                         net_dev, poll, module);
-                up(&master->device_sem);
+                ec_lock_up(&master->device_sem);
 
                 snprintf(net_dev->name, IFNAMSIZ, "ec%c%u",
                         ec_device_names[dev_idx != 0][0], master->index);
@@ -518,7 +515,7 @@ ec_device_t *ecdev_offer(
             }
         }
 
-        up(&master->device_sem);
+        ec_lock_up(&master->device_sem);
 
         EC_MASTER_DBG(master, 1, "Master declined device %s.\n", str);
     }
@@ -552,27 +549,27 @@ ec_master_t *ecrt_request_master_err(
     }
     master = &masters[master_index];
 
-    if (down_interruptible(&master_sem)) {
+    if (ec_lock_down_interruptible(&master_sem)) {
         errptr = ERR_PTR(-EINTR);
         goto out_return;
     }
 
     if (master->reserved) {
-        up(&master_sem);
+        ec_lock_up(&master_sem);
         EC_MASTER_ERR(master, "Master already in use!\n");
         errptr = ERR_PTR(-EBUSY);
         goto out_return;
     }
     master->reserved = 1;
-    up(&master_sem);
+    ec_lock_up(&master_sem);
 
-    if (down_interruptible(&master->device_sem)) {
+    if (ec_lock_down_interruptible(&master->device_sem)) {
         errptr = ERR_PTR(-EINTR);
         goto out_release;
     }
 
     if (master->phase != EC_IDLE) {
-        up(&master->device_sem);
+        ec_lock_up(&master->device_sem);
         EC_MASTER_ERR(master, "Master still waiting for devices!\n");
         errptr = ERR_PTR(-ENODEV);
         goto out_release;
@@ -581,14 +578,14 @@ ec_master_t *ecrt_request_master_err(
     for (; dev_idx < ec_master_num_devices(master); dev_idx++) {
         ec_device_t *device = &master->devices[dev_idx];
         if (!try_module_get(device->module)) {
-            up(&master->device_sem);
+            ec_lock_up(&master->device_sem);
             EC_MASTER_ERR(master, "Device module is unloading!\n");
             errptr = ERR_PTR(-ENODEV);
             goto out_module_put;
         }
     }
 
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 
     if (ec_master_enter_operation_phase(master)) {
         EC_MASTER_ERR(master, "Failed to enter OPERATION phase!\n");
diff --git a/master/pdo.c b/master/pdo.c
index 9c145939..034241fe 100644
--- a/master/pdo.c
+++ b/master/pdo.c
@@ -24,10 +24,14 @@
    EtherCAT process data object methods.
 */
 
-/****************************************************************************/
-
+/*****************************************************************************/
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/slab.h>
 #include <linux/err.h>
+#else
+#include "mm.h"
+#endif
 
 #include "pdo.h"
 
@@ -86,7 +90,11 @@ out_return:
 void ec_pdo_clear(ec_pdo_t *pdo /**< EtherCAT PDO. */)
 {
     if (pdo->name)
+#ifdef EC_USERMODE
+        free(pdo->name);
+#else
         kfree(pdo->name);
+#endif
 
     ec_pdo_clear_entries(pdo);
 }
@@ -103,7 +111,11 @@ void ec_pdo_clear_entries(ec_pdo_t *pdo /**< EtherCAT PDO. */)
     list_for_each_entry_safe(entry, next, &pdo->entries, list) {
         list_del(&entry->list);
         ec_pdo_entry_clear(entry);
+#ifdef EC_USERMODE
+        free(entry);
+#else
         kfree(entry);
+#endif
     }
 }
 
@@ -125,10 +137,18 @@ int ec_pdo_set_name(
         return 0;
 
     if (pdo->name)
+#ifdef EC_USERMODE
+        free(pdo->name);
+#else
         kfree(pdo->name);
+#endif
 
     if (name && (len = strlen(name))) {
+#ifdef EC_USERMODE
+        if (!(pdo->name = (char *) malloc(len + 1))) {
+#else
         if (!(pdo->name = (char *) kmalloc(len + 1, GFP_KERNEL))) {
+#endif
             EC_ERR("Failed to allocate PDO name.\n");
             return -ENOMEM;
         }
@@ -154,8 +174,11 @@ ec_pdo_entry_t *ec_pdo_add_entry(
         )
 {
     ec_pdo_entry_t *entry;
-
+#ifdef EC_USERMODE
+    if (!(entry = malloc(sizeof(ec_pdo_entry_t)))) {
+#else
     if (!(entry = kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate memory for PDO entry.\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -186,15 +209,24 @@ int ec_pdo_copy_entries(
     ec_pdo_clear_entries(pdo);
 
     list_for_each_entry(other_entry, &other->entries, list) {
+#ifdef EC_USERMODE
+        if (!(entry = (ec_pdo_entry_t *)
+                    malloc(sizeof(ec_pdo_entry_t)))) {
+#else
         if (!(entry = (ec_pdo_entry_t *)
                     kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+#endif
             EC_ERR("Failed to allocate memory for PDO entry copy.\n");
             return -ENOMEM;
         }
 
         ret = ec_pdo_entry_init_copy(entry, other_entry);
         if (ret < 0) {
+#ifdef EC_USERMODE
+            free(entry);
+#else
             kfree(entry);
+#endif
             return ret;
         }
 
@@ -295,13 +327,13 @@ void ec_pdo_print_entries(
     const ec_pdo_entry_t *entry;
 
     if (list_empty(&pdo->entries)) {
-        printk(KERN_CONT "(none)");
+        ec_print(EC_CONT "(none)");
     } else {
         list_for_each_entry(entry, &pdo->entries, list) {
-            printk(KERN_CONT "0x%04X:%02X/%u",
+            ec_print(EC_CONT "0x%04X:%02X/%u",
                     entry->index, entry->subindex, entry->bit_length);
             if (entry->list.next != &pdo->entries)
-                printk(KERN_CONT " ");
+                ec_print(EC_CONT " ");
         }
     }
 }
diff --git a/master/pdo.h b/master/pdo.h
index 1819c836..f2aa3225 100644
--- a/master/pdo.h
+++ b/master/pdo.h
@@ -29,9 +29,12 @@
 #ifndef __EC_PDO_H__
 #define __EC_PDO_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 #include "pdo_entry.h"
 
 /****************************************************************************/
diff --git a/master/pdo_entry.c b/master/pdo_entry.c
index 836cb3df..6d7b3f1d 100644
--- a/master/pdo_entry.c
+++ b/master/pdo_entry.c
@@ -26,7 +26,10 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/slab.h>
+#endif
 
 #include "pdo_entry.h"
 
@@ -68,7 +71,11 @@ int ec_pdo_entry_init_copy(
 void ec_pdo_entry_clear(ec_pdo_entry_t *entry /**< PDO entry. */)
 {
     if (entry->name)
+#ifdef EC_USERMODE
+        free(entry->name);
+#else
         kfree(entry->name);
+#endif
 }
 
 /****************************************************************************/
@@ -89,10 +96,18 @@ int ec_pdo_entry_set_name(
         return 0;
 
     if (entry->name)
+#ifdef EC_USERMODE
+        free(entry->name);
+#else
         kfree(entry->name);
+#endif
 
     if (name && (len = strlen(name))) {
+#ifdef EC_USERMODE
+        if (!(entry->name = (char *) malloc(len + 1))) {
+#else
         if (!(entry->name = (char *) kmalloc(len + 1, GFP_KERNEL))) {
+#endif
             EC_ERR("Failed to allocate PDO entry name.\n");
             return -ENOMEM;
         }
diff --git a/master/pdo_entry.h b/master/pdo_entry.h
index 96dc41eb..0ef4fb2d 100644
--- a/master/pdo_entry.h
+++ b/master/pdo_entry.h
@@ -29,9 +29,12 @@
 #ifndef __EC_PDO_ENTRY_H__
 #define __EC_PDO_ENTRY_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 
 /****************************************************************************/
 
diff --git a/master/pdo_list.c b/master/pdo_list.c
index f26b1c88..7af87998 100644
--- a/master/pdo_list.c
+++ b/master/pdo_list.c
@@ -24,9 +24,14 @@
    EtherCAT PDO list methods.
 */
 
-/****************************************************************************/
+/*****************************************************************************/
+#include "globals.h"
 
+#ifdef EC_USERMODE
+#include "mm.h"
+#else
 #include <linux/module.h>
+#endif
 
 #include "globals.h"
 #include "pdo.h"
@@ -66,7 +71,11 @@ void ec_pdo_list_clear_pdos(ec_pdo_list_t *pl /**< PDO list. */)
     list_for_each_entry_safe(pdo, next, &pl->list, list) {
         list_del_init(&pdo->list);
         ec_pdo_clear(pdo);
+#ifdef EC_USERMODE
+        free(pdo);
+#else
         kfree(pdo);
+#endif
     }
 }
 
@@ -113,7 +122,11 @@ ec_pdo_t *ec_pdo_list_add_pdo(
 {
     ec_pdo_t *pdo;
 
+#ifdef EC_USERMODE
+    if (!(pdo = (ec_pdo_t *) malloc(sizeof(ec_pdo_t)))) {
+#else
     if (!(pdo = (ec_pdo_t *) kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate memory for PDO.\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -145,14 +158,22 @@ int ec_pdo_list_add_pdo_copy(
         return -EEXIST;
     }
 
+#ifdef EC_USERMODE
+    if (!(mapped_pdo = malloc(sizeof(ec_pdo_t)))) {
+#else
     if (!(mapped_pdo = kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate PDO memory.\n");
         return -ENOMEM;
     }
 
     ret = ec_pdo_init_copy(mapped_pdo, pdo);
     if (ret < 0) {
+#ifdef EC_USERMODE
+        free(mapped_pdo);
+#else
         kfree(mapped_pdo);
+#endif
         return ret;
     }
 
@@ -325,12 +346,12 @@ void ec_pdo_list_print(
     const ec_pdo_t *pdo;
 
     if (list_empty(&pl->list)) {
-        printk(KERN_CONT "(none)");
+        ec_print(EC_CONT "(none)");
     } else {
         list_for_each_entry(pdo, &pl->list, list) {
-            printk(KERN_CONT "0x%04X", pdo->index);
+            ec_print(EC_CONT "0x%04X", pdo->index);
             if (pdo->list.next != &pl->list)
-                printk(KERN_CONT " ");
+                ec_print(EC_CONT " ");
         }
     }
 }
diff --git a/master/pdo_list.h b/master/pdo_list.h
index 5bd9be7f..4d2e0d83 100644
--- a/master/pdo_list.h
+++ b/master/pdo_list.h
@@ -29,9 +29,12 @@
 #ifndef __EC_PDO_LIST_H__
 #define __EC_PDO_LIST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 #include "pdo.h"
 
 /****************************************************************************/
diff --git a/master/reg_request.c b/master/reg_request.c
index eab70b1d..3b2edb2b 100644
--- a/master/reg_request.c
+++ b/master/reg_request.c
@@ -25,9 +25,15 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "mm.h"
+#else
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
+#endif
 
 #include "reg_request.h"
 
@@ -42,7 +48,11 @@ int ec_reg_request_init(
         size_t size /**< Memory size. */
         )
 {
+#ifdef EC_USERMODE
+    if (!(reg->data = (uint8_t *) malloc(size))) {
+#else
     if (!(reg->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate %zu bytes of register memory.\n", size);
         return -ENOMEM;
     }
@@ -67,7 +77,11 @@ void ec_reg_request_clear(
         )
 {
     if (reg->data) {
+#ifdef EC_USERMODE
+        free(reg->data);
+#else
         kfree(reg->data);
+#endif
     }
 }
 
@@ -115,11 +129,12 @@ int ecrt_reg_request_read(ec_reg_request_t *reg, uint16_t address,
 
 /** \cond */
 
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_reg_request_data);
 EXPORT_SYMBOL(ecrt_reg_request_state);
 EXPORT_SYMBOL(ecrt_reg_request_write);
 EXPORT_SYMBOL(ecrt_reg_request_read);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/reg_request.h b/master/reg_request.h
index 86876b64..32934c08 100644
--- a/master/reg_request.h
+++ b/master/reg_request.h
@@ -29,9 +29,12 @@
 #ifndef __EC_REG_REQUEST_H__
 #define __EC_REG_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 
 /****************************************************************************/
 
diff --git a/master/rt_locks.h b/master/rt_locks.h
index bfe59217..3d95fab0 100644
--- a/master/rt_locks.h
+++ b/master/rt_locks.h
@@ -30,18 +30,19 @@
 #define __EC_LOCKS_H__
 
 #include "globals.h"
+#ifdef EC_USERMODE
+#include <semaphore.h>
+#else
 #include <linux/version.h>
-
 #include <linux/semaphore.h>
+#endif
 
 /****************************************************************************/
 
 #ifdef EC_USE_RTMUTEX
 
 #include <linux/rtmutex.h>
-
 typedef struct rt_mutex ec_lock_t;
-
 static inline void ec_lock_init(ec_lock_t *sem) { rt_mutex_init(sem); }
 static inline void ec_lock_down(ec_lock_t *sem) { rt_mutex_lock(sem); }
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 34)
@@ -57,14 +58,41 @@ static inline void ec_lock_up(ec_lock_t *sem) { rt_mutex_unlock(sem); }
 
 #else
 
+#ifdef EC_USERMODE
+typedef sem_t ec_lock_t;
+#else
 typedef struct semaphore ec_lock_t;
+#endif
 
-static inline void ec_lock_init(ec_lock_t *sem) { sema_init(sem, 1); }
-static inline void ec_lock_down(ec_lock_t *sem) { down(sem); }
+static inline void ec_lock_init(ec_lock_t *sem) { 
+#ifdef EC_USERMODE
+	sem_init(sem, 0, 1);
+#else
+	sema_init(sem, 1);
+#endif
+}
+
+static inline void ec_lock_down(ec_lock_t *sem) {
+#ifdef EC_USERMODE
+	sem_wait(sem);
+#else
+	down(sem);
+#endif
+}
 static inline int ec_lock_down_interruptible(ec_lock_t *sem) {
+#ifdef EC_USERMODE
+    return sem_wait(sem);
+#else
     return down_interruptible(sem);
+#endif
+}
+static inline void ec_lock_up(ec_lock_t *sem) {
+#ifdef EC_USERMODE
+	sem_post(sem);
+#else
+	up(sem);
+#endif
 }
-static inline void ec_lock_up(ec_lock_t *sem) { up(sem); }
 
 #endif
 
diff --git a/master/rtdm.c b/master/rtdm.c
index 0112e1a7..098516d7 100644
--- a/master/rtdm.c
+++ b/master/rtdm.c
@@ -23,19 +23,20 @@
 /** \file
  * RTDM interface.
  */
-
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/mman.h>
 
-
+/* include last because it does some redefinitions */
+#include <rtdm/rtdm_driver.h>
+#endif
 #include "master.h"
 #include "ioctl.h"
 #include "rtdm.h"
 #include "rtdm_details.h"
 
-/* include last because it does some redefinitions */
-#include <rtdm/rtdm_driver.h>
 
 /** Set to 1 to enable device operations debugging.
  */
diff --git a/master/sdo.c b/master/sdo.c
index 3b8d3ac6..1bb6afdc 100644
--- a/master/sdo.c
+++ b/master/sdo.c
@@ -26,7 +26,12 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/slab.h>
+#else
+#include "mm.h"
+#endif
 
 #include "master.h"
 
@@ -66,11 +71,19 @@ void ec_sdo_clear(
     list_for_each_entry_safe(entry, next, &sdo->entries, list) {
         list_del(&entry->list);
         ec_sdo_entry_clear(entry);
+#ifdef EC_USERMODE
+        free(entry);
+#else
         kfree(entry);
+#endif
     }
 
     if (sdo->name)
+#ifdef EC_USERMODE
+        free(sdo->name);
+#else
         kfree(sdo->name);
+#endif
 }
 
 /****************************************************************************/
diff --git a/master/sdo.h b/master/sdo.h
index 5426bcaa..01f214dd 100644
--- a/master/sdo.h
+++ b/master/sdo.h
@@ -29,9 +29,13 @@
 #ifndef __EC_SDO_H__
 #define __EC_SDO_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
-#include "globals.h"
 #include "sdo_entry.h"
 
 /****************************************************************************/
diff --git a/master/sdo_entry.c b/master/sdo_entry.c
index ae4b3661..8da9ae8b 100644
--- a/master/sdo_entry.c
+++ b/master/sdo_entry.c
@@ -26,7 +26,12 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/slab.h>
+#else
+#include <mm.h>
+#endif
 
 #include "sdo_entry.h"
 
@@ -63,7 +68,11 @@ void ec_sdo_entry_clear(
 {
 
     if (entry->description)
+#ifdef EC_USERMODE
+        free(entry->description);
+#else
         kfree(entry->description);
+#endif
 }
 
 /****************************************************************************/
diff --git a/master/sdo_entry.h b/master/sdo_entry.h
index 87c92bbd..3e0b418f 100644
--- a/master/sdo_entry.h
+++ b/master/sdo_entry.h
@@ -29,10 +29,14 @@
 #ifndef __EC_SDO_ENTRY_H__
 #define __EC_SDO_ENTRY_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
 #include <linux/kobject.h>
-
-#include "globals.h"
+#endif
 
 /****************************************************************************/
 
diff --git a/master/sdo_request.c b/master/sdo_request.c
index 040c6b5d..55b21d8d 100644
--- a/master/sdo_request.c
+++ b/master/sdo_request.c
@@ -25,9 +25,14 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
+#else
+#include "mm.h"
+#endif
 
 #include "sdo_request.h"
 
@@ -59,7 +64,7 @@ void ec_sdo_request_init(
     req->state = EC_INT_REQUEST_INIT;
     req->jiffies_start = 0U;
     req->jiffies_sent = 0U;
-    req->errno = 0;
+    req->err = 0;
     req->abort_code = 0x00000000;
 }
 
@@ -102,7 +107,11 @@ void ec_sdo_request_clear_data(
         )
 {
     if (req->data) {
+#ifdef EC_USERMODE
+        free(req->data);
+#else
         kfree(req->data);
+#endif
         req->data = NULL;
     }
 
@@ -128,7 +137,11 @@ int ec_sdo_request_alloc(
 
     ec_sdo_request_clear_data(req);
 
+#ifdef EC_USERMODE
+    if (!(req->data = (uint8_t *) malloc(size))) {
+#else
     if (!(req->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate %zu bytes of SDO memory.\n", size);
         return -ENOMEM;
     }
@@ -170,8 +183,14 @@ int ec_sdo_request_copy_data(
  */
 int ec_sdo_request_timed_out(const ec_sdo_request_t *req /**< SDO request. */)
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    return req->issue_timeout
+        && jiffies - req->jiffies_start > NSEC_PER_SEC * req->issue_timeout / 1000;
+#else
     return req->issue_timeout
         && jiffies - req->jiffies_start > HZ * req->issue_timeout / 1000;
+#endif
 }
 
 /*****************************************************************************
@@ -210,7 +229,11 @@ size_t ecrt_sdo_request_data_size(const ec_sdo_request_t *req)
 
 /****************************************************************************/
 
-ec_request_state_t ecrt_sdo_request_state(const ec_sdo_request_t *req)
+ec_request_state_t ecrt_sdo_request_state(
+#ifdef __KERNEL__
+		const
+#endif	
+		ec_sdo_request_t *req)
 {
    return ec_request_state_translation_table[req->state];
 }
@@ -219,9 +242,12 @@ ec_request_state_t ecrt_sdo_request_state(const ec_sdo_request_t *req)
 
 int ecrt_sdo_request_read(ec_sdo_request_t *req)
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->dir = EC_DIR_INPUT;
     req->state = EC_INT_REQUEST_QUEUED;
-    req->errno = 0;
+    req->err = 0;
     req->abort_code = 0x00000000;
     req->jiffies_start = jiffies;
     return 0;
@@ -231,9 +257,12 @@ int ecrt_sdo_request_read(ec_sdo_request_t *req)
 
 int ecrt_sdo_request_write(ec_sdo_request_t *req)
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->dir = EC_DIR_OUTPUT;
     req->state = EC_INT_REQUEST_QUEUED;
-    req->errno = 0;
+    req->err = 0;
     req->abort_code = 0x00000000;
     req->jiffies_start = jiffies;
     return 0;
@@ -242,7 +271,7 @@ int ecrt_sdo_request_write(ec_sdo_request_t *req)
 /****************************************************************************/
 
 /** \cond */
-
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_sdo_request_index);
 EXPORT_SYMBOL(ecrt_sdo_request_timeout);
 EXPORT_SYMBOL(ecrt_sdo_request_data);
@@ -250,7 +279,7 @@ EXPORT_SYMBOL(ecrt_sdo_request_data_size);
 EXPORT_SYMBOL(ecrt_sdo_request_state);
 EXPORT_SYMBOL(ecrt_sdo_request_read);
 EXPORT_SYMBOL(ecrt_sdo_request_write);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/sdo_request.h b/master/sdo_request.h
index aa2d1849..1b37e4a8 100644
--- a/master/sdo_request.h
+++ b/master/sdo_request.h
@@ -29,9 +29,12 @@
 #ifndef __EC_SDO_REQUEST_H__
 #define __EC_SDO_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
+#include <linux/list.h>
+#endif
 
 /****************************************************************************/
 
@@ -56,7 +59,7 @@ struct ec_sdo_request {
     unsigned long jiffies_start; /**< Jiffies, when the request was issued. */
     unsigned long jiffies_sent; /**< Jiffies, when the upload/download
                                      request was sent. */
-    int errno; /**< Error number. */
+    int err; /**< Error number. */
     uint32_t abort_code; /**< SDO request abort code. Zero on success. */
 };
 
@@ -69,7 +72,6 @@ int ec_sdo_request_copy(ec_sdo_request_t *, const ec_sdo_request_t *);
 int ec_sdo_request_alloc(ec_sdo_request_t *, size_t);
 int ec_sdo_request_copy_data(ec_sdo_request_t *, const uint8_t *, size_t);
 int ec_sdo_request_timed_out(const ec_sdo_request_t *);
-
 /****************************************************************************/
 
 #endif
diff --git a/master/slave.c b/master/slave.c
index 04cf2151..20c70794 100644
--- a/master/slave.c
+++ b/master/slave.c
@@ -26,10 +26,14 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/delay.h>
-
-#include "globals.h"
+#else
+#include "mm.h"
+#include "list.h"
+#endif
 #include "datagram.h"
 #include "master.h"
 #include "slave_config.h"
@@ -231,14 +235,26 @@ void ec_slave_clear(ec_slave_t *slave /**< EtherCAT slave */)
     list_for_each_entry_safe(sdo, next_sdo, &slave->sdo_dictionary, list) {
         list_del(&sdo->list);
         ec_sdo_clear(sdo);
+#ifdef EC_USERMODE
+        free(sdo);
+#else
         kfree(sdo);
+#endif
     }
 
     // free all strings
     if (slave->sii.strings) {
         for (i = 0; i < slave->sii.string_count; i++)
+#ifdef EC_USERMODE
+            free(slave->sii.strings[i]);
+#else
             kfree(slave->sii.strings[i]);
+#endif
+#ifdef EC_USERMODE
+        free(slave->sii.strings);
+#else
         kfree(slave->sii.strings);
+#endif
     }
 
     // free all sync managers
@@ -248,11 +264,19 @@ void ec_slave_clear(ec_slave_t *slave /**< EtherCAT slave */)
     list_for_each_entry_safe(pdo, next_pdo, &slave->sii.pdos, list) {
         list_del(&pdo->list);
         ec_pdo_clear(pdo);
+#ifdef EC_USERMODE
+        free(pdo);
+#else
         kfree(pdo);
+#endif
     }
 
     if (slave->sii_words) {
+#ifdef EC_USERMODE
+        free(slave->sii_words);
+#else
         kfree(slave->sii_words);
+#endif
     }
 
     ec_fsm_slave_clear(&slave->fsm);
@@ -270,7 +294,11 @@ void ec_slave_clear_sync_managers(ec_slave_t *slave /**< EtherCAT slave. */)
         for (i = 0; i < slave->sii.sync_count; i++) {
             ec_sync_clear(&slave->sii.syncs[i]);
         }
+#ifdef EC_USERMODE
+        free(slave->sii.syncs);
+#else
         kfree(slave->sii.syncs);
+#endif
         slave->sii.syncs = NULL;
     }
 }
@@ -333,8 +361,12 @@ int ec_slave_fetch_sii_strings(
 
     if (slave->sii.string_count) {
         if (!(slave->sii.strings =
+#ifdef EC_USERMODE
+                    malloc(sizeof(char *) * slave->sii.string_count))) {
+#else
                     kmalloc(sizeof(char *) * slave->sii.string_count,
                         GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate string array memory.\n");
             err = -ENOMEM;
             goto out_zero;
@@ -345,7 +377,11 @@ int ec_slave_fetch_sii_strings(
             size = data[offset];
             // allocate memory for string structure and data at a single blow
             if (!(slave->sii.strings[i] =
+#ifdef EC_USERMODE
+                        malloc(sizeof(char *) * slave->sii.string_count))) {
+#else
                         kmalloc(sizeof(char) * size + 1, GFP_KERNEL))) {
+#endif
                 EC_SLAVE_ERR(slave, "Failed to allocate string memory.\n");
                 err = -ENOMEM;
                 goto out_free;
@@ -360,8 +396,16 @@ int ec_slave_fetch_sii_strings(
 
 out_free:
     for (i--; i >= 0; i--)
+#ifdef EC_USERMODE
+        free(slave->sii.strings[i]);
+#else
         kfree(slave->sii.strings[i]);
+#endif
+#ifdef EC_USERMODE
+    free(slave->sii.strings);
+#else
     kfree(slave->sii.strings);
+#endif
     slave->sii.strings = NULL;
 out_zero:
     slave->sii.string_count = 0;
@@ -455,7 +499,11 @@ int ec_slave_fetch_sii_syncs(
             return -EOVERFLOW;
         }
         memsize = sizeof(ec_sync_t) * total_count;
+#ifdef EC_USERMODE
+        if (!(syncs = malloc(memsize))) {
+#else
         if (!(syncs = kmalloc(memsize, GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate %zu bytes"
                     " for sync managers.\n", memsize);
             return -ENOMEM;
@@ -477,7 +525,11 @@ int ec_slave_fetch_sii_syncs(
         }
 
         if (slave->sii.syncs)
+#ifdef EC_USERMODE
+            free(slave->sii.syncs);
+#else
             kfree(slave->sii.syncs);
+#endif
         slave->sii.syncs = syncs;
         slave->sii.sync_count = total_count;
     }
@@ -505,7 +557,11 @@ int ec_slave_fetch_sii_pdos(
     unsigned int entry_count, i;
 
     while (data_size >= 8) {
+#ifdef EC_USERMODE
+        if (!(pdo = malloc(sizeof(ec_pdo_t)))) {
+#else
         if (!(pdo = kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+#endif
             EC_SLAVE_ERR(slave, "Failed to allocate PDO memory.\n");
             return -ENOMEM;
         }
@@ -518,7 +574,11 @@ int ec_slave_fetch_sii_pdos(
                 ec_slave_sii_string(slave, EC_READ_U8(data + 5)));
         if (ret) {
             ec_pdo_clear(pdo);
+#ifdef EC_USERMODE
+            free(pdo);
+#else
             kfree(pdo);
+#endif
             return ret;
         }
         list_add_tail(&pdo->list, &slave->sii.pdos);
@@ -527,7 +587,11 @@ int ec_slave_fetch_sii_pdos(
         data += 8;
 
         for (i = 0; i < entry_count; i++) {
+#ifdef EC_USERMODE
+            if (!(entry = malloc(sizeof(ec_pdo_entry_t)))) {
+#else
             if (!(entry = kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+#endif
                 EC_SLAVE_ERR(slave, "Failed to allocate PDO entry memory.\n");
                 return -ENOMEM;
             }
@@ -539,7 +603,11 @@ int ec_slave_fetch_sii_pdos(
                     ec_slave_sii_string(slave, EC_READ_U8(data + 3)));
             if (ret) {
                 ec_pdo_entry_clear(entry);
+#ifdef EC_USERMODE
+                free(entry);
+#else
                 kfree(entry);
+#endif
                 return ret;
             }
             entry->bit_length = EC_READ_U8(data + 5);
diff --git a/master/slave.h b/master/slave.h
index 4e113e28..e5ccad25 100644
--- a/master/slave.h
+++ b/master/slave.h
@@ -29,10 +29,17 @@
 #ifndef __EC_SLAVE_H__
 #define __EC_SLAVE_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#include <pthread.h>
+#else
 #include <linux/list.h>
 #include <linux/kobject.h>
+#include <linux/rtmutex.h>
+#endif
 
-#include "globals.h"
 #include "datagram.h"
 #include "pdo.h"
 #include "sync.h"
@@ -52,7 +59,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_INFO(slave, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u-%u: " fmt, slave->master->index, \
+    ec_print(EC_INFO_LEVEL "EtherCAT %u-%u: " fmt, slave->master->index, \
             slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific errors to syslog.
@@ -66,7 +73,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_ERR(slave, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u-%u: " fmt, slave->master->index, \
+    ec_print(EC_ERR_LEVEL "EtherCAT ERROR %u-%u: " fmt, slave->master->index, \
             slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific warnings to syslog.
@@ -80,7 +87,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_WARN(slave, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u-%u: " fmt, \
+    ec_print(EC_WARNING_LEVEL "EtherCAT WARNING %u-%u: " fmt, \
             slave->master->index, slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific debug messages to syslog.
@@ -98,7 +105,7 @@
 #define EC_SLAVE_DBG(slave, level, fmt, args...) \
     do { \
         if (slave->master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u-%u: " fmt, \
+            ec_print(EC_DEBUG_LEVEL "EtherCAT DEBUG %u-%u: " fmt, \
                     slave->master->index, slave->ring_position, ##args); \
         } \
     } while (0)
diff --git a/master/slave_config.c b/master/slave_config.c
index 87e81a6c..34de0557 100644
--- a/master/slave_config.c
+++ b/master/slave_config.c
@@ -40,8 +40,10 @@
 #include "eoe_request.h"
 #endif
 
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/slab.h>
+#endif
 
 /****************************************************************************/
 
@@ -145,49 +147,77 @@ void ec_slave_config_clear(
     list_for_each_entry_safe(req, next_req, &sc->sdo_configs, list) {
         list_del(&req->list);
         ec_sdo_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
     }
 
     // free all SDO requests
     list_for_each_entry_safe(req, next_req, &sc->sdo_requests, list) {
         list_del(&req->list);
         ec_sdo_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
     }
 
     // free all SoE requests
     list_for_each_entry_safe(soe, next_soe, &sc->soe_requests, list) {
         list_del(&soe->list);
         ec_soe_request_clear(soe);
+#ifdef EC_USERMODE
+        free(soe);
+#else
         kfree(soe);
+#endif
     }
 
     // free all register requests
     list_for_each_entry_safe(reg, next_reg, &sc->reg_requests, list) {
         list_del(&reg->list);
         ec_reg_request_clear(reg);
+#ifdef EC_USERMODE
+        free(reg;
+#else
         kfree(reg);
+#endif
     }
 
     // free all VoE handlers
     list_for_each_entry_safe(voe, next_voe, &sc->voe_handlers, list) {
         list_del(&voe->list);
         ec_voe_handler_clear(voe);
+#ifdef EC_USERMODE
+        free(voe);
+#else
         kfree(voe);
+#endif
     }
 
     // free all SoE configurations
     list_for_each_entry_safe(soe, next_soe, &sc->soe_configs, list) {
         list_del(&soe->list);
         ec_soe_request_clear(soe);
+#ifdef EC_USERMODE
+        free(soe);
+#else
         kfree(soe);
+#endif
     }
 
     // free all flags
     list_for_each_entry_safe(flag, next_flag, &sc->flags, list) {
         list_del(&flag->list);
         ec_flag_clear(flag);
+#ifdef EC_USERMODE
+        free(flag);
+#else
         kfree(flag);
+#endif
     }
 
     // free all AL timeouts
@@ -237,9 +267,9 @@ int ec_slave_config_prepare_fmmu(
 
     fmmu = &sc->fmmu_configs[sc->used_fmmus++];
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     ec_fmmu_config_init(fmmu, sc, domain, sync_index, dir);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return fmmu->logical_start_address;
 }
@@ -322,6 +352,9 @@ void ec_slave_config_detach(
         list_for_each_entry(reg, &sc->reg_requests, list) {
             if (sc->slave->fsm.reg_request == reg) {
                 sc->slave->fsm.reg_request = NULL;
+#ifdef EC_USERMODE
+                wake_up_all(&sc->slave->master->request_queue);
+#endif
                 break;
             }
         }
@@ -729,18 +762,18 @@ int ecrt_slave_config_pdo_assign_add(ec_slave_config_t *sc,
         return -EINVAL;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
 
     pdo = ec_pdo_list_add_pdo(&sc->sync_configs[sync_index].pdos, pdo_index);
     if (IS_ERR(pdo)) {
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
         return PTR_ERR(pdo);
     }
     pdo->sync_index = sync_index;
 
     ec_slave_config_load_default_mapping(sc, pdo);
 
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -757,9 +790,9 @@ int ecrt_slave_config_pdo_assign_clear(ec_slave_config_t *sc,
         return -EINVAL;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     ec_pdo_list_clear_pdos(&sc->sync_configs[sync_index].pdos);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -786,10 +819,10 @@ int ecrt_slave_config_pdo_mapping_add(ec_slave_config_t *sc,
             break;
 
     if (pdo) {
-        down(&sc->master->master_sem);
+        ec_lock_down(&sc->master->master_sem);
         entry = ec_pdo_add_entry(pdo, entry_index, entry_subindex,
                 entry_bit_length);
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
         if (IS_ERR(entry))
             retval = PTR_ERR(entry);
     } else {
@@ -817,9 +850,9 @@ int ecrt_slave_config_pdo_mapping_clear(ec_slave_config_t *sc,
             break;
 
     if (pdo) {
-        down(&sc->master->master_sem);
+        ec_lock_down(&sc->master->master_sem);
         ec_pdo_clear_entries(pdo);
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
     } else {
         EC_CONFIG_WARN(sc, "PDO 0x%04X is not assigned.\n", pdo_index);
     }
@@ -1051,7 +1084,11 @@ int ecrt_slave_config_sdo(ec_slave_config_t *sc, uint16_t index,
     }
 
     if (!(req = (ec_sdo_request_t *)
+#ifdef EC_USERMODE
+          malloc(sizeof(ec_sdo_request_t)))) {
+#else
           kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " SDO configuration!\n");
         return -ENOMEM;
@@ -1063,13 +1100,17 @@ int ecrt_slave_config_sdo(ec_slave_config_t *sc, uint16_t index,
     ret = ec_sdo_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -1135,7 +1176,11 @@ int ecrt_slave_config_complete_sdo(ec_slave_config_t *sc, uint16_t index,
     }
 
     if (!(req = (ec_sdo_request_t *)
+#ifdef EC_USERMODE
+          malloc(sizeof(ec_sdo_request_t)))) {
+#else
           kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " SDO configuration!\n");
         return -ENOMEM;
@@ -1148,13 +1193,17 @@ int ecrt_slave_config_complete_sdo(ec_slave_config_t *sc, uint16_t index,
     ret = ec_sdo_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -1202,7 +1251,11 @@ ec_sdo_request_t *ecrt_slave_config_create_sdo_request_err(
             __func__, sc, index, subindex, size);
 
     if (!(req = (ec_sdo_request_t *)
+#ifdef EC_USERMODE
+                malloc(sizeof(ec_sdo_request_t)))) {
+#else
                 kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate SDO request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -1213,7 +1266,11 @@ ec_sdo_request_t *ecrt_slave_config_create_sdo_request_err(
     ret = ec_sdo_request_alloc(req, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
         return ERR_PTR(ret);
     }
 
@@ -1221,9 +1278,9 @@ ec_sdo_request_t *ecrt_slave_config_create_sdo_request_err(
     memset(req->data, 0x00, size);
     req->data_size = size;
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_requests);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return req;
 }
@@ -1253,8 +1310,13 @@ ec_soe_request_t *ecrt_slave_config_create_soe_request_err(
             "drive_no = 0x%02X, idn = 0x%04X, size = %zu)\n",
             __func__, sc, drive_no, idn, size);
 
+#ifdef EC_USERMODE
+    if (!(req = (ec_soe_request_t *)
+                malloc(sizeof(ec_soe_request_t)))) {
+#else
     if (!(req = (ec_soe_request_t *)
                 kmalloc(sizeof(ec_soe_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate IDN request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -1265,7 +1327,11 @@ ec_soe_request_t *ecrt_slave_config_create_soe_request_err(
     ret = ec_soe_request_alloc(req, size);
     if (ret < 0) {
         ec_soe_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
         return ERR_PTR(ret);
     }
 
@@ -1273,9 +1339,9 @@ ec_soe_request_t *ecrt_slave_config_create_soe_request_err(
     memset(req->data, 0x00, size);
     req->data_size = size;
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->soe_requests);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return req;
 }
@@ -1304,21 +1370,30 @@ ec_reg_request_t *ecrt_slave_config_create_reg_request_err(
     EC_CONFIG_DBG(sc, 1, "%s(sc = 0x%p, size = %zu)\n",
             __func__, sc, size);
 
+#ifdef EC_USERMODE
+    if (!(reg = (ec_reg_request_t *)
+                malloc(sizeof(ec_reg_request_t)))) {
+#else
     if (!(reg = (ec_reg_request_t *)
                 kmalloc(sizeof(ec_reg_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate register request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
     ret = ec_reg_request_init(reg, size);
     if (ret) {
+#ifdef EC_USERMODE
+        free(reg);
+#else
         kfree(reg);
+#endif
         return ERR_PTR(ret);
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&reg->list, &sc->reg_requests);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return reg;
 }
@@ -1347,20 +1422,28 @@ ec_voe_handler_t *ecrt_slave_config_create_voe_handler_err(
     EC_CONFIG_DBG(sc, 1, "%s(sc = 0x%p, size = %zu)\n", __func__, sc, size);
 
     if (!(voe = (ec_voe_handler_t *)
+#ifdef EC_USERMODE
+                malloc(sizeof(ec_voe_handler_t)))) {
+#else
                 kmalloc(sizeof(ec_voe_handler_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate VoE request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
     ret = ec_voe_handler_init(voe, sc, size);
     if (ret < 0) {
+#ifdef EC_USERMODE
+        free(voe);
+#else
         kfree(voe);
+#endif
         return ERR_PTR(ret);
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&voe->list, &sc->voe_handlers);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return voe;
 }
@@ -1425,7 +1508,11 @@ int ecrt_slave_config_idn(ec_slave_config_t *sc, uint8_t drive_no,
     }
 
     if (!(req = (ec_soe_request_t *)
+#ifdef EC_USERMODE
+          malloc(sizeof(ec_soe_request_t)))) {
+#else
           kmalloc(sizeof(ec_soe_request_t), GFP_KERNEL))) {
+#endif
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " IDN configuration!\n");
         return -ENOMEM;
@@ -1439,13 +1526,17 @@ int ecrt_slave_config_idn(ec_slave_config_t *sc, uint8_t drive_no,
     ret = ec_soe_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_soe_request_clear(req);
+#ifdef EC_USERMODE
+        free(req);
+#else
         kfree(req);
+#endif
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->soe_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -1466,21 +1557,28 @@ int ecrt_slave_config_flag(ec_slave_config_t *sc, const char *key,
     }
     else { // new flag
         int ret;
-
+#ifdef EC_USERMODE
+        if (!(flag = (ec_flag_t *) malloc(sizeof(ec_flag_t)))) {
+#else
         if (!(flag = (ec_flag_t *) kmalloc(sizeof(ec_flag_t), GFP_KERNEL))) {
+#endif
             EC_CONFIG_ERR(sc, "Failed to allocate memory for flag!\n");
             return -ENOMEM;
         }
 
         ret = ec_flag_init(flag, key, value);
         if (ret) {
+#ifdef EC_USERMODE
+            free(flag);
+#else
             kfree(flag);
+#endif
             return ret;
         }
 
-        down(&sc->master->master_sem);
+        ec_lock_down(&sc->master->master_sem);
         list_add_tail(&flag->list, &sc->flags);
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
     }
     return 0;
 }
@@ -1611,6 +1709,7 @@ int ecrt_slave_config_state_timeout(ec_slave_config_t *sc,
 
 /** \cond */
 
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_slave_config_sync_manager);
 EXPORT_SYMBOL(ecrt_slave_config_watchdog);
 EXPORT_SYMBOL(ecrt_slave_config_pdo_assign_add);
@@ -1647,6 +1746,7 @@ EXPORT_SYMBOL(ecrt_slave_config_eoe_hostname);
 #endif
 EXPORT_SYMBOL(ecrt_slave_config_state_timeout);
 
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/slave_config.h b/master/slave_config.h
index 124995c2..9fcf67a6 100644
--- a/master/slave_config.h
+++ b/master/slave_config.h
@@ -29,9 +29,13 @@
 #ifndef __EC_SLAVE_CONFIG_H__
 #define __EC_SLAVE_CONFIG_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
-#include "globals.h"
 #include "slave.h"
 #include "sync_config.h"
 #include "fmmu_config.h"
@@ -52,7 +56,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_INFO(sc, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u %u:%u: " fmt, sc->master->index, \
+    ec_print(EC_INFO_LEVEL "EtherCAT %u %u:%u: " fmt, sc->master->index, \
             sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific errors to syslog.
@@ -66,7 +70,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_ERR(sc, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u %u:%u: " fmt, sc->master->index, \
+    ec_print(EC_ERR_LEVEL "EtherCAT ERROR %u %u:%u: " fmt, sc->master->index, \
             sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific warnings to syslog.
@@ -80,7 +84,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_WARN(sc, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u %u:%u: " fmt, \
+    ec_print(EC_WARNING_LEVEL "EtherCAT WARNING %u %u:%u: " fmt, \
             sc->master->index, sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific debug messages to
@@ -99,7 +103,7 @@
 #define EC_CONFIG_DBG(sc, level, fmt, args...) \
     do { \
         if (sc->master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u %u:%u: " fmt, \
+            ec_print(EC_DEBUG_LEVEL "EtherCAT DEBUG %u %u:%u: " fmt, \
                     sc->master->index, sc->alias, sc->position, ##args); \
         } \
     } while (0)
diff --git a/master/soe_request.c b/master/soe_request.c
index ef90124b..05401d66 100644
--- a/master/soe_request.c
+++ b/master/soe_request.c
@@ -25,9 +25,14 @@
 
 /****************************************************************************/
 
+#include "globals.h"
+#ifndef EC_USERMODE
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
+#else
+#include "mm.h"
+#endif
 
 #include "soe_request.h"
 
@@ -125,7 +130,11 @@ void ec_soe_request_clear_data(
         )
 {
     if (req->data) {
+#ifdef EC_USERMODE
+        free(req->data);
+#else
         kfree(req->data);
+#endif
         req->data = NULL;
     }
 
@@ -151,7 +160,11 @@ int ec_soe_request_alloc(
 
     ec_soe_request_clear_data(req);
 
+#ifdef EC_USERMODE
+    if (!(req->data = (uint8_t *) malloc(size))) {
+#else
     if (!(req->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+#endif
         EC_ERR("Failed to allocate %zu bytes of SoE memory.\n", size);
         return -ENOMEM;
     }
@@ -202,14 +215,22 @@ int ec_soe_request_append_data(
 {
     if (req->data_size + size > req->mem_size) {
         size_t new_size = req->mem_size ? req->mem_size * 2 : size;
+#ifdef EC_USERMODE
+        uint8_t *new_data = (uint8_t *) malloc(new_size);
+#else
         uint8_t *new_data = (uint8_t *) kmalloc(new_size, GFP_KERNEL);
+#endif
         if (!new_data) {
             EC_ERR("Failed to allocate %zu bytes of SoE memory.\n",
                     new_size);
             return -ENOMEM;
         }
         memcpy(new_data, req->data, req->data_size);
+#ifdef EC_USERMODE
+        free(req->data);
+#else
         kfree(req->data);
+#endif
         req->data = new_data;
         req->mem_size = new_size;
     }
@@ -230,6 +251,9 @@ int ec_soe_request_read(
     req->dir = EC_DIR_INPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->error_code = 0x0000;
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->jiffies_start = jiffies;
     return 0;
 }
@@ -245,6 +269,9 @@ int ec_soe_request_write(
     req->dir = EC_DIR_OUTPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->error_code = 0x0000;
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     req->jiffies_start = jiffies;
     return 0;
 }
@@ -257,8 +284,14 @@ int ec_soe_request_write(
  */
 int ec_soe_request_timed_out(const ec_soe_request_t *req /**< SDO request. */)
 {
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+    return req->issue_timeout
+	&& jiffies - req->jiffies_start > NSEC_PER_SEC * req->issue_timeout / 1000;
+#else
     return req->issue_timeout
         && jiffies - req->jiffies_start > HZ * req->issue_timeout / 1000;
+#endif
 }
 
 /*****************************************************************************
@@ -297,7 +330,11 @@ size_t ecrt_soe_request_data_size(const ec_soe_request_t *req)
 
 /****************************************************************************/
 
-ec_request_state_t ecrt_soe_request_state(const ec_soe_request_t *req)
+ec_request_state_t ecrt_soe_request_state(
+#ifdef __KERNEL__
+		const
+#endif	
+		ec_soe_request_t *req)
 {
    return ec_request_state_translation_table[req->state];
 }
@@ -319,7 +356,7 @@ int ecrt_soe_request_write(ec_soe_request_t *req)
 /****************************************************************************/
 
 /** \cond */
-
+#ifndef EC_USERMODE
 EXPORT_SYMBOL(ecrt_soe_request_idn);
 EXPORT_SYMBOL(ecrt_soe_request_timeout);
 EXPORT_SYMBOL(ecrt_soe_request_data);
@@ -327,7 +364,7 @@ EXPORT_SYMBOL(ecrt_soe_request_data_size);
 EXPORT_SYMBOL(ecrt_soe_request_state);
 EXPORT_SYMBOL(ecrt_soe_request_read);
 EXPORT_SYMBOL(ecrt_soe_request_write);
-
+#endif
 /** \endcond */
 
 /****************************************************************************/
diff --git a/master/soe_request.h b/master/soe_request.h
index ced4c9a1..76d69ea2 100644
--- a/master/soe_request.h
+++ b/master/soe_request.h
@@ -29,9 +29,13 @@
 #ifndef __EC_SOE_REQUEST_H__
 #define __EC_SOE_REQUEST_H__
 
+#include "globals.h"
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
-#include "globals.h"
 
 /****************************************************************************/
 
diff --git a/master/voe_handler.c b/master/voe_handler.c
index fc8cf307..dff2e5fc 100644
--- a/master/voe_handler.c
+++ b/master/voe_handler.c
@@ -233,6 +233,9 @@ void ec_voe_handler_state_write_start(ec_voe_handler_t *voe)
     /* data already in datagram */
 
     voe->retries = EC_FSM_RETRIES;
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     voe->jiffies_start = jiffies;
     voe->state = ec_voe_handler_state_write_response;
 }
@@ -257,10 +260,18 @@ void ec_voe_handler_state_write_response(ec_voe_handler_t *voe)
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     if (datagram->working_counter != 1) {
         if (!datagram->working_counter) {
+#ifdef EC_USERMODE
+            unsigned long diff_ms =
+               (jiffies - voe->jiffies_start) * 1000 / NSEC_PER_SEC ;
+#else
             unsigned long diff_ms =
                 (jiffies - voe->jiffies_start) * 1000 / HZ;
+#endif
             if (diff_ms < EC_VOE_RESPONSE_TIMEOUT) {
                 EC_SLAVE_DBG(slave, 1, "Slave did not respond to"
                         " VoE write request. Retrying after %lu ms...\n",
@@ -300,6 +311,9 @@ void ec_voe_handler_state_read_start(ec_voe_handler_t *voe)
         return;
     }
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     ec_slave_mbox_prepare_check(slave, datagram); // can not fail.
 
     voe->jiffies_start = jiffies;
@@ -337,8 +351,13 @@ void ec_voe_handler_state_read_check(ec_voe_handler_t *voe)
     }
 
     if (!ec_slave_mbox_check(datagram)) {
+#ifdef EC_USERMODE
+        unsigned long diff_ms =
+            (datagram->jiffies_received - voe->jiffies_start) * 1000 / NSEC_PER_SEC;
+#else
         unsigned long diff_ms =
             (datagram->jiffies_received - voe->jiffies_start) * 1000 / HZ;
+#endif
         if (diff_ms >= EC_VOE_RESPONSE_TIMEOUT) {
             voe->state = ec_voe_handler_state_error;
             voe->request_state = EC_INT_REQUEST_FAILURE;
@@ -442,6 +461,9 @@ void ec_voe_handler_state_read_nosync_start(ec_voe_handler_t *voe)
 
     ec_slave_mbox_prepare_fetch(slave, datagram); // can not fail.
 
+#ifdef EC_USERMODE
+    uint64_t jiffies = get_jiffies();
+#endif
     voe->jiffies_start = jiffies;
     voe->retries = EC_FSM_RETRIES;
     voe->state = ec_voe_handler_state_read_nosync_response;
diff --git a/master/voe_handler.h b/master/voe_handler.h
index 8e85372c..fdab445d 100644
--- a/master/voe_handler.h
+++ b/master/voe_handler.h
@@ -29,9 +29,14 @@
 #ifndef __EC_VOE_HANDLER_H__
 #define __EC_VOE_HANDLER_H__
 
+#include "globals.h"
+
+#ifdef EC_USERMODE
+#include "list.h"
+#else
 #include <linux/list.h>
+#endif
 
-#include "globals.h"
 #include "datagram.h"
 
 /****************************************************************************/
diff --git a/master/wq.h b/master/wq.h
new file mode 100644
index 00000000..e26fdd04
--- /dev/null
+++ b/master/wq.h
@@ -0,0 +1,68 @@
+#ifndef __EC_WQ_H__
+#define __EC_WQ_H__
+
+#include "list.h"
+#include "rt_locks.h"
+
+struct wait_queue_head {
+	struct list_head list;
+	ec_lock_t lock;
+};
+
+struct wait_queue_entry {
+	struct list_head entry;
+};
+typedef struct wait_queue_head wait_queue_head_t;
+
+//typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);
+
+#define DEFINE_WAIT_FUNC(name, function) \
+	wait_queue_t name = { \
+		.private = current, \
+		.func = function, \
+		.task_list = LIST_HEAD_INIT((name).task_list), \
+	}
+
+#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)
+
+static inline void wake_up_all(wait_queue_head_t *p)
+{
+}
+
+static inline void wake_up_interruptible(wait_queue_head_t *p) 
+{
+    if (!p)
+        return;
+    ec_lock_up(&p->lock);
+}
+
+static inline void init_waitqueue_head(wait_queue_head_t *p)
+{
+    if (!p)
+        return;
+    ec_lock_init(&p->lock);
+    INIT_LIST_HEAD(&p->list);
+}
+
+#define  __wait_event(queue, condition)                             \
+do {                                                                \
+    }                                                               \
+} while (0)
+
+#define wait_event(queue, condition)                                \
+do {                                                                \
+} while(0)
+
+#define  __wait_event_interruptible(queue, condition, ret)          \
+do {                                                                \
+    }                                                               \
+} while (0)
+
+#define  wait_event_interruptible(queue, condition)                 \
+({                                                                  \
+    int __ret = 0;                                                  \
+    __ret;                                                          \
+})
+
+#endif
+
diff --git a/script/Makefile.am b/script/Makefile.am
index 37605229..301a6cbb 100644
--- a/script/Makefile.am
+++ b/script/Makefile.am
@@ -23,7 +23,10 @@
 #
 #------------------------------------------------------------------------------
 
-SUBDIRS = init.d sysconfig
+SUBDIRS = sysconfig
+
+if !ENABLE_USERMODE
+SUBDIRS += init.d
 
 sbin_SCRIPTS = ethercatctl
 
@@ -45,6 +48,7 @@ CLEANFILES = \
 if HAVE_SYSTEMD
 systemdsystemunit_DATA = ethercat.service
 endif
+endif
 
 completionsdir = $(datadir)/bash-completion/completions
 completions_DATA = ethercat.bash_completion
diff --git a/script/sysconfig/Makefile.am b/script/sysconfig/Makefile.am
index 2273c32b..5ae4c302 100644
--- a/script/sysconfig/Makefile.am
+++ b/script/sysconfig/Makefile.am
@@ -22,8 +22,14 @@
 
 sysdir = $(sysconfdir)/sysconfig
 
+if ENABLE_USERMODE
+sys_DATA = ecrt.conf
+
+EXTRA_DIST = ecrt.conf
+else
 sys_DATA = ethercat
 
 EXTRA_DIST = ethercat
+endif
 
 #------------------------------------------------------------------------------
diff --git a/script/sysconfig/ecrt.conf b/script/sysconfig/ecrt.conf
new file mode 100644
index 00000000..4731b500
--- /dev/null
+++ b/script/sysconfig/ecrt.conf
@@ -0,0 +1,15 @@
+# test
+ethercat={
+	master_id=0
+	master_mac="xx:xx:xx:xx:xx:xx"
+	debug_level=0
+	drv_argv="--lcores 3"
+}
+
+ethercat={
+	master_id=1
+	master_mac="xx:xx:xx:xx:xx:xx"
+	debug_level=0
+	drv_argv="--lcores 3"
+}
+
diff --git a/tool/CommandMaster.cpp b/tool/CommandMaster.cpp
index 9e743eeb..a6e16e28 100644
--- a/tool/CommandMaster.cpp
+++ b/tool/CommandMaster.cpp
@@ -168,6 +168,15 @@ void CommandMaster::execute(const StringVector &args)
                 }
             }
             cout << setprecision(0) << endl;
+#ifdef EC_BENCHMARK
+        cout << "      Latency data:" << endl
+            << "                                min     max     avg" << endl
+            << "        Tx total latency [ns]: " << data.devices[dev_idx].tx_latency[0][0] << "    " << data.devices[dev_idx].tx_latency[0][1] << "    " << data.devices[dev_idx].tx_latency[0][2] << endl
+            << "        Tx sw    latency [ns]: " << data.devices[dev_idx].tx_latency[1][0] << "    " << data.devices[dev_idx].tx_latency[1][1] << "    " << data.devices[dev_idx].tx_latency[1][2] << endl
+            << "        Tx hw    latency [ns]: " << data.devices[dev_idx].tx_latency[2][0] << "    " << data.devices[dev_idx].tx_latency[2][1] << "    " << data.devices[dev_idx].tx_latency[2][2] << endl
+            << "        Rx total latency [ns]: " << data.devices[dev_idx].rx_latency[0][0] << "    " << data.devices[dev_idx].rx_latency[0][1] << "    " << data.devices[dev_idx].rx_latency[0][2] << endl
+            << "        Rx sw    latency [ns]: " << data.devices[dev_idx].rx_latency[1][0] << "    " << data.devices[dev_idx].rx_latency[1][1] << "    " << data.devices[dev_idx].rx_latency[1][2] << endl;
+#endif
         }
         unsigned int lost = data.tx_count - data.rx_count;
         if (lost == 1) {
diff --git a/tool/Makefile.am b/tool/Makefile.am
index 27bce15c..64c564de 100644
--- a/tool/Makefile.am
+++ b/tool/Makefile.am
@@ -125,4 +125,13 @@ ethercat_CXXFLAGS = \
 	-Wall -DREV=$(REV) \
 	-fno-strict-aliasing
 
+if ENABLE_USERMODE
+ethercat_CXXFLAGS += \
+	-DEC_USERMODE \
+	-lrt 
+
+ethercat_LDADD = \
+	$(top_builddir)/ipc/libecat_ipc.la
+endif
+
 #-----------------------------------------------------------------------------
diff --git a/tool/MasterDevice.cpp b/tool/MasterDevice.cpp
index ac256d88..0feb023d 100644
--- a/tool/MasterDevice.cpp
+++ b/tool/MasterDevice.cpp
@@ -29,15 +29,23 @@
 #include <sstream>
 #include <iomanip>
 using namespace std;
-
+#include "globals.h"
 #include "MasterDevice.h"
 
+#ifdef EC_USERMODE
+#include "../ipc/ipc_ctrl.h"
+#endif
+
 /****************************************************************************/
 
 MasterDevice::MasterDevice(unsigned int index):
     index(index),
     masterCount(0U),
+#ifdef EC_USERMODE
+    ipcs(NULL)
+#else
     fd(-1)
+#endif
 {
 }
 
@@ -61,6 +69,11 @@ void MasterDevice::open(Permissions perm)
 {
     stringstream deviceName;
 
+#ifdef EC_USERMODE
+    if (ipcs == NULL) { // not already open
+        ec_ioctl_module_t module_data;
+       	ipc_ctrl_init(&ipcs);
+#else
     if (fd == -1) { // not already open
         ec_ioctl_module_t module_data;
         deviceName << "/dev/EtherCAT" << index;
@@ -72,6 +85,7 @@ void MasterDevice::open(Permissions perm)
                 << strerror(errno);
             throw MasterDeviceException(err);
         }
+#endif
 
         getModule(&module_data);
         if (module_data.ioctl_version_magic != EC_IOCTL_VERSION_MAGIC) {
@@ -95,17 +109,26 @@ void MasterDevice::open(Permissions perm)
 
 void MasterDevice::close()
 {
+#ifdef EC_USERMODE
+    ipc_ctrl_release(ipcs);
+    ipcs = NULL;
+#else
     if (fd != -1) {
         ::close(fd);
         fd = -1;
     }
+#endif
 }
 
 /****************************************************************************/
 
 void MasterDevice::getModule(ec_ioctl_module_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_MODULE, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_MODULE, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get module information: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -116,7 +139,11 @@ void MasterDevice::getModule(ec_ioctl_module_t *data)
 
 void MasterDevice::getMaster(ec_ioctl_master_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_MASTER, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_MASTER, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get master information: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -129,7 +156,11 @@ void MasterDevice::getConfig(ec_ioctl_config_t *data, unsigned int index)
 {
     data->config_index = index;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave configuration: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -149,7 +180,11 @@ void MasterDevice::getConfigPdo(
     data->sync_index = sync_index;
     data->pdo_pos = pdo_pos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG_PDO, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_PDO, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave config PDO: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -171,7 +206,11 @@ void MasterDevice::getConfigPdoEntry(
     data->pdo_pos = pdo_pos;
     data->entry_pos = entry_pos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG_PDO_ENTRY, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_PDO_ENTRY, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave config PDO entry: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -189,7 +228,11 @@ void MasterDevice::getConfigSdo(
     data->config_index = index;
     data->sdo_pos = sdo_pos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG_SDO, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_SDO, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave config SDO: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -207,7 +250,11 @@ void MasterDevice::getConfigIdn(
     data->config_index = index;
     data->idn_pos = pos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG_IDN, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_IDN, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave config IDN: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -225,7 +272,11 @@ void MasterDevice::getConfigFlag(
     data->config_index = index;
     data->flag_pos = pos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_CONFIG_FLAG, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_FLAG, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get slave config flag: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -238,7 +289,11 @@ void MasterDevice::getDomain(ec_ioctl_domain_t *data, unsigned int index)
 {
     data->index = index;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_DOMAIN, data)) {
+#else
     if (ioctl(fd, EC_IOCTL_DOMAIN, data)) {
+#endif
         stringstream err;
         err << "Failed to get domain: ";
         if (errno == EINVAL)
@@ -258,7 +313,11 @@ void MasterDevice::getData(ec_ioctl_domain_data_t *data,
     data->data_size = dataSize;
     data->target = mem;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_DOMAIN_DATA, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_DOMAIN_DATA, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to get domain data: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -271,7 +330,11 @@ void MasterDevice::getSlave(ec_ioctl_slave_t *slave, uint16_t slaveIndex)
 {
     slave->position = slaveIndex;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE, slave)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE, slave)) {
+#endif
         stringstream err;
         err << "Failed to get slave: ";
         if (errno == EINVAL)
@@ -293,7 +356,11 @@ void MasterDevice::getFmmu(
     fmmu->domain_index = domainIndex;
     fmmu->fmmu_index = fmmuIndex;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_DOMAIN_FMMU, fmmu)) {
+#else
     if (ioctl(fd, EC_IOCTL_DOMAIN_FMMU, fmmu)) {
+#endif
         stringstream err;
         err << "Failed to get domain FMMU: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -311,7 +378,11 @@ void MasterDevice::getSync(
     sync->slave_position = slaveIndex;
     sync->sync_index = syncIndex;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SYNC, sync)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SYNC, sync)) {
+#endif
         stringstream err;
         err << "Failed to get sync manager: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -331,7 +402,11 @@ void MasterDevice::getPdo(
     pdo->sync_index = syncIndex;
     pdo->pdo_pos = pdoPos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SYNC_PDO, pdo)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SYNC_PDO, pdo)) {
+#endif
         stringstream err;
         err << "Failed to get PDO: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -353,7 +428,11 @@ void MasterDevice::getPdoEntry(
     entry->pdo_pos = pdoPos;
     entry->entry_pos = entryPos;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SYNC_PDO_ENTRY, entry)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SYNC_PDO_ENTRY, entry)) {
+#endif
         stringstream err;
         err << "Failed to get PDO entry: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -371,7 +450,11 @@ void MasterDevice::getSdo(
     sdo->slave_position = slaveIndex;
     sdo->sdo_position = sdoPosition;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SDO, sdo)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SDO, sdo)) {
+#endif
         stringstream err;
         err << "Failed to get SDO: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -391,7 +474,11 @@ void MasterDevice::getSdoEntry(
     entry->sdo_spec = sdoSpec;
     entry->sdo_entry_subindex = entrySubindex;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SDO_ENTRY, entry)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SDO_ENTRY, entry)) {
+#endif
         stringstream err;
         err << "Failed to get SDO entry: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -404,7 +491,11 @@ void MasterDevice::readSii(
         ec_ioctl_slave_sii_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SII_READ, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SII_READ, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to read SII: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -417,7 +508,11 @@ void MasterDevice::writeSii(
         ec_ioctl_slave_sii_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SII_WRITE, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SII_WRITE, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to write SII: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -430,7 +525,11 @@ void MasterDevice::readReg(
         ec_ioctl_slave_reg_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_REG_READ, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_REG_READ, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to read register: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -443,7 +542,11 @@ void MasterDevice::writeReg(
         ec_ioctl_slave_reg_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_REG_WRITE, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_REG_WRITE, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to write register: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -456,7 +559,11 @@ void MasterDevice::readFoe(
         ec_ioctl_slave_foe_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_FOE_READ, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_FOE_READ, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to read via FoE: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -469,7 +576,11 @@ void MasterDevice::writeFoe(
         ec_ioctl_slave_foe_t *data
         )
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_FOE_WRITE, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_FOE_WRITE, data) < 0) {
+#endif
         stringstream err;
         err << "Failed to write via FoE: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -480,7 +591,11 @@ void MasterDevice::writeFoe(
 
 void MasterDevice::setDebug(unsigned int debugLevel)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_MASTER_DEBUG, &debugLevel) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_MASTER_DEBUG, debugLevel) < 0) {
+#endif
         stringstream err;
         err << "Failed to set debug level: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -491,7 +606,11 @@ void MasterDevice::setDebug(unsigned int debugLevel)
 
 void MasterDevice::rescan()
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
+#endif
         stringstream err;
         err << "Failed to command rescan: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -502,7 +621,11 @@ void MasterDevice::rescan()
 
 void MasterDevice::sdoDownload(ec_ioctl_slave_sdo_download_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SDO_DOWNLOAD, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SDO_DOWNLOAD, data) < 0) {
+#endif
         stringstream err;
         if (errno == EIO && data->abort_code) {
             throw MasterDeviceSdoAbortException(data->abort_code);
@@ -517,7 +640,11 @@ void MasterDevice::sdoDownload(ec_ioctl_slave_sdo_download_t *data)
 
 void MasterDevice::sdoUpload(ec_ioctl_slave_sdo_upload_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SDO_UPLOAD, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SDO_UPLOAD, data) < 0) {
+#endif
         stringstream err;
         if (errno == EIO && data->abort_code) {
             throw MasterDeviceSdoAbortException(data->abort_code);
@@ -540,7 +667,11 @@ void MasterDevice::requestState(
     data.slave_position = slavePosition;
     data.al_state = state;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_STATE, &data)) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_STATE, &data)) {
+#endif
         stringstream err;
         err << "Failed to request slave state: ";
         if (errno == EINVAL)
@@ -555,7 +686,11 @@ void MasterDevice::requestState(
 
 void MasterDevice::readSoe(ec_ioctl_slave_soe_read_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SOE_READ, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SOE_READ, data) < 0) {
+#endif
         if (errno == EIO && data->error_code) {
             throw MasterDeviceSoeException(data->error_code);
         } else {
@@ -570,7 +705,11 @@ void MasterDevice::readSoe(ec_ioctl_slave_soe_read_t *data)
 
 void MasterDevice::writeSoe(ec_ioctl_slave_soe_write_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_SOE_WRITE, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_SOE_WRITE, data) < 0) {
+#endif
         if (errno == EIO && data->error_code) {
             throw MasterDeviceSoeException(data->error_code);
         } else {
@@ -592,7 +731,11 @@ void MasterDevice::getEoeHandler(
 {
     eoe->eoe_index = eoeHandlerIndex;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_EOE_HANDLER, eoe)) {
+#else
     if (ioctl(fd, EC_IOCTL_EOE_HANDLER, eoe)) {
+#endif
         stringstream err;
         err << "Failed to get EoE handler: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -609,7 +752,11 @@ void MasterDevice::getIpParam(ec_ioctl_eoe_ip_t *data, uint16_t config_index)
 {
     data->config_index = config_index;
 
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_EOE_IP_PARAM, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_CONFIG_EOE_IP_PARAM, data) < 0) {
+#endif
         if (errno == EIO && data->result) {
             throw MasterDeviceEoeException(data->result);
         } else {
@@ -628,7 +775,11 @@ void MasterDevice::getIpParam(ec_ioctl_eoe_ip_t *data, uint16_t config_index)
 
 void MasterDevice::setIpParam(ec_ioctl_eoe_ip_t *data)
 {
+#ifdef EC_USERMODE
+    if (ipc_ctrl_ioctl(ipcs, EC_IOCTL_SLAVE_EOE_IP_PARAM, data) < 0) {
+#else
     if (ioctl(fd, EC_IOCTL_SLAVE_EOE_IP_PARAM, data) < 0) {
+#endif
         if (errno == EIO && data->result) {
             throw MasterDeviceEoeException(data->result);
         } else {
diff --git a/tool/MasterDevice.h b/tool/MasterDevice.h
index bb6c8a8e..28a67c74 100644
--- a/tool/MasterDevice.h
+++ b/tool/MasterDevice.h
@@ -165,7 +165,11 @@ class MasterDevice
     private:
         unsigned int index;
         unsigned int masterCount;
+#ifdef EC_USERMODE
+	char* ipcs;
+#else
         int fd;
+#endif
 };
 
 /****************************************************************************/
-- 
2.45.2

